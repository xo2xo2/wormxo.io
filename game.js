( () => {
    var s1 = Object.defineProperty
      , Yh = Object.getOwnPropertySymbols
      , n1 = Object.prototype.hasOwnProperty
      , a1 = Object.prototype.propertyIsEnumerable
      , $h = (i, e, t) => e in i ? s1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , o1 = (i, e) => {
        for (var t in e || (e = {}))
            n1.call(e, t) && $h(i, t, e[t]);
        if (Yh)
            for (var t of Yh(e))
                a1.call(e, t) && $h(i, t, e[t]);
        return i
    }
      , c1 = Object.defineProperty
      , l1 = Object.defineProperties
      , h1 = Object.getOwnPropertyDescriptors
      , Kh = Object.getOwnPropertySymbols
      , u1 = Object.prototype.hasOwnProperty
      , d1 = Object.prototype.propertyIsEnumerable
      , qh = (i, e, t) => e in i ? c1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Zh = (i, e) => {
        for (var t in e || (e = {}))
            u1.call(e, t) && qh(i, t, e[t]);
        if (Kh)
            for (var t of Kh(e))
                d1.call(e, t) && qh(i, t, e[t]);
        return i
    }
      , f1 = (i, e) => l1(i, h1(e))
      , O = (i => (i.Application = "application",
    i.WebGLPipes = "webgl-pipes",
    i.WebGLPipesAdaptor = "webgl-pipes-adaptor",
    i.WebGLSystem = "webgl-system",
    i.WebGPUPipes = "webgpu-pipes",
    i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor",
    i.WebGPUSystem = "webgpu-system",
    i.CanvasSystem = "canvas-system",
    i.CanvasPipesAdaptor = "canvas-pipes-adaptor",
    i.CanvasPipes = "canvas-pipes",
    i.Asset = "asset",
    i.LoadParser = "load-parser",
    i.ResolveParser = "resolve-parser",
    i.CacheParser = "cache-parser",
    i.DetectionParser = "detection-parser",
    i.MaskEffect = "mask-effect",
    i.BlendMode = "blend-mode",
    i.TextureSource = "texture-source",
    i.Environment = "environment",
    i.ShapeBuilder = "shape-builder",
    i.Batcher = "batcher",
    i))(O || {})
      , Mc = i => {
        if (typeof i == "function" || typeof i == "object" && i.extension) {
            let e = typeof i.extension != "object" ? {
                type: i.extension
            } : i.extension;
            i = f1(Zh({}, e), {
                ref: i
            })
        }
        if (typeof i == "object")
            i = Zh({}, i);
        else
            throw new Error("Invalid extension type");
        return typeof i.type == "string" && (i.type = [i.type]),
        i
    }
      , Ls = (i, e) => {
        var t;
        return (t = Mc(i).priority) != null ? t : e
    }
      , be = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...i) {
            return i.map(Mc).forEach(e => {
                e.type.forEach(t => {
                    var r, s;
                    return (s = (r = this._removeHandlers)[t]) == null ? void 0 : s.call(r, e)
                }
                )
            }
            ),
            this
        },
        add(...i) {
            return i.map(Mc).forEach(e => {
                e.type.forEach(t => {
                    var r, s;
                    let n = this._addHandlers
                      , a = this._queue;
                    n[t] ? (s = n[t]) == null || s.call(n, e) : (a[t] = a[t] || [],
                    (r = a[t]) == null || r.push(e))
                }
                )
            }
            ),
            this
        },
        handle(i, e, t) {
            var r;
            let s = this._addHandlers
              , n = this._removeHandlers;
            s[i] = e,
            n[i] = t;
            let a = this._queue;
            return a[i] && ((r = a[i]) == null || r.forEach(o => e(o)),
            delete a[i]),
            this
        },
        handleByMap(i, e) {
            return this.handle(i, t => {
                t.name && (e[t.name] = t.ref)
            }
            , t => {
                t.name && delete e[t.name]
            }
            )
        },
        handleByNamedList(i, e, t=-1) {
            return this.handle(i, r => {
                e.findIndex(s => s.name === r.name) >= 0 || (e.push({
                    name: r.name,
                    value: r.ref
                }),
                e.sort( (s, n) => Ls(n.value, t) - Ls(s.value, t)))
            }
            , r => {
                let s = e.findIndex(n => n.name === r.name);
                s !== -1 && e.splice(s, 1)
            }
            )
        },
        handleByList(i, e, t=-1) {
            return this.handle(i, r => {
                e.includes(r.ref) || (e.push(r.ref),
                e.sort( (s, n) => Ls(n, t) - Ls(s, t)))
            }
            , r => {
                let s = e.indexOf(r.ref);
                s !== -1 && e.splice(s, 1)
            }
            )
        },
        mixin(i, ...e) {
            for (let t of e)
                Object.defineProperties(i.prototype, Object.getOwnPropertyDescriptors(t))
        }
    };
    function X0(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
    }
    var wh = {
        exports: {}
    }
      , xw = wh.exports;
    (function(i) {
        "use strict";
        var e = Object.prototype.hasOwnProperty
          , t = "~";
        function r() {}
        Object.create && (r.prototype = Object.create(null),
        new r().__proto__ || (t = !1));
        function s(l, u, d) {
            this.fn = l,
            this.context = u,
            this.once = d || !1
        }
        function n(l, u, d, f, b) {
            if (typeof d != "function")
                throw new TypeError("The listener must be a function");
            var m = new s(d,f || l,b)
              , x = t ? t + u : u;
            return l._events[x] ? l._events[x].fn ? l._events[x] = [l._events[x], m] : l._events[x].push(m) : (l._events[x] = m,
            l._eventsCount++),
            l
        }
        function a(l, u) {
            --l._eventsCount === 0 ? l._events = new r : delete l._events[u]
        }
        function o() {
            this._events = new r,
            this._eventsCount = 0
        }
        o.prototype.eventNames = function() {
            var l = [], u, d;
            if (this._eventsCount === 0)
                return l;
            for (d in u = this._events)
                e.call(u, d) && l.push(t ? d.slice(1) : d);
            return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l
        }
        ,
        o.prototype.listeners = function(l) {
            var u = t ? t + l : l
              , d = this._events[u];
            if (!d)
                return [];
            if (d.fn)
                return [d.fn];
            for (var f = 0, b = d.length, m = new Array(b); f < b; f++)
                m[f] = d[f].fn;
            return m
        }
        ,
        o.prototype.listenerCount = function(l) {
            var u = t ? t + l : l
              , d = this._events[u];
            return d ? d.fn ? 1 : d.length : 0
        }
        ,
        o.prototype.emit = function(l, u, d, f, b, m) {
            var x = t ? t + l : l;
            if (!this._events[x])
                return !1;
            var v = this._events[x], S = arguments.length, w, E;
            if (v.fn) {
                switch (v.once && this.removeListener(l, v.fn, void 0, !0),
                S) {
                case 1:
                    return v.fn.call(v.context),
                    !0;
                case 2:
                    return v.fn.call(v.context, u),
                    !0;
                case 3:
                    return v.fn.call(v.context, u, d),
                    !0;
                case 4:
                    return v.fn.call(v.context, u, d, f),
                    !0;
                case 5:
                    return v.fn.call(v.context, u, d, f, b),
                    !0;
                case 6:
                    return v.fn.call(v.context, u, d, f, b, m),
                    !0
                }
                for (E = 1,
                w = new Array(S - 1); E < S; E++)
                    w[E - 1] = arguments[E];
                v.fn.apply(v.context, w)
            } else {
                var P = v.length, C;
                for (E = 0; E < P; E++)
                    switch (v[E].once && this.removeListener(l, v[E].fn, void 0, !0),
                    S) {
                    case 1:
                        v[E].fn.call(v[E].context);
                        break;
                    case 2:
                        v[E].fn.call(v[E].context, u);
                        break;
                    case 3:
                        v[E].fn.call(v[E].context, u, d);
                        break;
                    case 4:
                        v[E].fn.call(v[E].context, u, d, f);
                        break;
                    default:
                        if (!w)
                            for (C = 1,
                            w = new Array(S - 1); C < S; C++)
                                w[C - 1] = arguments[C];
                        v[E].fn.apply(v[E].context, w)
                    }
            }
            return !0
        }
        ,
        o.prototype.on = function(l, u, d) {
            return n(this, l, u, d, !1)
        }
        ,
        o.prototype.once = function(l, u, d) {
            return n(this, l, u, d, !0)
        }
        ,
        o.prototype.removeListener = function(l, u, d, f) {
            var b = t ? t + l : l;
            if (!this._events[b])
                return this;
            if (!u)
                return a(this, b),
                this;
            var m = this._events[b];
            if (m.fn)
                m.fn === u && (!f || m.once) && (!d || m.context === d) && a(this, b);
            else {
                for (var x = 0, v = [], S = m.length; x < S; x++)
                    (m[x].fn !== u || f && !m[x].once || d && m[x].context !== d) && v.push(m[x]);
                v.length ? this._events[b] = v.length === 1 ? v[0] : v : a(this, b)
            }
            return this
        }
        ,
        o.prototype.removeAllListeners = function(l) {
            var u;
            return l ? (u = t ? t + l : l,
            this._events[u] && a(this, u)) : (this._events = new r,
            this._eventsCount = 0),
            this
        }
        ,
        o.prototype.off = o.prototype.removeListener,
        o.prototype.addListener = o.prototype.on,
        o.prefixed = t,
        o.EventEmitter = o,
        i.exports = o
    }
    )(wh);
    var p1 = wh.exports
      , Ot = X0(p1)
      , b1 = {
        grad: .9,
        turn: 360,
        rad: 360 / (2 * Math.PI)
    }
      , oi = function(i) {
        return typeof i == "string" ? i.length > 0 : typeof i == "number"
    }
      , st = function(i, e, t) {
        return e === void 0 && (e = 0),
        t === void 0 && (t = Math.pow(10, e)),
        Math.round(t * i) / t + 0
    }
      , Dt = function(i, e, t) {
        return e === void 0 && (e = 0),
        t === void 0 && (t = 1),
        i > t ? t : i > e ? i : e
    }
      , j0 = function(i) {
        return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360
    }
      , Qh = function(i) {
        return {
            r: Dt(i.r, 0, 255),
            g: Dt(i.g, 0, 255),
            b: Dt(i.b, 0, 255),
            a: Dt(i.a)
        }
    }
      , Po = function(i) {
        return {
            r: st(i.r),
            g: st(i.g),
            b: st(i.b),
            a: st(i.a, 3)
        }
    }
      , m1 = /^#([0-9a-f]{3,8})$/i
      , Ns = function(i) {
        var e = i.toString(16);
        return e.length < 2 ? "0" + e : e
    }
      , H0 = function(i) {
        var e = i.r
          , t = i.g
          , r = i.b
          , s = i.a
          , n = Math.max(e, t, r)
          , a = n - Math.min(e, t, r)
          , o = a ? n === e ? (t - r) / a : n === t ? 2 + (r - e) / a : 4 + (e - t) / a : 0;
        return {
            h: 60 * (o < 0 ? o + 6 : o),
            s: n ? a / n * 100 : 0,
            v: n / 255 * 100,
            a: s
        }
    }
      , z0 = function(i) {
        var e = i.h
          , t = i.s
          , r = i.v
          , s = i.a;
        e = e / 360 * 6,
        t /= 100,
        r /= 100;
        var n = Math.floor(e)
          , a = r * (1 - t)
          , o = r * (1 - (e - n) * t)
          , l = r * (1 - (1 - e + n) * t)
          , u = n % 6;
        return {
            r: 255 * [r, o, a, a, l, r][u],
            g: 255 * [l, r, r, o, a, a][u],
            b: 255 * [a, a, l, r, r, o][u],
            a: s
        }
    }
      , Jh = function(i) {
        return {
            h: j0(i.h),
            s: Dt(i.s, 0, 100),
            l: Dt(i.l, 0, 100),
            a: Dt(i.a)
        }
    }
      , eu = function(i) {
        return {
            h: st(i.h),
            s: st(i.s),
            l: st(i.l),
            a: st(i.a, 3)
        }
    }
      , tu = function(i) {
        return z0((t = (e = i).s,
        {
            h: e.h,
            s: (t *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * t / (r + t) * 100 : 0,
            v: r + t,
            a: e.a
        }));
        var e, t, r
    }
      , es = function(i) {
        return {
            h: (e = H0(i)).h,
            s: (s = (200 - (t = e.s)) * (r = e.v) / 100) > 0 && s < 200 ? t * r / 100 / (s <= 100 ? s : 200 - s) * 100 : 0,
            l: s / 2,
            a: e.a
        };
        var e, t, r, s
    }
      , g1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
      , _1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
      , x1 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
      , y1 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
      , Cc = {
        string: [[function(i) {
            var e = m1.exec(i);
            return e ? (i = e[1]).length <= 4 ? {
                r: parseInt(i[0] + i[0], 16),
                g: parseInt(i[1] + i[1], 16),
                b: parseInt(i[2] + i[2], 16),
                a: i.length === 4 ? st(parseInt(i[3] + i[3], 16) / 255, 2) : 1
            } : i.length === 6 || i.length === 8 ? {
                r: parseInt(i.substr(0, 2), 16),
                g: parseInt(i.substr(2, 2), 16),
                b: parseInt(i.substr(4, 2), 16),
                a: i.length === 8 ? st(parseInt(i.substr(6, 2), 16) / 255, 2) : 1
            } : null : null
        }
        , "hex"], [function(i) {
            var e = x1.exec(i) || y1.exec(i);
            return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Qh({
                r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
            }) : null
        }
        , "rgb"], [function(i) {
            var e = g1.exec(i) || _1.exec(i);
            if (!e)
                return null;
            var t, r, s = Jh({
                h: (t = e[1],
                r = e[2],
                r === void 0 && (r = "deg"),
                Number(t) * (b1[r] || 1)),
                s: Number(e[3]),
                l: Number(e[4]),
                a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
            });
            return tu(s)
        }
        , "hsl"]],
        object: [[function(i) {
            var e = i.r
              , t = i.g
              , r = i.b
              , s = i.a
              , n = s === void 0 ? 1 : s;
            return oi(e) && oi(t) && oi(r) ? Qh({
                r: Number(e),
                g: Number(t),
                b: Number(r),
                a: Number(n)
            }) : null
        }
        , "rgb"], [function(i) {
            var e = i.h
              , t = i.s
              , r = i.l
              , s = i.a
              , n = s === void 0 ? 1 : s;
            if (!oi(e) || !oi(t) || !oi(r))
                return null;
            var a = Jh({
                h: Number(e),
                s: Number(t),
                l: Number(r),
                a: Number(n)
            });
            return tu(a)
        }
        , "hsl"], [function(i) {
            var e = i.h
              , t = i.s
              , r = i.v
              , s = i.a
              , n = s === void 0 ? 1 : s;
            if (!oi(e) || !oi(t) || !oi(r))
                return null;
            var a = (function(o) {
                return {
                    h: j0(o.h),
                    s: Dt(o.s, 0, 100),
                    v: Dt(o.v, 0, 100),
                    a: Dt(o.a)
                }
            }
            )({
                h: Number(e),
                s: Number(t),
                v: Number(r),
                a: Number(n)
            });
            return z0(a)
        }
        , "hsv"]]
    }
      , iu = function(i, e) {
        for (var t = 0; t < e.length; t++) {
            var r = e[t][0](i);
            if (r)
                return [r, e[t][1]]
        }
        return [null, void 0]
    }
      , v1 = function(i) {
        return typeof i == "string" ? iu(i.trim(), Cc.string) : typeof i == "object" && i !== null ? iu(i, Cc.object) : [null, void 0]
    };
    var Ro = function(i, e) {
        var t = es(i);
        return {
            h: t.h,
            s: Dt(t.s + 100 * e, 0, 100),
            l: t.l,
            a: t.a
        }
    }
      , Mo = function(i) {
        return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255
    }
      , ru = function(i, e) {
        var t = es(i);
        return {
            h: t.h,
            s: t.s,
            l: Dt(t.l + 100 * e, 0, 100),
            a: t.a
        }
    }
      , Oc = (function() {
        function i(e) {
            this.parsed = v1(e)[0],
            this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        }
        return i.prototype.isValid = function() {
            return this.parsed !== null
        }
        ,
        i.prototype.brightness = function() {
            return st(Mo(this.rgba), 2)
        }
        ,
        i.prototype.isDark = function() {
            return Mo(this.rgba) < .5
        }
        ,
        i.prototype.isLight = function() {
            return Mo(this.rgba) >= .5
        }
        ,
        i.prototype.toHex = function() {
            return e = Po(this.rgba),
            t = e.r,
            r = e.g,
            s = e.b,
            a = (n = e.a) < 1 ? Ns(st(255 * n)) : "",
            "#" + Ns(t) + Ns(r) + Ns(s) + a;
            var e, t, r, s, n, a
        }
        ,
        i.prototype.toRgb = function() {
            return Po(this.rgba)
        }
        ,
        i.prototype.toRgbString = function() {
            return e = Po(this.rgba),
            t = e.r,
            r = e.g,
            s = e.b,
            (n = e.a) < 1 ? "rgba(" + t + ", " + r + ", " + s + ", " + n + ")" : "rgb(" + t + ", " + r + ", " + s + ")";
            var e, t, r, s, n
        }
        ,
        i.prototype.toHsl = function() {
            return eu(es(this.rgba))
        }
        ,
        i.prototype.toHslString = function() {
            return e = eu(es(this.rgba)),
            t = e.h,
            r = e.s,
            s = e.l,
            (n = e.a) < 1 ? "hsla(" + t + ", " + r + "%, " + s + "%, " + n + ")" : "hsl(" + t + ", " + r + "%, " + s + "%)";
            var e, t, r, s, n
        }
        ,
        i.prototype.toHsv = function() {
            return e = H0(this.rgba),
            {
                h: st(e.h),
                s: st(e.s),
                v: st(e.v),
                a: st(e.a, 3)
            };
            var e
        }
        ,
        i.prototype.invert = function() {
            return ii({
                r: 255 - (e = this.rgba).r,
                g: 255 - e.g,
                b: 255 - e.b,
                a: e.a
            });
            var e
        }
        ,
        i.prototype.saturate = function(e) {
            return e === void 0 && (e = .1),
            ii(Ro(this.rgba, e))
        }
        ,
        i.prototype.desaturate = function(e) {
            return e === void 0 && (e = .1),
            ii(Ro(this.rgba, -e))
        }
        ,
        i.prototype.grayscale = function() {
            return ii(Ro(this.rgba, -1))
        }
        ,
        i.prototype.lighten = function(e) {
            return e === void 0 && (e = .1),
            ii(ru(this.rgba, e))
        }
        ,
        i.prototype.darken = function(e) {
            return e === void 0 && (e = .1),
            ii(ru(this.rgba, -e))
        }
        ,
        i.prototype.rotate = function(e) {
            return e === void 0 && (e = 15),
            this.hue(this.hue() + e)
        }
        ,
        i.prototype.alpha = function(e) {
            return typeof e == "number" ? ii({
                r: (t = this.rgba).r,
                g: t.g,
                b: t.b,
                a: e
            }) : st(this.rgba.a, 3);
            var t
        }
        ,
        i.prototype.hue = function(e) {
            var t = es(this.rgba);
            return typeof e == "number" ? ii({
                h: e,
                s: t.s,
                l: t.l,
                a: t.a
            }) : st(t.h)
        }
        ,
        i.prototype.isEqual = function(e) {
            return this.toHex() === ii(e).toHex()
        }
        ,
        i
    }
    )()
      , ii = function(i) {
        return i instanceof Oc ? i : new Oc(i)
    }
      , su = []
      , T1 = function(i) {
        i.forEach(function(e) {
            su.indexOf(e) < 0 && (e(Oc, Cc),
            su.push(e))
        })
    };
    function S1(i, e) {
        var t = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000"
        }
          , r = {};
        for (var s in t)
            r[t[s]] = s;
        var n = {};
        i.prototype.toName = function(a) {
            if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
                return "transparent";
            var o, l, u = r[this.toHex()];
            if (u)
                return u;
            if (a != null && a.closest) {
                var d = this.toRgb()
                  , f = 1 / 0
                  , b = "black";
                if (!n.length)
                    for (var m in t)
                        n[m] = new i(t[m]).toRgb();
                for (var x in t) {
                    var v = (o = d,
                    l = n[x],
                    Math.pow(o.r - l.r, 2) + Math.pow(o.g - l.g, 2) + Math.pow(o.b - l.b, 2));
                    v < f && (f = v,
                    b = x)
                }
                return b
            }
        }
        ,
        e.string.push([function(a) {
            var o = a.toLowerCase()
              , l = o === "transparent" ? "#0000" : t[o];
            return l ? new i(l).toRgb() : null
        }
        , "name"])
    }
    var w1 = Object.defineProperty
      , nu = Object.getOwnPropertySymbols
      , A1 = Object.prototype.hasOwnProperty
      , E1 = Object.prototype.propertyIsEnumerable
      , au = (i, e, t) => e in i ? w1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , P1 = (i, e) => {
        for (var t in e || (e = {}))
            A1.call(e, t) && au(i, t, e[t]);
        if (nu)
            for (var t of nu(e))
                E1.call(e, t) && au(i, t, e[t]);
        return i
    }
    ;
    T1([S1]);
    var ur = class qr {
        constructor(e=16777215) {
            this._value = null,
            this._components = new Float32Array(4),
            this._components.fill(1),
            this._int = 16777215,
            this.value = e
        }
        get red() {
            return this._components[0]
        }
        get green() {
            return this._components[1]
        }
        get blue() {
            return this._components[2]
        }
        get alpha() {
            return this._components[3]
        }
        setValue(e) {
            return this.value = e,
            this
        }
        set value(e) {
            if (e instanceof qr)
                this._value = this._cloneSource(e._value),
                this._int = e._int,
                this._components.set(e._components);
            else {
                if (e === null)
                    throw new Error("Cannot set Color#value to null");
                (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e),
                this._normalize(this._value))
            }
        }
        get value() {
            return this._value
        }
        _cloneSource(e) {
            return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? P1({}, e) : e
        }
        _isSourceEqual(e, t) {
            let r = typeof e;
            if (r !== typeof t)
                return !1;
            if (r === "number" || r === "string" || e instanceof Number)
                return e === t;
            if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t))
                return e.length !== t.length ? !1 : e.every( (s, n) => s === t[n]);
            if (e !== null && t !== null) {
                let s = Object.keys(e)
                  , n = Object.keys(t);
                return s.length !== n.length ? !1 : s.every(a => e[a] === t[a])
            }
            return e === t
        }
        toRgba() {
            let[e,t,r,s] = this._components;
            return {
                r: e,
                g: t,
                b: r,
                a: s
            }
        }
        toRgb() {
            let[e,t,r] = this._components;
            return {
                r: e,
                g: t,
                b: r
            }
        }
        toRgbaString() {
            let[e,t,r] = this.toUint8RgbArray();
            return `rgba(${e},${t},${r},${this.alpha})`
        }
        toUint8RgbArray(e) {
            let[t,r,s] = this._components;
            return this._arrayRgb || (this._arrayRgb = []),
            e || (e = this._arrayRgb),
            e[0] = Math.round(t * 255),
            e[1] = Math.round(r * 255),
            e[2] = Math.round(s * 255),
            e
        }
        toArray(e) {
            this._arrayRgba || (this._arrayRgba = []),
            e || (e = this._arrayRgba);
            let[t,r,s,n] = this._components;
            return e[0] = t,
            e[1] = r,
            e[2] = s,
            e[3] = n,
            e
        }
        toRgbArray(e) {
            this._arrayRgb || (this._arrayRgb = []),
            e || (e = this._arrayRgb);
            let[t,r,s] = this._components;
            return e[0] = t,
            e[1] = r,
            e[2] = s,
            e
        }
        toNumber() {
            return this._int
        }
        toBgrNumber() {
            let[e,t,r] = this.toUint8RgbArray();
            return (r << 16) + (t << 8) + e
        }
        toLittleEndianNumber() {
            let e = this._int;
            return (e >> 16) + (e & 65280) + ((e & 255) << 16)
        }
        multiply(e) {
            let[t,r,s,n] = qr._temp.setValue(e)._components;
            return this._components[0] *= t,
            this._components[1] *= r,
            this._components[2] *= s,
            this._components[3] *= n,
            this._refreshInt(),
            this._value = null,
            this
        }
        premultiply(e, t=!0) {
            return t && (this._components[0] *= e,
            this._components[1] *= e,
            this._components[2] *= e),
            this._components[3] = e,
            this._refreshInt(),
            this._value = null,
            this
        }
        toPremultiplied(e, t=!0) {
            if (e === 1)
                return (255 << 24) + this._int;
            if (e === 0)
                return t ? 0 : this._int;
            let r = this._int >> 16 & 255
              , s = this._int >> 8 & 255
              , n = this._int & 255;
            return t && (r = r * e + .5 | 0,
            s = s * e + .5 | 0,
            n = n * e + .5 | 0),
            (e * 255 << 24) + (r << 16) + (s << 8) + n
        }
        toHex() {
            let e = this._int.toString(16);
            return `#${"000000".substring(0, 6 - e.length) + e}`
        }
        toHexa() {
            let e = Math.round(this._components[3] * 255).toString(16);
            return this.toHex() + "00".substring(0, 2 - e.length) + e
        }
        setAlpha(e) {
            return this._components[3] = this._clamp(e),
            this
        }
        _normalize(e) {
            let t, r, s, n;
            if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
                let a = e;
                t = (a >> 16 & 255) / 255,
                r = (a >> 8 & 255) / 255,
                s = (a & 255) / 255,
                n = 1
            } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4)
                e = this._clamp(e),
                [t,r,s,n=1] = e;
            else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4)
                e = this._clamp(e, 0, 255),
                [t,r,s,n=255] = e,
                t /= 255,
                r /= 255,
                s /= 255,
                n /= 255;
            else if (typeof e == "string" || typeof e == "object") {
                if (typeof e == "string") {
                    let o = qr.HEX_PATTERN.exec(e);
                    o && (e = `#${o[2]}`)
                }
                let a = ii(e);
                a.isValid() && ({r: t, g: r, b: s, a: n} = a.rgba,
                t /= 255,
                r /= 255,
                s /= 255)
            }
            if (t !== void 0)
                this._components[0] = t,
                this._components[1] = r,
                this._components[2] = s,
                this._components[3] = n,
                this._refreshInt();
            else
                throw new Error(`Unable to convert color ${e}`)
        }
        _refreshInt() {
            this._clamp(this._components);
            let[e,t,r] = this._components;
            this._int = (e * 255 << 16) + (t * 255 << 8) + (r * 255 | 0)
        }
        _clamp(e, t=0, r=1) {
            return typeof e == "number" ? Math.min(Math.max(e, t), r) : (e.forEach( (s, n) => {
                e[n] = Math.min(Math.max(s, t), r)
            }
            ),
            e)
        }
        static isColorLike(e) {
            return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof qr || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0
        }
    }
    ;
    ur.shared = new ur,
    ur._temp = new ur,
    ur.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    var Be = ur
      , R1 = {
        cullArea: null,
        cullable: !1,
        cullableChildren: !0
    }
      , M1 = Math.PI * 2
      , C1 = 180 / Math.PI
      , O1 = Math.PI / 180
      , Ue = class i {
        constructor(e=0, t=0) {
            this.x = 0,
            this.y = 0,
            this.x = e,
            this.y = t
        }
        clone() {
            return new i(this.x,this.y)
        }
        copyFrom(e) {
            return this.set(e.x, e.y),
            this
        }
        copyTo(e) {
            return e.set(this.x, this.y),
            e
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        set(e=0, t=e) {
            return this.x = e,
            this.y = t,
            this
        }
        static get shared() {
            return Co.x = 0,
            Co.y = 0,
            Co
        }
    }
      , Co = new Ue
      , ce = class i {
        constructor(e=1, t=0, r=0, s=1, n=0, a=0) {
            this.array = null,
            this.a = e,
            this.b = t,
            this.c = r,
            this.d = s,
            this.tx = n,
            this.ty = a
        }
        fromArray(e) {
            this.a = e[0],
            this.b = e[1],
            this.c = e[3],
            this.d = e[4],
            this.tx = e[2],
            this.ty = e[5]
        }
        set(e, t, r, s, n, a) {
            return this.a = e,
            this.b = t,
            this.c = r,
            this.d = s,
            this.tx = n,
            this.ty = a,
            this
        }
        toArray(e, t) {
            this.array || (this.array = new Float32Array(9));
            let r = t || this.array;
            return e ? (r[0] = this.a,
            r[1] = this.b,
            r[2] = 0,
            r[3] = this.c,
            r[4] = this.d,
            r[5] = 0,
            r[6] = this.tx,
            r[7] = this.ty,
            r[8] = 1) : (r[0] = this.a,
            r[1] = this.c,
            r[2] = this.tx,
            r[3] = this.b,
            r[4] = this.d,
            r[5] = this.ty,
            r[6] = 0,
            r[7] = 0,
            r[8] = 1),
            r
        }
        apply(e, t) {
            t = t || new Ue;
            let r = e.x
              , s = e.y;
            return t.x = this.a * r + this.c * s + this.tx,
            t.y = this.b * r + this.d * s + this.ty,
            t
        }
        applyInverse(e, t) {
            t = t || new Ue;
            let r = this.a
              , s = this.b
              , n = this.c
              , a = this.d
              , o = this.tx
              , l = this.ty
              , u = 1 / (r * a + n * -s)
              , d = e.x
              , f = e.y;
            return t.x = a * u * d + -n * u * f + (l * n - o * a) * u,
            t.y = r * u * f + -s * u * d + (-l * r + o * s) * u,
            t
        }
        translate(e, t) {
            return this.tx += e,
            this.ty += t,
            this
        }
        scale(e, t) {
            return this.a *= e,
            this.d *= t,
            this.c *= e,
            this.b *= t,
            this.tx *= e,
            this.ty *= t,
            this
        }
        rotate(e) {
            let t = Math.cos(e)
              , r = Math.sin(e)
              , s = this.a
              , n = this.c
              , a = this.tx;
            return this.a = s * t - this.b * r,
            this.b = s * r + this.b * t,
            this.c = n * t - this.d * r,
            this.d = n * r + this.d * t,
            this.tx = a * t - this.ty * r,
            this.ty = a * r + this.ty * t,
            this
        }
        append(e) {
            let t = this.a
              , r = this.b
              , s = this.c
              , n = this.d;
            return this.a = e.a * t + e.b * s,
            this.b = e.a * r + e.b * n,
            this.c = e.c * t + e.d * s,
            this.d = e.c * r + e.d * n,
            this.tx = e.tx * t + e.ty * s + this.tx,
            this.ty = e.tx * r + e.ty * n + this.ty,
            this
        }
        appendFrom(e, t) {
            let r = e.a
              , s = e.b
              , n = e.c
              , a = e.d
              , o = e.tx
              , l = e.ty
              , u = t.a
              , d = t.b
              , f = t.c
              , b = t.d;
            return this.a = r * u + s * f,
            this.b = r * d + s * b,
            this.c = n * u + a * f,
            this.d = n * d + a * b,
            this.tx = o * u + l * f + t.tx,
            this.ty = o * d + l * b + t.ty,
            this
        }
        setTransform(e, t, r, s, n, a, o, l, u) {
            return this.a = Math.cos(o + u) * n,
            this.b = Math.sin(o + u) * n,
            this.c = -Math.sin(o - l) * a,
            this.d = Math.cos(o - l) * a,
            this.tx = e - (r * this.a + s * this.c),
            this.ty = t - (r * this.b + s * this.d),
            this
        }
        prepend(e) {
            let t = this.tx;
            if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
                let r = this.a
                  , s = this.c;
                this.a = r * e.a + this.b * e.c,
                this.b = r * e.b + this.b * e.d,
                this.c = s * e.a + this.d * e.c,
                this.d = s * e.b + this.d * e.d
            }
            return this.tx = t * e.a + this.ty * e.c + e.tx,
            this.ty = t * e.b + this.ty * e.d + e.ty,
            this
        }
        decompose(e) {
            let t = this.a
              , r = this.b
              , s = this.c
              , n = this.d
              , a = e.pivot
              , o = -Math.atan2(-s, n)
              , l = Math.atan2(r, t)
              , u = Math.abs(o + l);
            return u < 1e-5 || Math.abs(M1 - u) < 1e-5 ? (e.rotation = l,
            e.skew.x = e.skew.y = 0) : (e.rotation = 0,
            e.skew.x = o,
            e.skew.y = l),
            e.scale.x = Math.sqrt(t * t + r * r),
            e.scale.y = Math.sqrt(s * s + n * n),
            e.position.x = this.tx + (a.x * t + a.y * s),
            e.position.y = this.ty + (a.x * r + a.y * n),
            e
        }
        invert() {
            let e = this.a
              , t = this.b
              , r = this.c
              , s = this.d
              , n = this.tx
              , a = e * s - t * r;
            return this.a = s / a,
            this.b = -t / a,
            this.c = -r / a,
            this.d = e / a,
            this.tx = (r * this.ty - s * n) / a,
            this.ty = -(e * this.ty - t * n) / a,
            this
        }
        isIdentity() {
            return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0
        }
        identity() {
            return this.a = 1,
            this.b = 0,
            this.c = 0,
            this.d = 1,
            this.tx = 0,
            this.ty = 0,
            this
        }
        clone() {
            let e = new i;
            return e.a = this.a,
            e.b = this.b,
            e.c = this.c,
            e.d = this.d,
            e.tx = this.tx,
            e.ty = this.ty,
            e
        }
        copyTo(e) {
            return e.a = this.a,
            e.b = this.b,
            e.c = this.c,
            e.d = this.d,
            e.tx = this.tx,
            e.ty = this.ty,
            e
        }
        copyFrom(e) {
            return this.a = e.a,
            this.b = e.b,
            this.c = e.c,
            this.d = e.d,
            this.tx = e.tx,
            this.ty = e.ty,
            this
        }
        equals(e) {
            return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty
        }
        static get IDENTITY() {
            return G1.identity()
        }
        static get shared() {
            return I1.identity()
        }
    }
      , I1 = new ce
      , G1 = new ce
      , ze = class i {
        constructor(e, t, r) {
            this._x = t || 0,
            this._y = r || 0,
            this._observer = e
        }
        clone(e) {
            return new i(e ?? this._observer,this._x,this._y)
        }
        set(e=0, t=e) {
            return (this._x !== e || this._y !== t) && (this._x = e,
            this._y = t,
            this._observer._onUpdate(this)),
            this
        }
        copyFrom(e) {
            return (this._x !== e.x || this._y !== e.y) && (this._x = e.x,
            this._y = e.y,
            this._observer._onUpdate(this)),
            this
        }
        copyTo(e) {
            return e.set(this._x, this._y),
            e
        }
        equals(e) {
            return e.x === this._x && e.y === this._y
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x !== e && (this._x = e,
            this._observer._onUpdate(this))
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y !== e && (this._y = e,
            this._observer._onUpdate(this))
        }
    }
      , Oo = {
        default: -1
    };
    function Le(i="default") {
        return Oo[i] === void 0 && (Oo[i] = -1),
        ++Oo[i]
    }
    var Pr = {
        _registeredResources: new Set,
        register(i) {
            this._registeredResources.add(i)
        },
        unregister(i) {
            this._registeredResources.delete(i)
        },
        release() {
            this._registeredResources.forEach(i => i.clear())
        },
        get registeredCount() {
            return this._registeredResources.size
        },
        isRegistered(i) {
            return this._registeredResources.has(i)
        },
        reset() {
            this._registeredResources.clear()
        }
    }
      , Ic = class {
        constructor(e, t) {
            this._pool = [],
            this._count = 0,
            this._index = 0,
            this._classType = e,
            t && this.prepopulate(t)
        }
        prepopulate(e) {
            for (let t = 0; t < e; t++)
                this._pool[this._index++] = new this._classType;
            this._count += e
        }
        get(e) {
            var t;
            let r;
            return this._index > 0 ? r = this._pool[--this._index] : r = new this._classType,
            (t = r.init) == null || t.call(r, e),
            r
        }
        return(e) {
            var t;
            (t = e.reset) == null || t.call(e),
            this._pool[this._index++] = e
        }
        get totalSize() {
            return this._count
        }
        get totalFree() {
            return this._index
        }
        get totalUsed() {
            return this._count - this._index
        }
        clear() {
            if (this._pool.length > 0 && this._pool[0].destroy)
                for (let e = 0; e < this._index; e++)
                    this._pool[e].destroy();
            this._pool.length = 0,
            this._count = 0,
            this._index = 0
        }
    }
      , Gc = class {
        constructor() {
            this._poolsByClass = new Map
        }
        prepopulate(e, t) {
            this.getPool(e).prepopulate(t)
        }
        get(e, t) {
            return this.getPool(e).get(t)
        }
        return(e) {
            this.getPool(e.constructor).return(e)
        }
        getPool(e) {
            return this._poolsByClass.has(e) || this._poolsByClass.set(e, new Ic(e)),
            this._poolsByClass.get(e)
        }
        stats() {
            let e = {};
            return this._poolsByClass.forEach(t => {
                let r = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name;
                e[r] = {
                    free: t.totalFree,
                    used: t.totalUsed,
                    size: t.totalSize
                }
            }
            ),
            e
        }
        clear() {
            this._poolsByClass.forEach(e => e.clear()),
            this._poolsByClass.clear()
        }
    }
      , Je = new Gc;
    Pr.register(Je);
    var B1 = {
        get isCachedAsTexture() {
            var i;
            return !!((i = this.renderGroup) != null && i.isCachedAsTexture)
        },
        cacheAsTexture(i) {
            typeof i == "boolean" && i === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(),
            this.renderGroup.enableCacheAsTexture(i === !0 ? {} : i))
        },
        updateCacheTexture() {
            var i;
            (i = this.renderGroup) == null || i.updateCacheTexture()
        },
        get cacheAsBitmap() {
            return this.isCachedAsTexture
        },
        set cacheAsBitmap(i) {
            this.cacheAsTexture(i)
        }
    };
    function V0(i, e, t) {
        let r = i.length, s;
        if (e >= r || t === 0)
            return;
        t = e + t > r ? r - e : t;
        let n = r - t;
        for (s = e; s < n; ++s)
            i[s] = i[s + t];
        i.length = n
    }
    var F1 = {
        allowChildren: !0,
        removeChildren(i=0, e) {
            var t;
            let r = e ?? this.children.length
              , s = r - i
              , n = [];
            if (s > 0 && s <= r) {
                for (let o = r - 1; o >= i; o--) {
                    let l = this.children[o];
                    l && (n.push(l),
                    l.parent = null)
                }
                V0(this.children, i, r);
                let a = this.renderGroup || this.parentRenderGroup;
                a && a.removeChildren(n);
                for (let o = 0; o < n.length; ++o) {
                    let l = n[o];
                    (t = l.parentRenderLayer) == null || t.detach(l),
                    this.emit("childRemoved", l, this, o),
                    n[o].emit("removed", this)
                }
                return n.length > 0 && this._didViewChangeTick++,
                n
            } else if (s === 0 && this.children.length === 0)
                return n;
            throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
        },
        removeChildAt(i) {
            let e = this.getChildAt(i);
            return this.removeChild(e)
        },
        getChildAt(i) {
            if (i < 0 || i >= this.children.length)
                throw new Error(`getChildAt: Index (${i}) does not exist.`);
            return this.children[i]
        },
        setChildIndex(i, e) {
            if (e < 0 || e >= this.children.length)
                throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
            this.getChildIndex(i),
            this.addChildAt(i, e)
        },
        getChildIndex(i) {
            let e = this.children.indexOf(i);
            if (e === -1)
                throw new Error("The supplied Container must be a child of the caller");
            return e
        },
        addChildAt(i, e) {
            let {children: t} = this;
            if (e < 0 || e > t.length)
                throw new Error(`${i}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);
            if (i.parent) {
                let s = i.parent.children.indexOf(i);
                if (i.parent === this && s === e)
                    return i;
                s !== -1 && i.parent.children.splice(s, 1)
            }
            e === t.length ? t.push(i) : t.splice(e, 0, i),
            i.parent = this,
            i.didChange = !0,
            i._updateFlags = 15;
            let r = this.renderGroup || this.parentRenderGroup;
            return r && r.addChild(i),
            this.sortableChildren && (this.sortDirty = !0),
            this.emit("childAdded", i, this, e),
            i.emit("added", this),
            i
        },
        swapChildren(i, e) {
            if (i === e)
                return;
            let t = this.getChildIndex(i)
              , r = this.getChildIndex(e);
            this.children[t] = e,
            this.children[r] = i;
            let s = this.renderGroup || this.parentRenderGroup;
            s && (s.structureDidChange = !0),
            this._didContainerChangeTick++
        },
        removeFromParent() {
            var i;
            (i = this.parent) == null || i.removeChild(this)
        },
        reparentChild(...i) {
            return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach(e => this.reparentChildAt(e, this.children.length)),
            i[0])
        },
        reparentChildAt(i, e) {
            if (i.parent === this)
                return this.setChildIndex(i, e),
                i;
            let t = i.worldTransform.clone();
            i.removeFromParent(),
            this.addChildAt(i, e);
            let r = this.worldTransform.clone();
            return r.invert(),
            t.prepend(r),
            i.setFromMatrix(t),
            i
        },
        replaceChild(i, e) {
            i.updateLocalTransform(),
            this.addChildAt(e, this.getChildIndex(i)),
            e.setFromMatrix(i.localTransform),
            e.updateLocalTransform(),
            this.removeChild(i)
        }
    }
      , D1 = {
        collectRenderables(i, e, t) {
            this.parentRenderLayer && this.parentRenderLayer !== t || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(),
            this.isSimple ? this.collectRenderablesSimple(i, e, t) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, i) : this.collectRenderablesWithEffects(i, e, t))
        },
        collectRenderablesSimple(i, e, t) {
            let r = this.children
              , s = r.length;
            for (let n = 0; n < s; n++)
                r[n].collectRenderables(i, e, t)
        },
        collectRenderablesWithEffects(i, e, t) {
            let {renderPipes: r} = e;
            for (let s = 0; s < this.effects.length; s++) {
                let n = this.effects[s];
                r[n.pipe].push(n, this, i)
            }
            this.collectRenderablesSimple(i, e, t);
            for (let s = this.effects.length - 1; s >= 0; s--) {
                let n = this.effects[s];
                r[n.pipe].pop(n, this, i)
            }
        }
    }
      , xr = class {
        constructor() {
            this.pipe = "filter",
            this.priority = 1
        }
        destroy() {
            for (let e = 0; e < this.filters.length; e++)
                this.filters[e].destroy();
            this.filters = null,
            this.filterArea = null
        }
    }
      , Bc = class {
        constructor() {
            this._effectClasses = [],
            this._tests = [],
            this._initialized = !1
        }
        init() {
            this._initialized || (this._initialized = !0,
            this._effectClasses.forEach(e => {
                this.add({
                    test: e.test,
                    maskClass: e
                })
            }
            ))
        }
        add(e) {
            this._tests.push(e)
        }
        getMaskEffect(e) {
            this._initialized || this.init();
            for (let t = 0; t < this._tests.length; t++) {
                let r = this._tests[t];
                if (r.test(e))
                    return Je.get(r.maskClass, e)
            }
            return e
        }
        returnMaskEffect(e) {
            Je.return(e)
        }
    }
      , Fc = new Bc;
    be.handleByList(O.MaskEffect, Fc._effectClasses);
    var k1 = Object.defineProperty
      , ou = Object.getOwnPropertySymbols
      , U1 = Object.prototype.hasOwnProperty
      , L1 = Object.prototype.propertyIsEnumerable
      , cu = (i, e, t) => e in i ? k1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , lu = (i, e) => {
        for (var t in e || (e = {}))
            U1.call(e, t) && cu(i, t, e[t]);
        if (ou)
            for (var t of ou(e))
                L1.call(e, t) && cu(i, t, e[t]);
        return i
    }
      , N1 = {
        _maskEffect: null,
        _maskOptions: {
            inverse: !1
        },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged() {
            let i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0)
        },
        addEffect(i) {
            this.effects.indexOf(i) === -1 && (this.effects.push(i),
            this.effects.sort( (e, t) => e.priority - t.priority),
            this._markStructureAsChanged(),
            this._updateIsSimple())
        },
        removeEffect(i) {
            let e = this.effects.indexOf(i);
            e !== -1 && (this.effects.splice(e, 1),
            this._markStructureAsChanged(),
            this._updateIsSimple())
        },
        set mask(i) {
            let e = this._maskEffect;
            e?.mask !== i && (e && (this.removeEffect(e),
            Fc.returnMaskEffect(e),
            this._maskEffect = null),
            i != null && (this._maskEffect = Fc.getMaskEffect(i),
            this.addEffect(this._maskEffect)))
        },
        get mask() {
            var i;
            return (i = this._maskEffect) == null ? void 0 : i.mask
        },
        setMask(i) {
            this._maskOptions = lu(lu({}, this._maskOptions), i),
            i.mask && (this.mask = i.mask),
            this._markStructureAsChanged()
        },
        set filters(i) {
            var e;
            !Array.isArray(i) && i && (i = [i]);
            let t = this._filterEffect || (this._filterEffect = new xr);
            i = i;
            let r = i?.length > 0
              , s = ((e = t.filters) == null ? void 0 : e.length) > 0
              , n = r !== s;
            i = Array.isArray(i) ? i.slice(0) : i,
            t.filters = Object.freeze(i),
            n && (r ? this.addEffect(t) : (this.removeEffect(t),
            t.filters = i ?? null))
        },
        get filters() {
            var i;
            return (i = this._filterEffect) == null ? void 0 : i.filters
        },
        set filterArea(i) {
            this._filterEffect || (this._filterEffect = new xr),
            this._filterEffect.filterArea = i
        },
        get filterArea() {
            var i;
            return (i = this._filterEffect) == null ? void 0 : i.filterArea
        }
    }
      , X1 = {
        label: null,
        get name() {
            return this.label
        },
        set name(i) {
            this.label = i
        },
        getChildByName(i, e=!1) {
            return this.getChildByLabel(i, e)
        },
        getChildByLabel(i, e=!1) {
            let t = this.children;
            for (let r = 0; r < t.length; r++) {
                let s = t[r];
                if (s.label === i || i instanceof RegExp && i.test(s.label))
                    return s
            }
            if (e)
                for (let r = 0; r < t.length; r++) {
                    let s = t[r].getChildByLabel(i, !0);
                    if (s)
                        return s
                }
            return null
        },
        getChildrenByLabel(i, e=!1, t=[]) {
            let r = this.children;
            for (let s = 0; s < r.length; s++) {
                let n = r[s];
                (n.label === i || i instanceof RegExp && i.test(n.label)) && t.push(n)
            }
            if (e)
                for (let s = 0; s < r.length; s++)
                    r[s].getChildrenByLabel(i, !0, t);
            return t
        }
    }
      , Xs = [new Ue, new Ue, new Ue, new Ue]
      , Oe = class i {
        constructor(e=0, t=0, r=0, s=0) {
            this.type = "rectangle",
            this.x = Number(e),
            this.y = Number(t),
            this.width = Number(r),
            this.height = Number(s)
        }
        get left() {
            return this.x
        }
        get right() {
            return this.x + this.width
        }
        get top() {
            return this.y
        }
        get bottom() {
            return this.y + this.height
        }
        isEmpty() {
            return this.left === this.right || this.top === this.bottom
        }
        static get EMPTY() {
            return new i(0,0,0,0)
        }
        clone() {
            return new i(this.x,this.y,this.width,this.height)
        }
        copyFromBounds(e) {
            return this.x = e.minX,
            this.y = e.minY,
            this.width = e.maxX - e.minX,
            this.height = e.maxY - e.minY,
            this
        }
        copyFrom(e) {
            return this.x = e.x,
            this.y = e.y,
            this.width = e.width,
            this.height = e.height,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
        contains(e, t) {
            return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height
        }
        strokeContains(e, t, r, s=.5) {
            let {width: n, height: a} = this;
            if (n <= 0 || a <= 0)
                return !1;
            let o = this.x
              , l = this.y
              , u = r * (1 - s)
              , d = r - u
              , f = o - u
              , b = o + n + u
              , m = l - u
              , x = l + a + u
              , v = o + d
              , S = o + n - d
              , w = l + d
              , E = l + a - d;
            return e >= f && e <= b && t >= m && t <= x && !(e > v && e < S && t > w && t < E)
        }
        intersects(e, t) {
            if (!t) {
                let ie = this.x < e.x ? e.x : this.x;
                if ((this.right > e.right ? e.right : this.right) <= ie)
                    return !1;
                let te = this.y < e.y ? e.y : this.y;
                return (this.bottom > e.bottom ? e.bottom : this.bottom) > te
            }
            let r = this.left
              , s = this.right
              , n = this.top
              , a = this.bottom;
            if (s <= r || a <= n)
                return !1;
            let o = Xs[0].set(e.left, e.top)
              , l = Xs[1].set(e.left, e.bottom)
              , u = Xs[2].set(e.right, e.top)
              , d = Xs[3].set(e.right, e.bottom);
            if (u.x <= o.x || l.y <= o.y)
                return !1;
            let f = Math.sign(t.a * t.d - t.b * t.c);
            if (f === 0 || (t.apply(o, o),
            t.apply(l, l),
            t.apply(u, u),
            t.apply(d, d),
            Math.max(o.x, l.x, u.x, d.x) <= r || Math.min(o.x, l.x, u.x, d.x) >= s || Math.max(o.y, l.y, u.y, d.y) <= n || Math.min(o.y, l.y, u.y, d.y) >= a))
                return !1;
            let b = f * (l.y - o.y)
              , m = f * (o.x - l.x)
              , x = b * r + m * n
              , v = b * s + m * n
              , S = b * r + m * a
              , w = b * s + m * a;
            if (Math.max(x, v, S, w) <= b * o.x + m * o.y || Math.min(x, v, S, w) >= b * d.x + m * d.y)
                return !1;
            let E = f * (o.y - u.y)
              , P = f * (u.x - o.x)
              , C = E * r + P * n
              , L = E * s + P * n
              , F = E * r + P * a
              , X = E * s + P * a;
            return !(Math.max(C, L, F, X) <= E * o.x + P * o.y || Math.min(C, L, F, X) >= E * d.x + P * d.y)
        }
        pad(e=0, t=e) {
            return this.x -= e,
            this.y -= t,
            this.width += e * 2,
            this.height += t * 2,
            this
        }
        fit(e) {
            let t = Math.max(this.x, e.x)
              , r = Math.min(this.x + this.width, e.x + e.width)
              , s = Math.max(this.y, e.y)
              , n = Math.min(this.y + this.height, e.y + e.height);
            return this.x = t,
            this.width = Math.max(r - t, 0),
            this.y = s,
            this.height = Math.max(n - s, 0),
            this
        }
        ceil(e=1, t=.001) {
            let r = Math.ceil((this.x + this.width - t) * e) / e
              , s = Math.ceil((this.y + this.height - t) * e) / e;
            return this.x = Math.floor((this.x + t) * e) / e,
            this.y = Math.floor((this.y + t) * e) / e,
            this.width = r - this.x,
            this.height = s - this.y,
            this
        }
        scale(e, t=e) {
            return this.x *= e,
            this.y *= t,
            this.width *= e,
            this.height *= t,
            this
        }
        enlarge(e) {
            let t = Math.min(this.x, e.x)
              , r = Math.max(this.x + this.width, e.x + e.width)
              , s = Math.min(this.y, e.y)
              , n = Math.max(this.y + this.height, e.y + e.height);
            return this.x = t,
            this.width = r - t,
            this.y = s,
            this.height = n - s,
            this
        }
        getBounds(e) {
            return e || (e = new i),
            e.copyFrom(this),
            e
        }
        containsRect(e) {
            if (this.width <= 0 || this.height <= 0)
                return !1;
            let t = e.x
              , r = e.y
              , s = e.x + e.width
              , n = e.y + e.height;
            return t >= this.x && t < this.x + this.width && r >= this.y && r < this.y + this.height && s >= this.x && s < this.x + this.width && n >= this.y && n < this.y + this.height
        }
        set(e, t, r, s) {
            return this.x = e,
            this.y = t,
            this.width = r,
            this.height = s,
            this
        }
    }
      , hu = new ce
      , at = class i {
        constructor(e=1 / 0, t=1 / 0, r=-1 / 0, s=-1 / 0) {
            this.minX = 1 / 0,
            this.minY = 1 / 0,
            this.maxX = -1 / 0,
            this.maxY = -1 / 0,
            this.matrix = hu,
            this.minX = e,
            this.minY = t,
            this.maxX = r,
            this.maxY = s
        }
        isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY
        }
        get rectangle() {
            this._rectangle || (this._rectangle = new Oe);
            let e = this._rectangle;
            return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0,
            e.y = 0,
            e.width = 0,
            e.height = 0) : e.copyFromBounds(this),
            e
        }
        clear() {
            return this.minX = 1 / 0,
            this.minY = 1 / 0,
            this.maxX = -1 / 0,
            this.maxY = -1 / 0,
            this.matrix = hu,
            this
        }
        set(e, t, r, s) {
            this.minX = e,
            this.minY = t,
            this.maxX = r,
            this.maxY = s
        }
        addFrame(e, t, r, s, n) {
            n || (n = this.matrix);
            let a = n.a
              , o = n.b
              , l = n.c
              , u = n.d
              , d = n.tx
              , f = n.ty
              , b = this.minX
              , m = this.minY
              , x = this.maxX
              , v = this.maxY
              , S = a * e + l * t + d
              , w = o * e + u * t + f;
            S < b && (b = S),
            w < m && (m = w),
            S > x && (x = S),
            w > v && (v = w),
            S = a * r + l * t + d,
            w = o * r + u * t + f,
            S < b && (b = S),
            w < m && (m = w),
            S > x && (x = S),
            w > v && (v = w),
            S = a * e + l * s + d,
            w = o * e + u * s + f,
            S < b && (b = S),
            w < m && (m = w),
            S > x && (x = S),
            w > v && (v = w),
            S = a * r + l * s + d,
            w = o * r + u * s + f,
            S < b && (b = S),
            w < m && (m = w),
            S > x && (x = S),
            w > v && (v = w),
            this.minX = b,
            this.minY = m,
            this.maxX = x,
            this.maxY = v
        }
        addRect(e, t) {
            this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t)
        }
        addBounds(e, t) {
            this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t)
        }
        addBoundsMask(e) {
            this.minX = this.minX > e.minX ? this.minX : e.minX,
            this.minY = this.minY > e.minY ? this.minY : e.minY,
            this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX,
            this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY
        }
        applyMatrix(e) {
            let t = this.minX
              , r = this.minY
              , s = this.maxX
              , n = this.maxY
              , {a, b: o, c: l, d: u, tx: d, ty: f} = e
              , b = a * t + l * r + d
              , m = o * t + u * r + f;
            this.minX = b,
            this.minY = m,
            this.maxX = b,
            this.maxY = m,
            b = a * s + l * r + d,
            m = o * s + u * r + f,
            this.minX = b < this.minX ? b : this.minX,
            this.minY = m < this.minY ? m : this.minY,
            this.maxX = b > this.maxX ? b : this.maxX,
            this.maxY = m > this.maxY ? m : this.maxY,
            b = a * t + l * n + d,
            m = o * t + u * n + f,
            this.minX = b < this.minX ? b : this.minX,
            this.minY = m < this.minY ? m : this.minY,
            this.maxX = b > this.maxX ? b : this.maxX,
            this.maxY = m > this.maxY ? m : this.maxY,
            b = a * s + l * n + d,
            m = o * s + u * n + f,
            this.minX = b < this.minX ? b : this.minX,
            this.minY = m < this.minY ? m : this.minY,
            this.maxX = b > this.maxX ? b : this.maxX,
            this.maxY = m > this.maxY ? m : this.maxY
        }
        fit(e) {
            return this.minX < e.left && (this.minX = e.left),
            this.maxX > e.right && (this.maxX = e.right),
            this.minY < e.top && (this.minY = e.top),
            this.maxY > e.bottom && (this.maxY = e.bottom),
            this
        }
        fitBounds(e, t, r, s) {
            return this.minX < e && (this.minX = e),
            this.maxX > t && (this.maxX = t),
            this.minY < r && (this.minY = r),
            this.maxY > s && (this.maxY = s),
            this
        }
        pad(e, t=e) {
            return this.minX -= e,
            this.maxX += e,
            this.minY -= t,
            this.maxY += t,
            this
        }
        ceil() {
            return this.minX = Math.floor(this.minX),
            this.minY = Math.floor(this.minY),
            this.maxX = Math.ceil(this.maxX),
            this.maxY = Math.ceil(this.maxY),
            this
        }
        clone() {
            return new i(this.minX,this.minY,this.maxX,this.maxY)
        }
        scale(e, t=e) {
            return this.minX *= e,
            this.minY *= t,
            this.maxX *= e,
            this.maxY *= t,
            this
        }
        get x() {
            return this.minX
        }
        set x(e) {
            let t = this.maxX - this.minX;
            this.minX = e,
            this.maxX = e + t
        }
        get y() {
            return this.minY
        }
        set y(e) {
            let t = this.maxY - this.minY;
            this.minY = e,
            this.maxY = e + t
        }
        get width() {
            return this.maxX - this.minX
        }
        set width(e) {
            this.maxX = this.minX + e
        }
        get height() {
            return this.maxY - this.minY
        }
        set height(e) {
            this.maxY = this.minY + e
        }
        get left() {
            return this.minX
        }
        get right() {
            return this.maxX
        }
        get top() {
            return this.minY
        }
        get bottom() {
            return this.maxY
        }
        get isPositive() {
            return this.maxX - this.minX > 0 && this.maxY - this.minY > 0
        }
        get isValid() {
            return this.minX + this.minY !== 1 / 0
        }
        addVertexData(e, t, r, s) {
            let n = this.minX
              , a = this.minY
              , o = this.maxX
              , l = this.maxY;
            s || (s = this.matrix);
            let u = s.a
              , d = s.b
              , f = s.c
              , b = s.d
              , m = s.tx
              , x = s.ty;
            for (let v = t; v < r; v += 2) {
                let S = e[v]
                  , w = e[v + 1]
                  , E = u * S + f * w + m
                  , P = d * S + b * w + x;
                n = E < n ? E : n,
                a = P < a ? P : a,
                o = E > o ? E : o,
                l = P > l ? P : l
            }
            this.minX = n,
            this.minY = a,
            this.maxX = o,
            this.maxY = l
        }
        containsPoint(e, t) {
            return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t
        }
        toString() {
            return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`
        }
        copyFrom(e) {
            return this.minX = e.minX,
            this.minY = e.minY,
            this.maxX = e.maxX,
            this.maxY = e.maxY,
            this
        }
    }
      , pt = Je.getPool(ce)
      , ui = Je.getPool(at)
      , j1 = new ce
      , H1 = {
        getFastGlobalBounds(i, e) {
            e || (e = new at),
            e.clear(),
            this._getGlobalBoundsRecursive(!!i, e, this.parentRenderLayer),
            e.isValid || e.set(0, 0, 0, 0);
            let t = this.renderGroup || this.parentRenderGroup;
            return e.applyMatrix(t.worldTransform),
            e
        },
        _getGlobalBoundsRecursive(i, e, t) {
            let r = e;
            if (i && this.parentRenderLayer && this.parentRenderLayer !== t || this.localDisplayStatus !== 7 || !this.measurable)
                return;
            let s = !!this.effects.length;
            if ((this.renderGroup || s) && (r = ui.get().clear()),
            this.boundsArea)
                e.addRect(this.boundsArea, this.worldTransform);
            else {
                if (this.renderPipeId) {
                    let a = this.bounds;
                    r.addFrame(a.minX, a.minY, a.maxX, a.maxY, this.groupTransform)
                }
                let n = this.children;
                for (let a = 0; a < n.length; a++)
                    n[a]._getGlobalBoundsRecursive(i, r, t)
            }
            if (s) {
                let n = !1
                  , a = this.renderGroup || this.parentRenderGroup;
                for (let o = 0; o < this.effects.length; o++)
                    this.effects[o].addBounds && (n || (n = !0,
                    r.applyMatrix(a.worldTransform)),
                    this.effects[o].addBounds(r, !0));
                n && r.applyMatrix(a.worldTransform.copyTo(j1).invert()),
                e.addBounds(r),
                ui.return(r)
            } else
                this.renderGroup && (e.addBounds(r, this.relativeGroupTransform),
                ui.return(r))
        }
    };
    function fo(i, e, t) {
        t.clear();
        let r, s;
        return i.parent ? e ? r = i.parent.worldTransform : (s = pt.get().identity(),
        r = Ah(i, s)) : r = ce.IDENTITY,
        W0(i, t, r, e),
        s && pt.return(s),
        t.isValid || t.set(0, 0, 0, 0),
        t
    }
    function W0(i, e, t, r) {
        var s, n;
        if (!i.visible || !i.measurable)
            return;
        let a;
        r ? a = i.worldTransform : (i.updateLocalTransform(),
        a = pt.get(),
        a.appendFrom(i.localTransform, t));
        let o = e
          , l = !!i.effects.length;
        if (l && (e = ui.get().clear()),
        i.boundsArea)
            e.addRect(i.boundsArea, a);
        else {
            let u = i.bounds;
            u && !u.isEmpty() && (e.matrix = a,
            e.addBounds(u));
            for (let d = 0; d < i.children.length; d++)
                W0(i.children[d], e, a, r)
        }
        if (l) {
            for (let u = 0; u < i.effects.length; u++)
                (n = (s = i.effects[u]).addBounds) == null || n.call(s, e);
            o.addBounds(e, ce.IDENTITY),
            ui.return(e)
        }
        r || pt.return(a)
    }
    function Ah(i, e) {
        let t = i.parent;
        return t && (Ah(t, e),
        t.updateLocalTransform(),
        e.append(t.localTransform)),
        e
    }
    function Y0(i, e) {
        if (i === 16777215 || !e)
            return e;
        if (e === 16777215 || !i)
            return i;
        let t = i >> 16 & 255
          , r = i >> 8 & 255
          , s = i & 255
          , n = e >> 16 & 255
          , a = e >> 8 & 255
          , o = e & 255
          , l = t * n / 255 | 0
          , u = r * a / 255 | 0
          , d = s * o / 255 | 0;
        return (l << 16) + (u << 8) + d
    }
    var uu = 16777215;
    function bn(i, e) {
        return i === uu ? e : e === uu ? i : Y0(i, e)
    }
    function ts(i) {
        return ((i & 255) << 16) + (i & 65280) + (i >> 16 & 255)
    }
    var z1 = {
        getGlobalAlpha(i) {
            if (i)
                return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
            let e = this.alpha
              , t = this.parent;
            for (; t; )
                e *= t.alpha,
                t = t.parent;
            return e
        },
        getGlobalTransform(i=new ce, e) {
            if (e)
                return i.copyFrom(this.worldTransform);
            this.updateLocalTransform();
            let t = Ah(this, pt.get().identity());
            return i.appendFrom(this.localTransform, t),
            pt.return(t),
            i
        },
        getGlobalTint(i) {
            if (i)
                return this.renderGroup ? ts(this.renderGroup.worldColor) : this.parentRenderGroup ? ts(bn(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
            let e = this.localColor
              , t = this.parent;
            for (; t; )
                e = bn(e, t.localColor),
                t = t.parent;
            return ts(e)
        }
    };
    function Eh(i, e, t) {
        return e.clear(),
        t || (t = ce.IDENTITY),
        $0(i, e, t, i, !0),
        e.isValid || e.set(0, 0, 0, 0),
        e
    }
    function $0(i, e, t, r, s) {
        var n, a;
        let o;
        if (s)
            o = pt.get(),
            o = t.copyTo(o);
        else {
            if (!i.visible || !i.measurable)
                return;
            i.updateLocalTransform();
            let d = i.localTransform;
            o = pt.get(),
            o.appendFrom(d, t)
        }
        let l = e
          , u = !!i.effects.length;
        if (u && (e = ui.get().clear()),
        i.boundsArea)
            e.addRect(i.boundsArea, o);
        else {
            i.renderPipeId && (e.matrix = o,
            e.addBounds(i.bounds));
            let d = i.children;
            for (let f = 0; f < d.length; f++)
                $0(d[f], e, o, r, !1)
        }
        if (u) {
            for (let d = 0; d < i.effects.length; d++)
                (a = (n = i.effects[d]).addLocalBounds) == null || a.call(n, e, r);
            l.addBounds(e, ce.IDENTITY),
            ui.return(e)
        }
        pt.return(o)
    }
    function K0(i, e) {
        let t = i.children;
        for (let r = 0; r < t.length; r++) {
            let s = t[r]
              , n = s.uid
              , a = (s._didViewChangeTick & 65535) << 16 | s._didContainerChangeTick & 65535
              , o = e.index;
            (e.data[o] !== n || e.data[o + 1] !== a) && (e.data[e.index] = n,
            e.data[e.index + 1] = a,
            e.didChange = !0),
            e.index = o + 2,
            s.children.length && K0(s, e)
        }
        return e.didChange
    }
    var V1 = new ce
      , W1 = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(i, e) {
            let t = Math.sign(this.scale.x) || 1;
            e !== 0 ? this.scale.x = i / e * t : this.scale.x = t
        },
        _setHeight(i, e) {
            let t = Math.sign(this.scale.y) || 1;
            e !== 0 ? this.scale.y = i / e * t : this.scale.y = t
        },
        getLocalBounds() {
            this._localBoundsCacheData || (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new at
            });
            let i = this._localBoundsCacheData;
            return i.index = 1,
            i.didChange = !1,
            i.data[0] !== this._didViewChangeTick && (i.didChange = !0,
            i.data[0] = this._didViewChangeTick),
            K0(this, i),
            i.didChange && Eh(this, i.localBounds, V1),
            i.localBounds
        },
        getBounds(i, e) {
            return fo(this, i, e || new at)
        }
    }
      , Y1 = {
        _onRender: null,
        set onRender(i) {
            let e = this.renderGroup || this.parentRenderGroup;
            if (!i) {
                this._onRender && e?.removeOnRender(this),
                this._onRender = null;
                return
            }
            this._onRender || e == null || e.addOnRender(this),
            this._onRender = i
        },
        get onRender() {
            return this._onRender
        }
    }
      , $1 = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex() {
            return this._zIndex
        },
        set zIndex(i) {
            this._zIndex !== i && (this._zIndex = i,
            this.depthOfChildModified())
        },
        depthOfChildModified() {
            this.parent && (this.parent.sortableChildren = !0,
            this.parent.sortDirty = !0),
            this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0)
        },
        sortChildren() {
            this.sortDirty && (this.sortDirty = !1,
            this.children.sort(K1))
        }
    };
    function K1(i, e) {
        return i._zIndex - e._zIndex
    }
    var q1 = {
        getGlobalPosition(i=new Ue, e=!1) {
            return this.parent ? this.parent.toGlobal(this._position, i, e) : (i.x = this._position.x,
            i.y = this._position.y),
            i
        },
        toGlobal(i, e, t=!1) {
            let r = this.getGlobalTransform(pt.get(), t);
            return e = r.apply(i, e),
            pt.return(r),
            e
        },
        toLocal(i, e, t, r) {
            e && (i = e.toGlobal(i, t, r));
            let s = this.getGlobalTransform(pt.get(), r);
            return t = s.applyInverse(i, t),
            pt.return(s),
            t
        }
    }
      , mn = class {
        constructor() {
            this.uid = Le("instructionSet"),
            this.instructions = [],
            this.instructionSize = 0,
            this.renderables = [],
            this.gcTick = 0
        }
        reset() {
            this.instructionSize = 0
        }
        destroy() {
            this.instructions.length = 0,
            this.renderables.length = 0,
            this.renderPipes = null,
            this.gcTick = 0
        }
        add(e) {
            this.instructions[this.instructionSize++] = e
        }
        log() {
            this.instructions.length = this.instructionSize
        }
    }
    ;
    function yr(i) {
        return i += i === 0 ? 1 : 0,
        --i,
        i |= i >>> 1,
        i |= i >>> 2,
        i |= i >>> 4,
        i |= i >>> 8,
        i |= i >>> 16,
        i + 1
    }
    function du(i) {
        return !(i & i - 1) && !!i
    }
    function vr(i) {
        let e = {};
        for (let t in i)
            i[t] !== void 0 && (e[t] = i[t]);
        return e
    }
    var Z1 = Object.defineProperty
      , fu = Object.getOwnPropertySymbols
      , Q1 = Object.prototype.hasOwnProperty
      , J1 = Object.prototype.propertyIsEnumerable
      , pu = (i, e, t) => e in i ? Z1(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , bu = (i, e) => {
        for (var t in e || (e = {}))
            Q1.call(e, t) && pu(i, t, e[t]);
        if (fu)
            for (var t of fu(e))
                J1.call(e, t) && pu(i, t, e[t]);
        return i
    }
      , mu = Object.create(null);
    function e_(i) {
        let e = mu[i];
        return e === void 0 && (mu[i] = Le("resource")),
        e
    }
    var q0 = class Z0 extends Ot {
        constructor(e={}) {
            var t, r, s, n, a, o, l;
            super(),
            this._resourceType = "textureSampler",
            this._touched = 0,
            this._maxAnisotropy = 1,
            this.destroyed = !1,
            e = bu(bu({}, Z0.defaultOptions), e),
            this.addressMode = e.addressMode,
            this.addressModeU = (t = e.addressModeU) != null ? t : this.addressModeU,
            this.addressModeV = (r = e.addressModeV) != null ? r : this.addressModeV,
            this.addressModeW = (s = e.addressModeW) != null ? s : this.addressModeW,
            this.scaleMode = e.scaleMode,
            this.magFilter = (n = e.magFilter) != null ? n : this.magFilter,
            this.minFilter = (a = e.minFilter) != null ? a : this.minFilter,
            this.mipmapFilter = (o = e.mipmapFilter) != null ? o : this.mipmapFilter,
            this.lodMinClamp = e.lodMinClamp,
            this.lodMaxClamp = e.lodMaxClamp,
            this.compare = e.compare,
            this.maxAnisotropy = (l = e.maxAnisotropy) != null ? l : 1
        }
        set addressMode(e) {
            this.addressModeU = e,
            this.addressModeV = e,
            this.addressModeW = e
        }
        get addressMode() {
            return this.addressModeU
        }
        set wrapMode(e) {
            this.addressMode = e
        }
        get wrapMode() {
            return this.addressMode
        }
        set scaleMode(e) {
            this.magFilter = e,
            this.minFilter = e,
            this.mipmapFilter = e
        }
        get scaleMode() {
            return this.magFilter
        }
        set maxAnisotropy(e) {
            this._maxAnisotropy = Math.min(e, 16),
            this._maxAnisotropy > 1 && (this.scaleMode = "linear")
        }
        get maxAnisotropy() {
            return this._maxAnisotropy
        }
        get _resourceId() {
            return this._sharedResourceId || this._generateResourceId()
        }
        update() {
            this.emit("change", this),
            this._sharedResourceId = null
        }
        _generateResourceId() {
            let e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
            return this._sharedResourceId = e_(e),
            this._resourceId
        }
        destroy() {
            this.destroyed = !0,
            this.emit("destroy", this),
            this.emit("change", this),
            this.removeAllListeners()
        }
    }
    ;
    q0.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
    };
    var kt = q0
      , t_ = Object.defineProperty
      , gu = Object.getOwnPropertySymbols
      , i_ = Object.prototype.hasOwnProperty
      , r_ = Object.prototype.propertyIsEnumerable
      , _u = (i, e, t) => e in i ? t_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , xu = (i, e) => {
        for (var t in e || (e = {}))
            i_.call(e, t) && _u(i, t, e[t]);
        if (gu)
            for (var t of gu(e))
                r_.call(e, t) && _u(i, t, e[t]);
        return i
    }
      , Q0 = class J0 extends Ot {
        constructor(e={}) {
            var t, r, s;
            super(),
            this.options = e,
            this.uid = Le("textureSource"),
            this._resourceType = "textureSource",
            this._resourceId = Le("resource"),
            this.uploadMethodId = "unknown",
            this._resolution = 1,
            this.pixelWidth = 1,
            this.pixelHeight = 1,
            this.width = 1,
            this.height = 1,
            this.sampleCount = 1,
            this.mipLevelCount = 1,
            this.autoGenerateMipmaps = !1,
            this.format = "rgba8unorm",
            this.dimension = "2d",
            this.antialias = !1,
            this._touched = 0,
            this._batchTick = -1,
            this._textureBindLocation = -1,
            e = xu(xu({}, J0.defaultOptions), e),
            this.label = (t = e.label) != null ? t : "",
            this.resource = e.resource,
            this.autoGarbageCollect = e.autoGarbageCollect,
            this._resolution = e.resolution,
            e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource && (r = this.resourceWidth) != null ? r : 1,
            e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource && (s = this.resourceHeight) != null ? s : 1,
            this.width = this.pixelWidth / this._resolution,
            this.height = this.pixelHeight / this._resolution,
            this.format = e.format,
            this.dimension = e.dimensions,
            this.mipLevelCount = e.mipLevelCount,
            this.autoGenerateMipmaps = e.autoGenerateMipmaps,
            this.sampleCount = e.sampleCount,
            this.antialias = e.antialias,
            this.alphaMode = e.alphaMode,
            this.style = new kt(vr(e)),
            this.destroyed = !1,
            this._refreshPOT()
        }
        get source() {
            return this
        }
        get style() {
            return this._style
        }
        set style(e) {
            var t, r;
            this.style !== e && ((t = this._style) == null || t.off("change", this._onStyleChange, this),
            this._style = e,
            (r = this._style) == null || r.on("change", this._onStyleChange, this),
            this._onStyleChange())
        }
        set maxAnisotropy(e) {
            this._style.maxAnisotropy = e
        }
        get maxAnisotropy() {
            return this._style.maxAnisotropy
        }
        get addressMode() {
            return this._style.addressMode
        }
        set addressMode(e) {
            this._style.addressMode = e
        }
        get repeatMode() {
            return this._style.addressMode
        }
        set repeatMode(e) {
            this._style.addressMode = e
        }
        get magFilter() {
            return this._style.magFilter
        }
        set magFilter(e) {
            this._style.magFilter = e
        }
        get minFilter() {
            return this._style.minFilter
        }
        set minFilter(e) {
            this._style.minFilter = e
        }
        get mipmapFilter() {
            return this._style.mipmapFilter
        }
        set mipmapFilter(e) {
            this._style.mipmapFilter = e
        }
        get lodMinClamp() {
            return this._style.lodMinClamp
        }
        set lodMinClamp(e) {
            this._style.lodMinClamp = e
        }
        get lodMaxClamp() {
            return this._style.lodMaxClamp
        }
        set lodMaxClamp(e) {
            this._style.lodMaxClamp = e
        }
        _onStyleChange() {
            this.emit("styleChange", this)
        }
        update() {
            if (this.resource) {
                let e = this._resolution;
                if (this.resize(this.resourceWidth / e, this.resourceHeight / e))
                    return
            }
            this.emit("update", this)
        }
        destroy() {
            this.destroyed = !0,
            this.emit("destroy", this),
            this.emit("change", this),
            this._style && (this._style.destroy(),
            this._style = null),
            this.uploadMethodId = null,
            this.resource = null,
            this.removeAllListeners()
        }
        unload() {
            this._resourceId = Le("resource"),
            this.emit("change", this),
            this.emit("unload", this)
        }
        get resourceWidth() {
            let {resource: e} = this;
            return e.naturalWidth || e.videoWidth || e.displayWidth || e.width
        }
        get resourceHeight() {
            let {resource: e} = this;
            return e.naturalHeight || e.videoHeight || e.displayHeight || e.height
        }
        get resolution() {
            return this._resolution
        }
        set resolution(e) {
            this._resolution !== e && (this._resolution = e,
            this.width = this.pixelWidth / e,
            this.height = this.pixelHeight / e)
        }
        resize(e, t, r) {
            r || (r = this._resolution),
            e || (e = this.width),
            t || (t = this.height);
            let s = Math.round(e * r)
              , n = Math.round(t * r);
            return this.width = s / r,
            this.height = n / r,
            this._resolution = r,
            this.pixelWidth === s && this.pixelHeight === n ? !1 : (this._refreshPOT(),
            this.pixelWidth = s,
            this.pixelHeight = n,
            this.emit("resize", this),
            this._resourceId = Le("resource"),
            this.emit("change", this),
            !0)
        }
        updateMipmaps() {
            this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this)
        }
        set wrapMode(e) {
            this._style.wrapMode = e
        }
        get wrapMode() {
            return this._style.wrapMode
        }
        set scaleMode(e) {
            this._style.scaleMode = e
        }
        get scaleMode() {
            return this._style.scaleMode
        }
        _refreshPOT() {
            this.isPowerOfTwo = du(this.pixelWidth) && du(this.pixelHeight)
        }
        static test(e) {
            throw new Error("Unimplemented")
        }
    }
    ;
    Q0.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: !1,
        sampleCount: 1,
        antialias: !1,
        autoGarbageCollect: !1
    };
    var Xe = Q0
      , ji = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
      , Hi = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
      , zi = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
      , Vi = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
      , Dc = []
      , eb = []
      , js = Math.sign;
    function s_() {
        for (let i = 0; i < 16; i++) {
            let e = [];
            Dc.push(e);
            for (let t = 0; t < 16; t++) {
                let r = js(ji[i] * ji[t] + zi[i] * Hi[t])
                  , s = js(Hi[i] * ji[t] + Vi[i] * Hi[t])
                  , n = js(ji[i] * zi[t] + zi[i] * Vi[t])
                  , a = js(Hi[i] * zi[t] + Vi[i] * Vi[t]);
                for (let o = 0; o < 16; o++)
                    if (ji[o] === r && Hi[o] === s && zi[o] === n && Vi[o] === a) {
                        e.push(o);
                        break
                    }
            }
        }
        for (let i = 0; i < 16; i++) {
            let e = new ce;
            e.set(ji[i], Hi[i], zi[i], Vi[i], 0, 0),
            eb.push(e)
        }
    }
    s_();
    var De = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: i => ji[i],
        uY: i => Hi[i],
        vX: i => zi[i],
        vY: i => Vi[i],
        inv: i => i & 8 ? i & 15 : -i & 7,
        add: (i, e) => Dc[i][e],
        sub: (i, e) => Dc[i][De.inv(e)],
        rotate180: i => i ^ 4,
        isVertical: i => (i & 3) === 2,
        byDirection: (i, e) => Math.abs(i) * 2 <= Math.abs(e) ? e >= 0 ? De.S : De.N : Math.abs(e) * 2 <= Math.abs(i) ? i > 0 ? De.E : De.W : e > 0 ? i > 0 ? De.SE : De.SW : i > 0 ? De.NE : De.NW,
        matrixAppendRotationInv: (i, e, t=0, r=0) => {
            let s = eb[De.inv(e)];
            s.tx = t,
            s.ty = r,
            i.append(s)
        }
        ,
        transformRectCoords: (i, e, t, r) => {
            let {x: s, y: n, width: a, height: o} = i
              , {x: l, y: u, width: d, height: f} = e;
            return t === De.E ? (r.set(s + l, n + u, a, o),
            r) : t === De.S ? r.set(d - n - o + l, s + u, o, a) : t === De.W ? r.set(d - s - a + l, f - n - o + u, a, o) : t === De.N ? r.set(n + l, f - s - a + u, o, a) : r.set(s + l, n + u, a, o)
        }
    }
      , yu = () => {}
      , n_ = Object.defineProperty
      , a_ = Object.defineProperties
      , o_ = Object.getOwnPropertyDescriptors
      , vu = Object.getOwnPropertySymbols
      , c_ = Object.prototype.hasOwnProperty
      , l_ = Object.prototype.propertyIsEnumerable
      , Tu = (i, e, t) => e in i ? n_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , h_ = (i, e) => {
        for (var t in e || (e = {}))
            c_.call(e, t) && Tu(i, t, e[t]);
        if (vu)
            for (var t of vu(e))
                l_.call(e, t) && Tu(i, t, e[t]);
        return i
    }
      , u_ = (i, e) => a_(i, o_(e))
      , us = class extends Xe {
        constructor(e) {
            let t = e.resource || new Float32Array(e.width * e.height * 4)
              , r = e.format;
            r || (t instanceof Float32Array ? r = "rgba32float" : t instanceof Int32Array || t instanceof Uint32Array ? r = "rgba32uint" : t instanceof Int16Array || t instanceof Uint16Array ? r = "rgba16uint" : (t instanceof Int8Array,
            r = "bgra8unorm")),
            super(u_(h_({}, e), {
                resource: t,
                format: r
            })),
            this.uploadMethodId = "buffer"
        }
        static test(e) {
            return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array
        }
    }
    ;
    us.extension = O.TextureSource;
    var Su = new ce
      , gn = class {
        constructor(e, t) {
            this.mapCoord = new ce,
            this.uClampFrame = new Float32Array(4),
            this.uClampOffset = new Float32Array(2),
            this._textureID = -1,
            this._updateID = 0,
            this.clampOffset = 0,
            typeof t > "u" ? this.clampMargin = e.width < 10 ? 0 : .5 : this.clampMargin = t,
            this.isSimple = !1,
            this.texture = e
        }
        get texture() {
            return this._texture
        }
        set texture(e) {
            var t;
            this.texture !== e && ((t = this._texture) == null || t.removeListener("update", this.update, this),
            this._texture = e,
            this._texture.addListener("update", this.update, this),
            this.update())
        }
        multiplyUvs(e, t) {
            t === void 0 && (t = e);
            let r = this.mapCoord;
            for (let s = 0; s < e.length; s += 2) {
                let n = e[s]
                  , a = e[s + 1];
                t[s] = n * r.a + a * r.c + r.tx,
                t[s + 1] = n * r.b + a * r.d + r.ty
            }
            return t
        }
        update() {
            let e = this._texture;
            this._updateID++;
            let t = e.uvs;
            this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0);
            let r = e.orig
              , s = e.trim;
            s && (Su.set(r.width / s.width, 0, 0, r.height / s.height, -s.x / s.width, -s.y / s.height),
            this.mapCoord.append(Su));
            let n = e.source
              , a = this.uClampFrame
              , o = this.clampMargin / n._resolution
              , l = this.clampOffset / n._resolution;
            return a[0] = (e.frame.x + o + l) / n.width,
            a[1] = (e.frame.y + o + l) / n.height,
            a[2] = (e.frame.x + e.frame.width - o + l) / n.width,
            a[3] = (e.frame.y + e.frame.height - o + l) / n.height,
            this.uClampOffset[0] = this.clampOffset / n.pixelWidth,
            this.uClampOffset[1] = this.clampOffset / n.pixelHeight,
            this.isSimple = e.frame.width === n.width && e.frame.height === n.height && e.rotate === 0,
            !0
        }
    }
      , Z = class extends Ot {
        constructor({source: e, label: t, frame: r, orig: s, trim: n, defaultAnchor: a, defaultBorders: o, rotate: l, dynamic: u}={}) {
            var d;
            if (super(),
            this.uid = Le("texture"),
            this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0
            },
            this.frame = new Oe,
            this.noFrame = !1,
            this.dynamic = !1,
            this.isTexture = !0,
            this.label = t,
            this.source = (d = e?.source) != null ? d : new Xe,
            this.noFrame = !r,
            r)
                this.frame.copyFrom(r);
            else {
                let {width: f, height: b} = this._source;
                this.frame.width = f,
                this.frame.height = b
            }
            this.orig = s || this.frame,
            this.trim = n,
            this.rotate = l ?? 0,
            this.defaultAnchor = a,
            this.defaultBorders = o,
            this.destroyed = !1,
            this.dynamic = u || !1,
            this.updateUvs()
        }
        set source(e) {
            this._source && this._source.off("resize", this.update, this),
            this._source = e,
            e.on("resize", this.update, this),
            this.emit("update", this)
        }
        get source() {
            return this._source
        }
        get textureMatrix() {
            return this._textureMatrix || (this._textureMatrix = new gn(this)),
            this._textureMatrix
        }
        get width() {
            return this.orig.width
        }
        get height() {
            return this.orig.height
        }
        updateUvs() {
            let {uvs: e, frame: t} = this
              , {width: r, height: s} = this._source
              , n = t.x / r
              , a = t.y / s
              , o = t.width / r
              , l = t.height / s
              , u = this.rotate;
            if (u) {
                let d = o / 2
                  , f = l / 2
                  , b = n + d
                  , m = a + f;
                u = De.add(u, De.NW),
                e.x0 = b + d * De.uX(u),
                e.y0 = m + f * De.uY(u),
                u = De.add(u, 2),
                e.x1 = b + d * De.uX(u),
                e.y1 = m + f * De.uY(u),
                u = De.add(u, 2),
                e.x2 = b + d * De.uX(u),
                e.y2 = m + f * De.uY(u),
                u = De.add(u, 2),
                e.x3 = b + d * De.uX(u),
                e.y3 = m + f * De.uY(u)
            } else
                e.x0 = n,
                e.y0 = a,
                e.x1 = n + o,
                e.y1 = a,
                e.x2 = n + o,
                e.y2 = a + l,
                e.x3 = n,
                e.y3 = a + l
        }
        destroy(e=!1) {
            this._source && e && (this._source.destroy(),
            this._source = null),
            this._textureMatrix = null,
            this.destroyed = !0,
            this.emit("destroy", this),
            this.removeAllListeners()
        }
        update() {
            this.noFrame && (this.frame.width = this._source.width,
            this.frame.height = this._source.height),
            this.updateUvs(),
            this.emit("update", this)
        }
        get baseTexture() {
            return this._source
        }
    }
    ;
    Z.EMPTY = new Z({
        label: "EMPTY",
        source: new Xe({
            label: "EMPTY"
        })
    }),
    Z.EMPTY.destroy = yu,
    Z.WHITE = new Z({
        source: new us({
            resource: new Uint8Array([255, 255, 255, 255]),
            width: 1,
            height: 1,
            alphaMode: "premultiply-alpha-on-upload",
            label: "WHITE"
        }),
        label: "WHITE"
    }),
    Z.WHITE.destroy = yu;
    var d_ = Object.defineProperty
      , f_ = Object.defineProperties
      , p_ = Object.getOwnPropertyDescriptors
      , wu = Object.getOwnPropertySymbols
      , b_ = Object.prototype.hasOwnProperty
      , m_ = Object.prototype.propertyIsEnumerable
      , Au = (i, e, t) => e in i ? d_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , g_ = (i, e) => {
        for (var t in e || (e = {}))
            b_.call(e, t) && Au(i, t, e[t]);
        if (wu)
            for (var t of wu(e))
                m_.call(e, t) && Au(i, t, e[t]);
        return i
    }
      , __ = (i, e) => f_(i, p_(e))
      , x_ = 0
      , kc = class {
        constructor(e) {
            this._poolKeyHash = Object.create(null),
            this._texturePool = {},
            this.textureOptions = e || {},
            this.enableFullScreen = !1,
            this.textureStyle = new kt(this.textureOptions)
        }
        createTexture(e, t, r) {
            let s = new Xe(__(g_({}, this.textureOptions), {
                width: e,
                height: t,
                resolution: 1,
                antialias: r,
                autoGarbageCollect: !1
            }));
            return new Z({
                source: s,
                label: `texturePool_${x_++}`
            })
        }
        getOptimalTexture(e, t, r=1, s) {
            let n = Math.ceil(e * r - 1e-6)
              , a = Math.ceil(t * r - 1e-6);
            n = yr(n),
            a = yr(a);
            let o = (n << 17) + (a << 1) + (s ? 1 : 0);
            this._texturePool[o] || (this._texturePool[o] = []);
            let l = this._texturePool[o].pop();
            return l || (l = this.createTexture(n, a, s)),
            l.source._resolution = r,
            l.source.width = n / r,
            l.source.height = a / r,
            l.source.pixelWidth = n,
            l.source.pixelHeight = a,
            l.frame.x = 0,
            l.frame.y = 0,
            l.frame.width = e,
            l.frame.height = t,
            l.updateUvs(),
            this._poolKeyHash[l.uid] = o,
            l
        }
        getSameSizeTexture(e, t=!1) {
            let r = e.source;
            return this.getOptimalTexture(e.width, e.height, r._resolution, t)
        }
        returnTexture(e, t=!1) {
            let r = this._poolKeyHash[e.uid];
            t && (e.source.style = this.textureStyle),
            this._texturePool[r].push(e)
        }
        clear(e) {
            if (e = e !== !1,
            e)
                for (let t in this._texturePool) {
                    let r = this._texturePool[t];
                    if (r)
                        for (let s = 0; s < r.length; s++)
                            r[s].destroy(!0)
                }
            this._texturePool = {}
        }
    }
      , Ke = new kc;
    Pr.register(Ke);
    var ds = class {
        constructor() {
            this.renderPipeId = "renderGroup",
            this.root = null,
            this.canBundle = !1,
            this.renderGroupParent = null,
            this.renderGroupChildren = [],
            this.worldTransform = new ce,
            this.worldColorAlpha = 4294967295,
            this.worldColor = 16777215,
            this.worldAlpha = 1,
            this.childrenToUpdate = Object.create(null),
            this.updateTick = 0,
            this.gcTick = 0,
            this.childrenRenderablesToUpdate = {
                list: [],
                index: 0
            },
            this.structureDidChange = !0,
            this.instructionSet = new mn,
            this._onRenderContainers = [],
            this.textureNeedsUpdate = !0,
            this.isCachedAsTexture = !1,
            this._matrixDirty = 7
        }
        init(e) {
            this.root = e,
            e._onRender && this.addOnRender(e),
            e.didChange = !0;
            let t = e.children;
            for (let r = 0; r < t.length; r++) {
                let s = t[r];
                s._updateFlags = 15,
                this.addChild(s)
            }
        }
        enableCacheAsTexture(e={}) {
            this.textureOptions = e,
            this.isCachedAsTexture = !0,
            this.textureNeedsUpdate = !0
        }
        disableCacheAsTexture() {
            this.isCachedAsTexture = !1,
            this.texture && (Ke.returnTexture(this.texture, !0),
            this.texture = null)
        }
        updateCacheTexture() {
            this.textureNeedsUpdate = !0;
            let e = this._parentCacheAsTextureRenderGroup;
            e && !e.textureNeedsUpdate && e.updateCacheTexture()
        }
        reset() {
            this.renderGroupChildren.length = 0;
            for (let e in this.childrenToUpdate) {
                let t = this.childrenToUpdate[e];
                t.list.fill(null),
                t.index = 0
            }
            this.childrenRenderablesToUpdate.index = 0,
            this.childrenRenderablesToUpdate.list.fill(null),
            this.root = null,
            this.updateTick = 0,
            this.structureDidChange = !0,
            this._onRenderContainers.length = 0,
            this.renderGroupParent = null,
            this.disableCacheAsTexture()
        }
        get localTransform() {
            return this.root.localTransform
        }
        addRenderGroupChild(e) {
            e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e),
            e.renderGroupParent = this,
            this.renderGroupChildren.push(e)
        }
        _removeRenderGroupChild(e) {
            let t = this.renderGroupChildren.indexOf(e);
            t > -1 && this.renderGroupChildren.splice(t, 1),
            e.renderGroupParent = null
        }
        addChild(e) {
            if (this.structureDidChange = !0,
            e.parentRenderGroup = this,
            e.updateTick = -1,
            e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1,
            e.didChange = !0,
            this.onChildUpdate(e),
            e.renderGroup) {
                this.addRenderGroupChild(e.renderGroup);
                return
            }
            e._onRender && this.addOnRender(e);
            let t = e.children;
            for (let r = 0; r < t.length; r++)
                this.addChild(t[r])
        }
        removeChild(e) {
            if (this.structureDidChange = !0,
            e._onRender && (e.renderGroup || this.removeOnRender(e)),
            e.parentRenderGroup = null,
            e.renderGroup) {
                this._removeRenderGroupChild(e.renderGroup);
                return
            }
            let t = e.children;
            for (let r = 0; r < t.length; r++)
                this.removeChild(t[r])
        }
        removeChildren(e) {
            for (let t = 0; t < e.length; t++)
                this.removeChild(e[t])
        }
        onChildUpdate(e) {
            let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
            t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
                index: 0,
                list: []
            }),
            t.list[t.index++] = e
        }
        updateRenderable(e) {
            e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e),
            e.didViewUpdate = !1)
        }
        onChildViewUpdate(e) {
            this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e
        }
        get isRenderable() {
            return this.root.localDisplayStatus === 7 && this.worldAlpha > 0
        }
        addOnRender(e) {
            this._onRenderContainers.push(e)
        }
        removeOnRender(e) {
            this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1)
        }
        runOnRender(e) {
            for (let t = 0; t < this._onRenderContainers.length; t++)
                this._onRenderContainers[t]._onRender(e)
        }
        destroy() {
            this.disableCacheAsTexture(),
            this.renderGroupParent = null,
            this.root = null,
            this.childrenRenderablesToUpdate = null,
            this.childrenToUpdate = null,
            this.renderGroupChildren = null,
            this._onRenderContainers = null,
            this.instructionSet = null
        }
        getChildren(e=[]) {
            let t = this.root.children;
            for (let r = 0; r < t.length; r++)
                this._getChildren(t[r], e);
            return e
        }
        _getChildren(e, t=[]) {
            if (t.push(e),
            e.renderGroup)
                return t;
            let r = e.children;
            for (let s = 0; s < r.length; s++)
                this._getChildren(r[s], t);
            return t
        }
        invalidateMatrices() {
            this._matrixDirty = 7
        }
        get inverseWorldTransform() {
            return this._matrixDirty & 1 ? (this._matrixDirty &= -2,
            this._inverseWorldTransform || (this._inverseWorldTransform = new ce),
            this._inverseWorldTransform.copyFrom(this.worldTransform).invert()) : this._inverseWorldTransform
        }
        get textureOffsetInverseTransform() {
            return this._matrixDirty & 2 ? (this._matrixDirty &= -3,
            this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new ce),
            this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y)) : this._textureOffsetInverseTransform
        }
        get inverseParentTextureTransform() {
            if (!(this._matrixDirty & 4))
                return this._inverseParentTextureTransform;
            this._matrixDirty &= -5;
            let e = this._parentCacheAsTextureRenderGroup;
            return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new ce),
            this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform
        }
        get cacheToLocalTransform() {
            return this.isCachedAsTexture ? this.textureOffsetInverseTransform : this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null
        }
    }
    ;
    function Uc(i, e, t={}) {
        for (let r in e)
            !t[r] && e[r] !== void 0 && (i[r] = e[r])
    }
    var Io = new ze(null)
      , Go = new ze(null)
      , Bo = new ze(null,1,1)
      , Fo = new ze(null)
      , _n = 1
      , Ph = 2
      , is = 4;
    var Te = class i extends Ot {
        constructor(e={}) {
            var t, r;
            super(),
            this.uid = Le("renderable"),
            this._updateFlags = 15,
            this.renderGroup = null,
            this.parentRenderGroup = null,
            this.parentRenderGroupIndex = 0,
            this.didChange = !1,
            this.didViewUpdate = !1,
            this.relativeRenderGroupDepth = 0,
            this.children = [],
            this.parent = null,
            this.includeInBuild = !0,
            this.measurable = !0,
            this.isSimple = !0,
            this.updateTick = -1,
            this.localTransform = new ce,
            this.relativeGroupTransform = new ce,
            this.groupTransform = this.relativeGroupTransform,
            this.destroyed = !1,
            this._position = new ze(this,0,0),
            this._scale = Bo,
            this._pivot = Go,
            this._origin = Fo,
            this._skew = Io,
            this._cx = 1,
            this._sx = 0,
            this._cy = 0,
            this._sy = 1,
            this._rotation = 0,
            this.localColor = 16777215,
            this.localAlpha = 1,
            this.groupAlpha = 1,
            this.groupColor = 16777215,
            this.groupColorAlpha = 4294967295,
            this.localBlendMode = "inherit",
            this.groupBlendMode = "normal",
            this.localDisplayStatus = 7,
            this.globalDisplayStatus = 7,
            this._didContainerChangeTick = 0,
            this._didViewChangeTick = 0,
            this._didLocalTransformChangeId = -1,
            this.effects = [],
            Uc(this, e, {
                children: !0,
                parent: !0,
                effects: !0
            }),
            (t = e.children) == null || t.forEach(s => this.addChild(s)),
            (r = e.parent) == null || r.addChild(this)
        }
        static mixin(e) {
            be.mixin(i, e)
        }
        set _didChangeId(e) {
            this._didViewChangeTick = e >> 12 & 4095,
            this._didContainerChangeTick = e & 4095
        }
        get _didChangeId() {
            return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12
        }
        addChild(...e) {
            if (e.length > 1) {
                for (let s = 0; s < e.length; s++)
                    this.addChild(e[s]);
                return e[0]
            }
            let t = e[0]
              , r = this.renderGroup || this.parentRenderGroup;
            return t.parent === this ? (this.children.splice(this.children.indexOf(t), 1),
            this.children.push(t),
            r && (r.structureDidChange = !0),
            t) : (t.parent && t.parent.removeChild(t),
            this.children.push(t),
            this.sortableChildren && (this.sortDirty = !0),
            t.parent = this,
            t.didChange = !0,
            t._updateFlags = 15,
            r && r.addChild(t),
            this.emit("childAdded", t, this, this.children.length - 1),
            t.emit("added", this),
            this._didViewChangeTick++,
            t._zIndex !== 0 && t.depthOfChildModified(),
            t)
        }
        removeChild(...e) {
            if (e.length > 1) {
                for (let s = 0; s < e.length; s++)
                    this.removeChild(e[s]);
                return e[0]
            }
            let t = e[0]
              , r = this.children.indexOf(t);
            return r > -1 && (this._didViewChangeTick++,
            this.children.splice(r, 1),
            this.renderGroup ? this.renderGroup.removeChild(t) : this.parentRenderGroup && this.parentRenderGroup.removeChild(t),
            t.parentRenderLayer && t.parentRenderLayer.detach(t),
            t.parent = null,
            this.emit("childRemoved", t, this, r),
            t.emit("removed", this)),
            t
        }
        _onUpdate(e) {
            e && e === this._skew && this._updateSkew(),
            this._didContainerChangeTick++,
            !this.didChange && (this.didChange = !0,
            this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this))
        }
        set isRenderGroup(e) {
            !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup())
        }
        get isRenderGroup() {
            return !!this.renderGroup
        }
        enableRenderGroup() {
            if (this.renderGroup)
                return;
            let e = this.parentRenderGroup;
            e?.removeChild(this),
            this.renderGroup = Je.get(ds, this),
            this.groupTransform = ce.IDENTITY,
            e?.addChild(this),
            this._updateIsSimple()
        }
        disableRenderGroup() {
            if (!this.renderGroup)
                return;
            let e = this.parentRenderGroup;
            e?.removeChild(this),
            Je.return(this.renderGroup),
            this.renderGroup = null,
            this.groupTransform = this.relativeGroupTransform,
            e?.addChild(this),
            this._updateIsSimple()
        }
        _updateIsSimple() {
            this.isSimple = !this.renderGroup && this.effects.length === 0
        }
        get worldTransform() {
            return this._worldTransform || (this._worldTransform = new ce),
            this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform),
            this._worldTransform
        }
        get x() {
            return this._position.x
        }
        set x(e) {
            this._position.x = e
        }
        get y() {
            return this._position.y
        }
        set y(e) {
            this._position.y = e
        }
        get position() {
            return this._position
        }
        set position(e) {
            this._position.copyFrom(e)
        }
        get rotation() {
            return this._rotation
        }
        set rotation(e) {
            this._rotation !== e && (this._rotation = e,
            this._onUpdate(this._skew))
        }
        get angle() {
            return this.rotation * C1
        }
        set angle(e) {
            this.rotation = e * O1
        }
        get pivot() {
            return this._pivot === Go && (this._pivot = new ze(this,0,0)),
            this._pivot
        }
        set pivot(e) {
            this._pivot === Go && (this._pivot = new ze(this,0,0)),
            typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e)
        }
        get skew() {
            return this._skew === Io && (this._skew = new ze(this,0,0)),
            this._skew
        }
        set skew(e) {
            this._skew === Io && (this._skew = new ze(this,0,0)),
            this._skew.copyFrom(e)
        }
        get scale() {
            return this._scale === Bo && (this._scale = new ze(this,1,1)),
            this._scale
        }
        set scale(e) {
            this._scale === Bo && (this._scale = new ze(this,0,0)),
            typeof e == "string" && (e = parseFloat(e)),
            typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e)
        }
        get origin() {
            return this._origin === Fo && (this._origin = new ze(this,0,0)),
            this._origin
        }
        set origin(e) {
            this._origin === Fo && (this._origin = new ze(this,0,0)),
            typeof e == "number" ? this._origin.set(e) : this._origin.copyFrom(e)
        }
        get width() {
            return Math.abs(this.scale.x * this.getLocalBounds().width)
        }
        set width(e) {
            let t = this.getLocalBounds().width;
            this._setWidth(e, t)
        }
        get height() {
            return Math.abs(this.scale.y * this.getLocalBounds().height)
        }
        set height(e) {
            let t = this.getLocalBounds().height;
            this._setHeight(e, t)
        }
        getSize(e) {
            e || (e = {});
            let t = this.getLocalBounds();
            return e.width = Math.abs(this.scale.x * t.width),
            e.height = Math.abs(this.scale.y * t.height),
            e
        }
        setSize(e, t) {
            var r;
            let s = this.getLocalBounds();
            typeof e == "object" ? (t = (r = e.height) != null ? r : e.width,
            e = e.width) : t != null || (t = e),
            e !== void 0 && this._setWidth(e, s.width),
            t !== void 0 && this._setHeight(t, s.height)
        }
        _updateSkew() {
            let e = this._rotation
              , t = this._skew;
            this._cx = Math.cos(e + t._y),
            this._sx = Math.sin(e + t._y),
            this._cy = -Math.sin(e - t._x),
            this._sy = Math.cos(e - t._x)
        }
        updateTransform(e) {
            return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y),
            this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y),
            this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation,
            this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y),
            this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y),
            this.origin.set(typeof e.originX == "number" ? e.originX : this.origin.x, typeof e.originY == "number" ? e.originY : this.origin.y),
            this
        }
        setFromMatrix(e) {
            e.decompose(this)
        }
        updateLocalTransform() {
            let e = this._didContainerChangeTick;
            if (this._didLocalTransformChangeId === e)
                return;
            this._didLocalTransformChangeId = e;
            let t = this.localTransform
              , r = this._scale
              , s = this._pivot
              , n = this._origin
              , a = this._position
              , o = r._x
              , l = r._y
              , u = s._x
              , d = s._y
              , f = -n._x
              , b = -n._y;
            t.a = this._cx * o,
            t.b = this._sx * o,
            t.c = this._cy * l,
            t.d = this._sy * l,
            t.tx = a._x - (u * t.a + d * t.c) + (f * t.a + b * t.c) - f,
            t.ty = a._y - (u * t.b + d * t.d) + (f * t.b + b * t.d) - b
        }
        set alpha(e) {
            e !== this.localAlpha && (this.localAlpha = e,
            this._updateFlags |= _n,
            this._onUpdate())
        }
        get alpha() {
            return this.localAlpha
        }
        set tint(e) {
            let t = Be.shared.setValue(e ?? 16777215).toBgrNumber();
            t !== this.localColor && (this.localColor = t,
            this._updateFlags |= _n,
            this._onUpdate())
        }
        get tint() {
            return ts(this.localColor)
        }
        set blendMode(e) {
            this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._updateFlags |= Ph,
            this.localBlendMode = e,
            this._onUpdate())
        }
        get blendMode() {
            return this.localBlendMode
        }
        get visible() {
            return !!(this.localDisplayStatus & 2)
        }
        set visible(e) {
            let t = e ? 2 : 0;
            (this.localDisplayStatus & 2) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._updateFlags |= is,
            this.localDisplayStatus ^= 2,
            this._onUpdate())
        }
        get culled() {
            return !(this.localDisplayStatus & 4)
        }
        set culled(e) {
            let t = e ? 0 : 4;
            (this.localDisplayStatus & 4) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._updateFlags |= is,
            this.localDisplayStatus ^= 4,
            this._onUpdate())
        }
        get renderable() {
            return !!(this.localDisplayStatus & 1)
        }
        set renderable(e) {
            let t = e ? 1 : 0;
            (this.localDisplayStatus & 1) !== t && (this._updateFlags |= is,
            this.localDisplayStatus ^= 1,
            this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._onUpdate())
        }
        get isRenderable() {
            return this.localDisplayStatus === 7 && this.groupAlpha > 0
        }
        destroy(e=!1) {
            var t;
            if (this.destroyed)
                return;
            this.destroyed = !0;
            let r;
            if (this.children.length && (r = this.removeChildren(0, this.children.length)),
            this.removeFromParent(),
            this.parent = null,
            this._maskEffect = null,
            this._filterEffect = null,
            this.effects = null,
            this._position = null,
            this._scale = null,
            this._pivot = null,
            this._origin = null,
            this._skew = null,
            this.emit("destroyed", this),
            this.removeAllListeners(),
            (typeof e == "boolean" ? e : e?.children) && r)
                for (let s = 0; s < r.length; ++s)
                    r[s].destroy(e);
            (t = this.renderGroup) == null || t.destroy(),
            this.renderGroup = null
        }
    }
    ;
    be.mixin(Te, F1, H1, q1, Y1, W1, N1, X1, $1, R1, B1, z1, D1);
    var fi = (i => (i[i.INTERACTION = 50] = "INTERACTION",
    i[i.HIGH = 25] = "HIGH",
    i[i.NORMAL = 0] = "NORMAL",
    i[i.LOW = -25] = "LOW",
    i[i.UTILITY = -50] = "UTILITY",
    i))(fi || {})
      , rs = class {
        constructor(e, t=null, r=0, s=!1) {
            this.next = null,
            this.previous = null,
            this._destroyed = !1,
            this._fn = e,
            this._context = t,
            this.priority = r,
            this._once = s
        }
        match(e, t=null) {
            return this._fn === e && this._context === t
        }
        emit(e) {
            this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
            let t = this.next;
            return this._once && this.destroy(!0),
            this._destroyed && (this.next = null),
            t
        }
        connect(e) {
            this.previous = e,
            e.next && (e.next.previous = this),
            this.next = e.next,
            e.next = this
        }
        destroy(e=!1) {
            this._destroyed = !0,
            this._fn = null,
            this._context = null,
            this.previous && (this.previous.next = this.next),
            this.next && (this.next.previous = this.previous);
            let t = this.next;
            return this.next = e ? null : t,
            this.previous = null,
            t
        }
    }
      , tb = class St {
        constructor() {
            this.autoStart = !1,
            this.deltaTime = 1,
            this.lastTime = -1,
            this.speed = 1,
            this.started = !1,
            this._requestId = null,
            this._maxElapsedMS = 100,
            this._minElapsedMS = 0,
            this._protected = !1,
            this._lastFrame = -1,
            this._head = new rs(null,null,1 / 0),
            this.deltaMS = 1 / St.targetFPMS,
            this.elapsedMS = 1 / St.targetFPMS,
            this._tick = e => {
                this._requestId = null,
                this.started && (this.update(e),
                this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
            }
        }
        _requestIfNeeded() {
            this._requestId === null && this._head.next && (this.lastTime = performance.now(),
            this._lastFrame = this.lastTime,
            this._requestId = requestAnimationFrame(this._tick))
        }
        _cancelIfNeeded() {
            this._requestId !== null && (cancelAnimationFrame(this._requestId),
            this._requestId = null)
        }
        _startIfPossible() {
            this.started ? this._requestIfNeeded() : this.autoStart && this.start()
        }
        add(e, t, r=fi.NORMAL) {
            return this._addListener(new rs(e,t,r))
        }
        addOnce(e, t, r=fi.NORMAL) {
            return this._addListener(new rs(e,t,r,!0))
        }
        _addListener(e) {
            let t = this._head.next
              , r = this._head;
            if (!t)
                e.connect(r);
            else {
                for (; t; ) {
                    if (e.priority > t.priority) {
                        e.connect(r);
                        break
                    }
                    r = t,
                    t = t.next
                }
                e.previous || e.connect(r)
            }
            return this._startIfPossible(),
            this
        }
        remove(e, t) {
            let r = this._head.next;
            for (; r; )
                r.match(e, t) ? r = r.destroy() : r = r.next;
            return this._head.next || this._cancelIfNeeded(),
            this
        }
        get count() {
            if (!this._head)
                return 0;
            let e = 0
              , t = this._head;
            for (; t = t.next; )
                e++;
            return e
        }
        start() {
            this.started || (this.started = !0,
            this._requestIfNeeded())
        }
        stop() {
            this.started && (this.started = !1,
            this._cancelIfNeeded())
        }
        destroy() {
            if (!this._protected) {
                this.stop();
                let e = this._head.next;
                for (; e; )
                    e = e.destroy(!0);
                this._head.destroy(),
                this._head = null
            }
        }
        update(e=performance.now()) {
            let t;
            if (e > this.lastTime) {
                if (t = this.elapsedMS = e - this.lastTime,
                t > this._maxElapsedMS && (t = this._maxElapsedMS),
                t *= this.speed,
                this._minElapsedMS) {
                    let n = e - this._lastFrame | 0;
                    if (n < this._minElapsedMS)
                        return;
                    this._lastFrame = e - n % this._minElapsedMS
                }
                this.deltaMS = t,
                this.deltaTime = this.deltaMS * St.targetFPMS;
                let r = this._head
                  , s = r.next;
                for (; s; )
                    s = s.emit(this);
                r.next || this._cancelIfNeeded()
            } else
                this.deltaTime = this.deltaMS = this.elapsedMS = 0;
            this.lastTime = e
        }
        get FPS() {
            return 1e3 / this.elapsedMS
        }
        get minFPS() {
            return 1e3 / this._maxElapsedMS
        }
        set minFPS(e) {
            let t = Math.min(this.maxFPS, e)
              , r = Math.min(Math.max(0, t) / 1e3, St.targetFPMS);
            this._maxElapsedMS = 1 / r
        }
        get maxFPS() {
            return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
        }
        set maxFPS(e) {
            if (e === 0)
                this._minElapsedMS = 0;
            else {
                let t = Math.max(this.minFPS, e);
                this._minElapsedMS = 1 / (t / 1e3)
            }
        }
        static get shared() {
            if (!St._shared) {
                let e = St._shared = new St;
                e.autoStart = !0,
                e._protected = !0
            }
            return St._shared
        }
        static get system() {
            if (!St._system) {
                let e = St._system = new St;
                e.autoStart = !0,
                e._protected = !0
            }
            return St._system
        }
    }
    ;
    tb.targetFPMS = .06;
    var nt = tb
      , xn = class {
        constructor(e) {
            this._lastTransform = "",
            this._observer = null,
            this._tickerAttached = !1,
            this.updateTranslation = () => {
                if (!this._canvas)
                    return;
                let t = this._canvas.getBoundingClientRect()
                  , r = this._canvas.width
                  , s = this._canvas.height
                  , n = t.width / r * this._renderer.resolution
                  , a = t.height / s * this._renderer.resolution
                  , o = t.left
                  , l = t.top
                  , u = `translate(${o}px, ${l}px) scale(${n}, ${a})`;
                u !== this._lastTransform && (this._domElement.style.transform = u,
                this._lastTransform = u)
            }
            ,
            this._domElement = e.domElement,
            this._renderer = e.renderer,
            !(globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas) && (this._canvas = this._renderer.canvas,
            this._attachObserver())
        }
        get canvas() {
            return this._canvas
        }
        ensureAttached() {
            !this._domElement.parentNode && this._canvas.parentNode && (this._canvas.parentNode.appendChild(this._domElement),
            this.updateTranslation())
        }
        _attachObserver() {
            "ResizeObserver"in globalThis ? (this._observer && (this._observer.disconnect(),
            this._observer = null),
            this._observer = new ResizeObserver(e => {
                for (let t of e) {
                    if (t.target !== this._canvas)
                        continue;
                    let r = this.canvas.width
                      , s = this.canvas.height
                      , n = t.contentRect.width / r * this._renderer.resolution
                      , a = t.contentRect.height / s * this._renderer.resolution;
                    (this._lastScaleX !== n || this._lastScaleY !== a) && (this.updateTranslation(),
                    this._lastScaleX = n,
                    this._lastScaleY = a)
                }
            }
            ),
            this._observer.observe(this._canvas)) : this._tickerAttached || nt.shared.add(this.updateTranslation, this, fi.HIGH)
        }
        destroy() {
            this._observer ? (this._observer.disconnect(),
            this._observer = null) : this._tickerAttached && nt.shared.remove(this.updateTranslation),
            this._domElement = null,
            this._renderer = null,
            this._canvas = null,
            this._tickerAttached = !1,
            this._lastTransform = "",
            this._lastScaleX = null,
            this._lastScaleY = null
        }
    }
      , fs = class i {
        constructor(e) {
            this.bubbles = !0,
            this.cancelBubble = !0,
            this.cancelable = !1,
            this.composed = !1,
            this.defaultPrevented = !1,
            this.eventPhase = i.prototype.NONE,
            this.propagationStopped = !1,
            this.propagationImmediatelyStopped = !1,
            this.layer = new Ue,
            this.page = new Ue,
            this.NONE = 0,
            this.CAPTURING_PHASE = 1,
            this.AT_TARGET = 2,
            this.BUBBLING_PHASE = 3,
            this.manager = e
        }
        get layerX() {
            return this.layer.x
        }
        get layerY() {
            return this.layer.y
        }
        get pageX() {
            return this.page.x
        }
        get pageY() {
            return this.page.y
        }
        get data() {
            return this
        }
        composedPath() {
            return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []),
            this.path
        }
        initEvent(e, t, r) {
            throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
        }
        initUIEvent(e, t, r, s, n) {
            throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
        }
        preventDefault() {
            this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
            this.defaultPrevented = !0
        }
        stopImmediatePropagation() {
            this.propagationImmediatelyStopped = !0
        }
        stopPropagation() {
            this.propagationStopped = !0
        }
    }
      , Do = /iPhone/i
      , Eu = /iPod/i
      , Pu = /iPad/i
      , Ru = /\biOS-universal(?:.+)Mac\b/i
      , ko = /\bAndroid(?:.+)Mobile\b/i
      , Mu = /Android/i
      , sr = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
      , Hs = /Silk/i
      , ci = /Windows Phone/i
      , Cu = /\bWindows(?:.+)ARM\b/i
      , Ou = /BlackBerry/i
      , Iu = /BB10/i
      , Gu = /Opera Mini/i
      , Bu = /\b(CriOS|Chrome)(?:.+)Mobile/i
      , Fu = /Mobile(?:.+)Firefox\b/i
      , Du = function(i) {
        return typeof i < "u" && i.platform === "MacIntel" && typeof i.maxTouchPoints == "number" && i.maxTouchPoints > 1 && typeof MSStream > "u"
    };
    function y_(i) {
        return function(e) {
            return e.test(i)
        }
    }
    function ku(i) {
        var e = {
            userAgent: "",
            platform: "",
            maxTouchPoints: 0
        };
        !i && typeof navigator < "u" ? e = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        } : typeof i == "string" ? e.userAgent = i : i && i.userAgent && (e = {
            userAgent: i.userAgent,
            platform: i.platform,
            maxTouchPoints: i.maxTouchPoints || 0
        });
        var t = e.userAgent
          , r = t.split("[FBAN");
        typeof r[1] < "u" && (t = r[0]),
        r = t.split("Twitter"),
        typeof r[1] < "u" && (t = r[0]);
        var s = y_(t)
          , n = {
            apple: {
                phone: s(Do) && !s(ci),
                ipod: s(Eu),
                tablet: !s(Do) && (s(Pu) || Du(e)) && !s(ci),
                universal: s(Ru),
                device: (s(Do) || s(Eu) || s(Pu) || s(Ru) || Du(e)) && !s(ci)
            },
            amazon: {
                phone: s(sr),
                tablet: !s(sr) && s(Hs),
                device: s(sr) || s(Hs)
            },
            android: {
                phone: !s(ci) && s(sr) || !s(ci) && s(ko),
                tablet: !s(ci) && !s(sr) && !s(ko) && (s(Hs) || s(Mu)),
                device: !s(ci) && (s(sr) || s(Hs) || s(ko) || s(Mu)) || s(/\bokhttp\b/i)
            },
            windows: {
                phone: s(ci),
                tablet: s(Cu),
                device: s(ci) || s(Cu)
            },
            other: {
                blackberry: s(Ou),
                blackberry10: s(Iu),
                opera: s(Gu),
                firefox: s(Fu),
                chrome: s(Bu),
                device: s(Ou) || s(Iu) || s(Gu) || s(Fu) || s(Bu)
            },
            any: !1,
            phone: !1,
            tablet: !1
        };
        return n.any = n.apple.device || n.android.device || n.windows.device || n.other.device,
        n.phone = n.apple.phone || n.android.phone || n.windows.phone,
        n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet,
        n
    }
    var Uu, v_ = (Uu = ku.default) != null ? Uu : ku, Nt = v_(globalThis.navigator), T_ = Object.defineProperty, Lu = Object.getOwnPropertySymbols, S_ = Object.prototype.hasOwnProperty, w_ = Object.prototype.propertyIsEnumerable, Nu = (i, e, t) => e in i ? T_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, Xu = (i, e) => {
        for (var t in e || (e = {}))
            S_.call(e, t) && Nu(i, t, e[t]);
        if (Lu)
            for (var t of Lu(e))
                w_.call(e, t) && Nu(i, t, e[t]);
        return i
    }
    , A_ = 9, ju = 100, E_ = 0, P_ = 0, Hu = 2, zu = 1, R_ = -1e3, M_ = -1e3, C_ = 2, Lc = class ib {
        constructor(e, t=Nt) {
            this._mobileInfo = t,
            this.debug = !1,
            this._activateOnTab = !0,
            this._deactivateOnMouseMove = !0,
            this._isActive = !1,
            this._isMobileAccessibility = !1,
            this._div = null,
            this._pool = [],
            this._renderId = 0,
            this._children = [],
            this._androidUpdateCount = 0,
            this._androidUpdateFrequency = 500,
            this._hookDiv = null,
            (t.tablet || t.phone) && this._createTouchHook(),
            this._renderer = e
        }
        get isActive() {
            return this._isActive
        }
        get isMobileAccessibility() {
            return this._isMobileAccessibility
        }
        get hookDiv() {
            return this._hookDiv
        }
        _createTouchHook() {
            let e = document.createElement("button");
            e.style.width = `${zu}px`,
            e.style.height = `${zu}px`,
            e.style.position = "absolute",
            e.style.top = `${R_}px`,
            e.style.left = `${M_}px`,
            e.style.zIndex = C_.toString(),
            e.style.backgroundColor = "#FF0000",
            e.title = "select to enable accessibility for this content",
            e.addEventListener("focus", () => {
                this._isMobileAccessibility = !0,
                this._activate(),
                this._destroyTouchHook()
            }
            ),
            document.body.appendChild(e),
            this._hookDiv = e
        }
        _destroyTouchHook() {
            this._hookDiv && (document.body.removeChild(this._hookDiv),
            this._hookDiv = null)
        }
        _activate() {
            if (this._isActive)
                return;
            this._isActive = !0,
            this._div || (this._div = document.createElement("div"),
            this._div.style.position = "absolute",
            this._div.style.top = `${E_}px`,
            this._div.style.left = `${P_}px`,
            this._div.style.pointerEvents = "none",
            this._div.style.zIndex = Hu.toString(),
            this._canvasObserver = new xn({
                domElement: this._div,
                renderer: this._renderer
            })),
            this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this),
            globalThis.addEventListener("keydown", this._onKeyDown, !1)),
            this._deactivateOnMouseMove && (this._onMouseMove = this._onMouseMove.bind(this),
            globalThis.document.addEventListener("mousemove", this._onMouseMove, !0));
            let e = this._renderer.view.canvas;
            if (e.parentNode)
                this._canvasObserver.ensureAttached(),
                this._initAccessibilitySetup();
            else {
                let t = new MutationObserver( () => {
                    e.parentNode && (t.disconnect(),
                    this._canvasObserver.ensureAttached(),
                    this._initAccessibilitySetup())
                }
                );
                t.observe(document.body, {
                    childList: !0,
                    subtree: !0
                })
            }
        }
        _initAccessibilitySetup() {
            this._renderer.runners.postrender.add(this),
            this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered)
        }
        _deactivate() {
            if (!(!this._isActive || this._isMobileAccessibility)) {
                this._isActive = !1,
                globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
                this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, !1),
                this._renderer.runners.postrender.remove(this);
                for (let e of this._children)
                    e._accessibleDiv && e._accessibleDiv.parentNode && (e._accessibleDiv.parentNode.removeChild(e._accessibleDiv),
                    e._accessibleDiv = null),
                    e._accessibleActive = !1;
                this._pool.forEach(e => {
                    e.parentNode && e.parentNode.removeChild(e)
                }
                ),
                this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div),
                this._pool = [],
                this._children = []
            }
        }
        _updateAccessibleObjects(e) {
            if (!e.visible || !e.accessibleChildren)
                return;
            e.accessible && (e._accessibleActive || this._addChild(e),
            e._renderId = this._renderId);
            let t = e.children;
            if (t)
                for (let r = 0; r < t.length; r++)
                    this._updateAccessibleObjects(t[r])
        }
        init(e) {
            let t = ib.defaultOptions
              , r = {
                accessibilityOptions: Xu(Xu({}, t), e?.accessibilityOptions || {})
            };
            this.debug = r.accessibilityOptions.debug,
            this._activateOnTab = r.accessibilityOptions.activateOnTab,
            this._deactivateOnMouseMove = r.accessibilityOptions.deactivateOnMouseMove,
            r.accessibilityOptions.enabledByDefault ? this._activate() : this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this),
            globalThis.addEventListener("keydown", this._onKeyDown, !1)),
            this._renderer.runners.postrender.remove(this)
        }
        postrender() {
            let e = performance.now();
            if (this._mobileInfo.android.device && e < this._androidUpdateCount || (this._androidUpdateCount = e + this._androidUpdateFrequency,
            !this._renderer.renderingToScreen || !this._renderer.view.canvas))
                return;
            let t = new Set;
            if (this._renderer.lastObjectRendered) {
                this._updateAccessibleObjects(this._renderer.lastObjectRendered);
                for (let r of this._children)
                    r._renderId === this._renderId && t.add(this._children.indexOf(r))
            }
            for (let r = this._children.length - 1; r >= 0; r--) {
                let s = this._children[r];
                t.has(r) || (s._accessibleDiv && s._accessibleDiv.parentNode && (s._accessibleDiv.parentNode.removeChild(s._accessibleDiv),
                this._pool.push(s._accessibleDiv),
                s._accessibleDiv = null),
                s._accessibleActive = !1,
                V0(this._children, r, 1))
            }
            this._renderer.renderingToScreen && this._canvasObserver.ensureAttached();
            for (let r = 0; r < this._children.length; r++) {
                let s = this._children[r];
                if (!s._accessibleActive || !s._accessibleDiv)
                    continue;
                let n = s._accessibleDiv
                  , a = s.hitArea || s.getBounds().rectangle;
                if (s.hitArea) {
                    let o = s.worldTransform;
                    n.style.left = `${o.tx + a.x * o.a}px`,
                    n.style.top = `${o.ty + a.y * o.d}px`,
                    n.style.width = `${a.width * o.a}px`,
                    n.style.height = `${a.height * o.d}px`
                } else
                    this._capHitArea(a),
                    n.style.left = `${a.x}px`,
                    n.style.top = `${a.y}px`,
                    n.style.width = `${a.width}px`,
                    n.style.height = `${a.height}px`
            }
            this._renderId++
        }
        _updateDebugHTML(e) {
            e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`
        }
        _capHitArea(e) {
            e.x < 0 && (e.width += e.x,
            e.x = 0),
            e.y < 0 && (e.height += e.y,
            e.y = 0);
            let {width: t, height: r} = this._renderer;
            e.x + e.width > t && (e.width = t - e.x),
            e.y + e.height > r && (e.height = r - e.y)
        }
        _addChild(e) {
            let t = this._pool.pop();
            t || (e.accessibleType === "button" ? t = document.createElement("button") : (t = document.createElement(e.accessibleType),
            t.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `,
            e.accessibleText && (t.innerText = e.accessibleText)),
            t.style.width = `${ju}px`,
            t.style.height = `${ju}px`,
            t.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent",
            t.style.position = "absolute",
            t.style.zIndex = Hu.toString(),
            t.style.borderStyle = "none",
            navigator.userAgent.toLowerCase().includes("chrome") ? t.setAttribute("aria-live", "off") : t.setAttribute("aria-live", "polite"),
            navigator.userAgent.match(/rv:.*Gecko\//) ? t.setAttribute("aria-relevant", "additions") : t.setAttribute("aria-relevant", "text"),
            t.addEventListener("click", this._onClick.bind(this)),
            t.addEventListener("focus", this._onFocus.bind(this)),
            t.addEventListener("focusout", this._onFocusOut.bind(this))),
            t.style.pointerEvents = e.accessiblePointerEvents,
            t.type = e.accessibleType,
            e.accessibleTitle && e.accessibleTitle !== null ? t.title = e.accessibleTitle : (!e.accessibleHint || e.accessibleHint === null) && (t.title = `container ${e.tabIndex}`),
            e.accessibleHint && e.accessibleHint !== null && t.setAttribute("aria-label", e.accessibleHint),
            e.interactive ? t.tabIndex = e.tabIndex : t.tabIndex = 0,
            this.debug && this._updateDebugHTML(t),
            e._accessibleActive = !0,
            e._accessibleDiv = t,
            t.container = e,
            this._children.push(e),
            this._div.appendChild(e._accessibleDiv)
        }
        _dispatchEvent(e, t) {
            let {container: r} = e.target
              , s = this._renderer.events.rootBoundary
              , n = Object.assign(new fs(s), {
                target: r
            });
            s.rootTarget = this._renderer.lastObjectRendered,
            t.forEach(a => s.dispatchEvent(n, a))
        }
        _onClick(e) {
            this._dispatchEvent(e, ["click", "pointertap", "tap"])
        }
        _onFocus(e) {
            e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"),
            this._dispatchEvent(e, ["mouseover"])
        }
        _onFocusOut(e) {
            e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"),
            this._dispatchEvent(e, ["mouseout"])
        }
        _onKeyDown(e) {
            e.keyCode !== A_ || !this._activateOnTab || this._activate()
        }
        _onMouseMove(e) {
            e.movementX === 0 && e.movementY === 0 || this._deactivate()
        }
        destroy() {
            var e;
            this._deactivate(),
            this._destroyTouchHook(),
            (e = this._canvasObserver) == null || e.destroy(),
            this._canvasObserver = null,
            this._div = null,
            this._pool = null,
            this._children = null,
            this._renderer = null,
            this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown)
        }
        setAccessibilityEnabled(e) {
            e ? this._activate() : this._deactivate()
        }
    }
    ;
    Lc.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem],
        name: "accessibility"
    },
    Lc.defaultOptions = {
        enabledByDefault: !1,
        debug: !1,
        activateOnTab: !0,
        deactivateOnMouseMove: !0
    };
    var O_ = Lc
      , I_ = {
        accessible: !1,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        accessibleType: "button",
        accessibleText: null,
        accessiblePointerEvents: "auto",
        accessibleChildren: !0,
        _accessibleActive: !1,
        _accessibleDiv: null,
        _renderId: -1
    };
    be.add(O_),
    be.mixin(Te, I_);
    var yn = class {
        static init(e) {
            Object.defineProperty(this, "resizeTo", {
                set(t) {
                    globalThis.removeEventListener("resize", this.queueResize),
                    this._resizeTo = t,
                    t && (globalThis.addEventListener("resize", this.queueResize),
                    this.resize())
                },
                get() {
                    return this._resizeTo
                }
            }),
            this.queueResize = () => {
                this._resizeTo && (this._cancelResize(),
                this._resizeId = requestAnimationFrame( () => this.resize()))
            }
            ,
            this._cancelResize = () => {
                this._resizeId && (cancelAnimationFrame(this._resizeId),
                this._resizeId = null)
            }
            ,
            this.resize = () => {
                if (!this._resizeTo)
                    return;
                this._cancelResize();
                let t, r;
                if (this._resizeTo === globalThis.window)
                    t = globalThis.innerWidth,
                    r = globalThis.innerHeight;
                else {
                    let {clientWidth: s, clientHeight: n} = this._resizeTo;
                    t = s,
                    r = n
                }
                this.renderer.resize(t, r),
                this.render()
            }
            ,
            this._resizeId = null,
            this._resizeTo = null,
            this.resizeTo = e.resizeTo || null
        }
        static destroy() {
            globalThis.removeEventListener("resize", this.queueResize),
            this._cancelResize(),
            this._cancelResize = null,
            this.queueResize = null,
            this.resizeTo = null,
            this.resize = null
        }
    }
    ;
    yn.extension = O.Application;
    var vn = class {
        static init(e) {
            e = Object.assign({
                autoStart: !0,
                sharedTicker: !1
            }, e),
            Object.defineProperty(this, "ticker", {
                set(t) {
                    this._ticker && this._ticker.remove(this.render, this),
                    this._ticker = t,
                    t && t.add(this.render, this, fi.LOW)
                },
                get() {
                    return this._ticker
                }
            }),
            this.stop = () => {
                this._ticker.stop()
            }
            ,
            this.start = () => {
                this._ticker.start()
            }
            ,
            this._ticker = null,
            this.ticker = e.sharedTicker ? nt.shared : new nt,
            e.autoStart && this.start()
        }
        static destroy() {
            if (this._ticker) {
                let e = this._ticker;
                this.ticker = null,
                e.destroy()
            }
        }
    }
    ;
    vn.extension = O.Application,
    be.add(yn),
    be.add(vn);
    var G_ = class {
        constructor() {
            this.interactionFrequency = 10,
            this._deltaTime = 0,
            this._didMove = !1,
            this._tickerAdded = !1,
            this._pauseUpdate = !0
        }
        init(i) {
            this.removeTickerListener(),
            this.events = i,
            this.interactionFrequency = 10,
            this._deltaTime = 0,
            this._didMove = !1,
            this._tickerAdded = !1,
            this._pauseUpdate = !0
        }
        get pauseUpdate() {
            return this._pauseUpdate
        }
        set pauseUpdate(i) {
            this._pauseUpdate = i
        }
        addTickerListener() {
            this._tickerAdded || !this.domElement || (nt.system.add(this._tickerUpdate, this, fi.INTERACTION),
            this._tickerAdded = !0)
        }
        removeTickerListener() {
            this._tickerAdded && (nt.system.remove(this._tickerUpdate, this),
            this._tickerAdded = !1)
        }
        pointerMoved() {
            this._didMove = !0
        }
        _update() {
            if (!this.domElement || this._pauseUpdate)
                return;
            if (this._didMove) {
                this._didMove = !1;
                return
            }
            let i = this.events._rootPointerEvent;
            this.events.supportsTouchEvents && i.pointerType === "touch" || globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove",{
                clientX: i.clientX,
                clientY: i.clientY,
                pointerType: i.pointerType,
                pointerId: i.pointerId
            }) : new MouseEvent("mousemove",{
                clientX: i.clientX,
                clientY: i.clientY
            }))
        }
        _tickerUpdate(i) {
            this._deltaTime += i.deltaTime,
            !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0,
            this._update())
        }
        destroy() {
            this.removeTickerListener(),
            this.events = null,
            this.domElement = null,
            this._deltaTime = 0,
            this._didMove = !1,
            this._tickerAdded = !1,
            this._pauseUpdate = !0
        }
    }
      , li = new G_
      , Tr = class extends fs {
        constructor() {
            super(...arguments),
            this.client = new Ue,
            this.movement = new Ue,
            this.offset = new Ue,
            this.global = new Ue,
            this.screen = new Ue
        }
        get clientX() {
            return this.client.x
        }
        get clientY() {
            return this.client.y
        }
        get x() {
            return this.clientX
        }
        get y() {
            return this.clientY
        }
        get movementX() {
            return this.movement.x
        }
        get movementY() {
            return this.movement.y
        }
        get offsetX() {
            return this.offset.x
        }
        get offsetY() {
            return this.offset.y
        }
        get globalX() {
            return this.global.x
        }
        get globalY() {
            return this.global.y
        }
        get screenX() {
            return this.screen.x
        }
        get screenY() {
            return this.screen.y
        }
        getLocalPosition(e, t, r) {
            return e.worldTransform.applyInverse(r || this.global, t)
        }
        getModifierState(e) {
            return "getModifierState"in this.nativeEvent && this.nativeEvent.getModifierState(e)
        }
        initMouseEvent(e, t, r, s, n, a, o, l, u, d, f, b, m, x, v) {
            throw new Error("Method not implemented.")
        }
    }
      , Pt = class extends Tr {
        constructor() {
            super(...arguments),
            this.width = 0,
            this.height = 0,
            this.isPrimary = !1
        }
        getCoalescedEvents() {
            return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
        }
        getPredictedEvents() {
            throw new Error("getPredictedEvents is not supported!")
        }
    }
      , Ri = class extends Tr {
        constructor() {
            super(...arguments),
            this.DOM_DELTA_PIXEL = 0,
            this.DOM_DELTA_LINE = 1,
            this.DOM_DELTA_PAGE = 2
        }
    }
    ;
    Ri.DOM_DELTA_PIXEL = 0,
    Ri.DOM_DELTA_LINE = 1,
    Ri.DOM_DELTA_PAGE = 2;
    var B_ = 2048
      , F_ = new Ue
      , Fr = new Ue
      , Nc = class {
        constructor(e) {
            this.dispatch = new Ot,
            this.moveOnAll = !1,
            this.enableGlobalMoveEvents = !0,
            this.mappingState = {
                trackingData: {}
            },
            this.eventPool = new Map,
            this._allInteractiveElements = [],
            this._hitElements = [],
            this._isPointerMoveEvent = !1,
            this.rootTarget = e,
            this.hitPruneFn = this.hitPruneFn.bind(this),
            this.hitTestFn = this.hitTestFn.bind(this),
            this.mapPointerDown = this.mapPointerDown.bind(this),
            this.mapPointerMove = this.mapPointerMove.bind(this),
            this.mapPointerOut = this.mapPointerOut.bind(this),
            this.mapPointerOver = this.mapPointerOver.bind(this),
            this.mapPointerUp = this.mapPointerUp.bind(this),
            this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this),
            this.mapWheel = this.mapWheel.bind(this),
            this.mappingTable = {},
            this.addEventMapping("pointerdown", this.mapPointerDown),
            this.addEventMapping("pointermove", this.mapPointerMove),
            this.addEventMapping("pointerout", this.mapPointerOut),
            this.addEventMapping("pointerleave", this.mapPointerOut),
            this.addEventMapping("pointerover", this.mapPointerOver),
            this.addEventMapping("pointerup", this.mapPointerUp),
            this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
            this.addEventMapping("wheel", this.mapWheel)
        }
        addEventMapping(e, t) {
            this.mappingTable[e] || (this.mappingTable[e] = []),
            this.mappingTable[e].push({
                fn: t,
                priority: 0
            }),
            this.mappingTable[e].sort( (r, s) => r.priority - s.priority)
        }
        dispatchEvent(e, t) {
            e.propagationStopped = !1,
            e.propagationImmediatelyStopped = !1,
            this.propagate(e, t),
            this.dispatch.emit(t || e.type, e)
        }
        mapEvent(e) {
            if (!this.rootTarget)
                return;
            let t = this.mappingTable[e.type];
            if (t)
                for (let r = 0, s = t.length; r < s; r++)
                    t[r].fn(e)
        }
        hitTest(e, t) {
            li.pauseUpdate = !0;
            let r = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"
              , s = this[r](this.rootTarget, this.rootTarget.eventMode, F_.set(e, t), this.hitTestFn, this.hitPruneFn);
            return s && s[0]
        }
        propagate(e, t) {
            if (!e.target)
                return;
            let r = e.composedPath();
            e.eventPhase = e.CAPTURING_PHASE;
            for (let s = 0, n = r.length - 1; s < n; s++)
                if (e.currentTarget = r[s],
                this.notifyTarget(e, t),
                e.propagationStopped || e.propagationImmediatelyStopped)
                    return;
            if (e.eventPhase = e.AT_TARGET,
            e.currentTarget = e.target,
            this.notifyTarget(e, t),
            !(e.propagationStopped || e.propagationImmediatelyStopped)) {
                e.eventPhase = e.BUBBLING_PHASE;
                for (let s = r.length - 2; s >= 0; s--)
                    if (e.currentTarget = r[s],
                    this.notifyTarget(e, t),
                    e.propagationStopped || e.propagationImmediatelyStopped)
                        return
            }
        }
        all(e, t, r=this._allInteractiveElements) {
            if (r.length === 0)
                return;
            e.eventPhase = e.BUBBLING_PHASE;
            let s = Array.isArray(t) ? t : [t];
            for (let n = r.length - 1; n >= 0; n--)
                s.forEach(a => {
                    e.currentTarget = r[n],
                    this.notifyTarget(e, a)
                }
                )
        }
        propagationPath(e) {
            let t = [e];
            for (let r = 0; r < B_ && e !== this.rootTarget && e.parent; r++) {
                if (!e.parent)
                    throw new Error("Cannot find propagation path to disconnected target");
                t.push(e.parent),
                e = e.parent
            }
            return t.reverse(),
            t
        }
        hitTestMoveRecursive(e, t, r, s, n, a=!1) {
            let o = !1;
            if (this._interactivePrune(e))
                return null;
            if ((e.eventMode === "dynamic" || t === "dynamic") && (li.pauseUpdate = !1),
            e.interactiveChildren && e.children) {
                let d = e.children;
                for (let f = d.length - 1; f >= 0; f--) {
                    let b = d[f]
                      , m = this.hitTestMoveRecursive(b, this._isInteractive(t) ? t : b.eventMode, r, s, n, a || n(e, r));
                    if (m) {
                        if (m.length > 0 && !m[m.length - 1].parent)
                            continue;
                        let x = e.isInteractive();
                        (m.length > 0 || x) && (x && this._allInteractiveElements.push(e),
                        m.push(e)),
                        this._hitElements.length === 0 && (this._hitElements = m),
                        o = !0
                    }
                }
            }
            let l = this._isInteractive(t)
              , u = e.isInteractive();
            return u && u && this._allInteractiveElements.push(e),
            a || this._hitElements.length > 0 ? null : o ? this._hitElements : l && !n(e, r) && s(e, r) ? u ? [e] : [] : null
        }
        hitTestRecursive(e, t, r, s, n) {
            if (this._interactivePrune(e) || n(e, r))
                return null;
            if ((e.eventMode === "dynamic" || t === "dynamic") && (li.pauseUpdate = !1),
            e.interactiveChildren && e.children) {
                let l = e.children
                  , u = r;
                for (let d = l.length - 1; d >= 0; d--) {
                    let f = l[d]
                      , b = this.hitTestRecursive(f, this._isInteractive(t) ? t : f.eventMode, u, s, n);
                    if (b) {
                        if (b.length > 0 && !b[b.length - 1].parent)
                            continue;
                        let m = e.isInteractive();
                        return (b.length > 0 || m) && b.push(e),
                        b
                    }
                }
            }
            let a = this._isInteractive(t)
              , o = e.isInteractive();
            return a && s(e, r) ? o ? [e] : [] : null
        }
        _isInteractive(e) {
            return e === "static" || e === "dynamic"
        }
        _interactivePrune(e) {
            return !e || !e.visible || !e.renderable || !e.measurable || e.eventMode === "none" || e.eventMode === "passive" && !e.interactiveChildren
        }
        hitPruneFn(e, t) {
            if (e.hitArea && (e.worldTransform.applyInverse(t, Fr),
            !e.hitArea.contains(Fr.x, Fr.y)))
                return !0;
            if (e.effects && e.effects.length)
                for (let r = 0; r < e.effects.length; r++) {
                    let s = e.effects[r];
                    if (s.containsPoint && !s.containsPoint(t, this.hitTestFn))
                        return !0
                }
            return !1
        }
        hitTestFn(e, t) {
            return e.hitArea ? !0 : e != null && e.containsPoint ? (e.worldTransform.applyInverse(t, Fr),
            e.containsPoint(Fr)) : !1
        }
        notifyTarget(e, t) {
            var r, s;
            if (!e.currentTarget.isInteractive())
                return;
            t != null || (t = e.type);
            let n = `on${t}`;
            (s = (r = e.currentTarget)[n]) == null || s.call(r, e);
            let a = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${t}capture` : t;
            this._notifyListeners(e, a),
            e.eventPhase === e.AT_TARGET && this._notifyListeners(e, t)
        }
        mapPointerDown(e) {
            if (!(e instanceof Pt))
                return;
            let t = this.createPointerEvent(e);
            if (this.dispatchEvent(t, "pointerdown"),
            t.pointerType === "touch")
                this.dispatchEvent(t, "touchstart");
            else if (t.pointerType === "mouse" || t.pointerType === "pen") {
                let s = t.button === 2;
                this.dispatchEvent(t, s ? "rightdown" : "mousedown")
            }
            let r = this.trackingData(e.pointerId);
            r.pressTargetsByButton[e.button] = t.composedPath(),
            this.freeEvent(t)
        }
        mapPointerMove(e) {
            var t, r, s;
            if (!(e instanceof Pt))
                return;
            this._allInteractiveElements.length = 0,
            this._hitElements.length = 0,
            this._isPointerMoveEvent = !0;
            let n = this.createPointerEvent(e);
            this._isPointerMoveEvent = !1;
            let a = n.pointerType === "mouse" || n.pointerType === "pen"
              , o = this.trackingData(e.pointerId)
              , l = this.findMountedTarget(o.overTargets);
            if (((t = o.overTargets) == null ? void 0 : t.length) > 0 && l !== n.target) {
                let f = e.type === "mousemove" ? "mouseout" : "pointerout"
                  , b = this.createPointerEvent(e, f, l);
                if (this.dispatchEvent(b, "pointerout"),
                a && this.dispatchEvent(b, "mouseout"),
                !n.composedPath().includes(l)) {
                    let m = this.createPointerEvent(e, "pointerleave", l);
                    for (m.eventPhase = m.AT_TARGET; m.target && !n.composedPath().includes(m.target); )
                        m.currentTarget = m.target,
                        this.notifyTarget(m),
                        a && this.notifyTarget(m, "mouseleave"),
                        m.target = m.target.parent;
                    this.freeEvent(m)
                }
                this.freeEvent(b)
            }
            if (l !== n.target) {
                let f = e.type === "mousemove" ? "mouseover" : "pointerover"
                  , b = this.clonePointerEvent(n, f);
                this.dispatchEvent(b, "pointerover"),
                a && this.dispatchEvent(b, "mouseover");
                let m = l?.parent;
                for (; m && m !== this.rootTarget.parent && m !== n.target; )
                    m = m.parent;
                if (!m || m === this.rootTarget.parent) {
                    let x = this.clonePointerEvent(n, "pointerenter");
                    for (x.eventPhase = x.AT_TARGET; x.target && x.target !== l && x.target !== this.rootTarget.parent; )
                        x.currentTarget = x.target,
                        this.notifyTarget(x),
                        a && this.notifyTarget(x, "mouseenter"),
                        x.target = x.target.parent;
                    this.freeEvent(x)
                }
                this.freeEvent(b)
            }
            let u = []
              , d = (r = this.enableGlobalMoveEvents) != null ? r : !0;
            this.moveOnAll ? u.push("pointermove") : this.dispatchEvent(n, "pointermove"),
            d && u.push("globalpointermove"),
            n.pointerType === "touch" && (this.moveOnAll ? u.splice(1, 0, "touchmove") : this.dispatchEvent(n, "touchmove"),
            d && u.push("globaltouchmove")),
            a && (this.moveOnAll ? u.splice(1, 0, "mousemove") : this.dispatchEvent(n, "mousemove"),
            d && u.push("globalmousemove"),
            this.cursor = (s = n.target) == null ? void 0 : s.cursor),
            u.length > 0 && this.all(n, u),
            this._allInteractiveElements.length = 0,
            this._hitElements.length = 0,
            o.overTargets = n.composedPath(),
            this.freeEvent(n)
        }
        mapPointerOver(e) {
            var t;
            if (!(e instanceof Pt))
                return;
            let r = this.trackingData(e.pointerId)
              , s = this.createPointerEvent(e)
              , n = s.pointerType === "mouse" || s.pointerType === "pen";
            this.dispatchEvent(s, "pointerover"),
            n && this.dispatchEvent(s, "mouseover"),
            s.pointerType === "mouse" && (this.cursor = (t = s.target) == null ? void 0 : t.cursor);
            let a = this.clonePointerEvent(s, "pointerenter");
            for (a.eventPhase = a.AT_TARGET; a.target && a.target !== this.rootTarget.parent; )
                a.currentTarget = a.target,
                this.notifyTarget(a),
                n && this.notifyTarget(a, "mouseenter"),
                a.target = a.target.parent;
            r.overTargets = s.composedPath(),
            this.freeEvent(s),
            this.freeEvent(a)
        }
        mapPointerOut(e) {
            if (!(e instanceof Pt))
                return;
            let t = this.trackingData(e.pointerId);
            if (t.overTargets) {
                let r = e.pointerType === "mouse" || e.pointerType === "pen"
                  , s = this.findMountedTarget(t.overTargets)
                  , n = this.createPointerEvent(e, "pointerout", s);
                this.dispatchEvent(n),
                r && this.dispatchEvent(n, "mouseout");
                let a = this.createPointerEvent(e, "pointerleave", s);
                for (a.eventPhase = a.AT_TARGET; a.target && a.target !== this.rootTarget.parent; )
                    a.currentTarget = a.target,
                    this.notifyTarget(a),
                    r && this.notifyTarget(a, "mouseleave"),
                    a.target = a.target.parent;
                t.overTargets = null,
                this.freeEvent(n),
                this.freeEvent(a)
            }
            this.cursor = null
        }
        mapPointerUp(e) {
            if (!(e instanceof Pt))
                return;
            let t = performance.now()
              , r = this.createPointerEvent(e);
            if (this.dispatchEvent(r, "pointerup"),
            r.pointerType === "touch")
                this.dispatchEvent(r, "touchend");
            else if (r.pointerType === "mouse" || r.pointerType === "pen") {
                let o = r.button === 2;
                this.dispatchEvent(r, o ? "rightup" : "mouseup")
            }
            let s = this.trackingData(e.pointerId)
              , n = this.findMountedTarget(s.pressTargetsByButton[e.button])
              , a = n;
            if (n && !r.composedPath().includes(n)) {
                let o = n;
                for (; o && !r.composedPath().includes(o); ) {
                    if (r.currentTarget = o,
                    this.notifyTarget(r, "pointerupoutside"),
                    r.pointerType === "touch")
                        this.notifyTarget(r, "touchendoutside");
                    else if (r.pointerType === "mouse" || r.pointerType === "pen") {
                        let l = r.button === 2;
                        this.notifyTarget(r, l ? "rightupoutside" : "mouseupoutside")
                    }
                    o = o.parent
                }
                delete s.pressTargetsByButton[e.button],
                a = o
            }
            if (a) {
                let o = this.clonePointerEvent(r, "click");
                o.target = a,
                o.path = null,
                s.clicksByButton[e.button] || (s.clicksByButton[e.button] = {
                    clickCount: 0,
                    target: o.target,
                    timeStamp: t
                });
                let l = s.clicksByButton[e.button];
                if (l.target === o.target && t - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1,
                l.target = o.target,
                l.timeStamp = t,
                o.detail = l.clickCount,
                o.pointerType === "mouse") {
                    let u = o.button === 2;
                    this.dispatchEvent(o, u ? "rightclick" : "click")
                } else
                    o.pointerType === "touch" && this.dispatchEvent(o, "tap");
                this.dispatchEvent(o, "pointertap"),
                this.freeEvent(o)
            }
            this.freeEvent(r)
        }
        mapPointerUpOutside(e) {
            if (!(e instanceof Pt))
                return;
            let t = this.trackingData(e.pointerId)
              , r = this.findMountedTarget(t.pressTargetsByButton[e.button])
              , s = this.createPointerEvent(e);
            if (r) {
                let n = r;
                for (; n; )
                    s.currentTarget = n,
                    this.notifyTarget(s, "pointerupoutside"),
                    s.pointerType === "touch" ? this.notifyTarget(s, "touchendoutside") : (s.pointerType === "mouse" || s.pointerType === "pen") && this.notifyTarget(s, s.button === 2 ? "rightupoutside" : "mouseupoutside"),
                    n = n.parent;
                delete t.pressTargetsByButton[e.button]
            }
            this.freeEvent(s)
        }
        mapWheel(e) {
            if (!(e instanceof Ri))
                return;
            let t = this.createWheelEvent(e);
            this.dispatchEvent(t),
            this.freeEvent(t)
        }
        findMountedTarget(e) {
            if (!e)
                return null;
            let t = e[0];
            for (let r = 1; r < e.length && e[r].parent === t; r++)
                t = e[r];
            return t
        }
        createPointerEvent(e, t, r) {
            var s;
            let n = this.allocateEvent(Pt);
            return this.copyPointerData(e, n),
            this.copyMouseData(e, n),
            this.copyData(e, n),
            n.nativeEvent = e.nativeEvent,
            n.originalEvent = e,
            n.target = (s = r ?? this.hitTest(n.global.x, n.global.y)) != null ? s : this._hitElements[0],
            typeof t == "string" && (n.type = t),
            n
        }
        createWheelEvent(e) {
            let t = this.allocateEvent(Ri);
            return this.copyWheelData(e, t),
            this.copyMouseData(e, t),
            this.copyData(e, t),
            t.nativeEvent = e.nativeEvent,
            t.originalEvent = e,
            t.target = this.hitTest(t.global.x, t.global.y),
            t
        }
        clonePointerEvent(e, t) {
            let r = this.allocateEvent(Pt);
            return r.nativeEvent = e.nativeEvent,
            r.originalEvent = e.originalEvent,
            this.copyPointerData(e, r),
            this.copyMouseData(e, r),
            this.copyData(e, r),
            r.target = e.target,
            r.path = e.composedPath().slice(),
            r.type = t ?? r.type,
            r
        }
        copyWheelData(e, t) {
            t.deltaMode = e.deltaMode,
            t.deltaX = e.deltaX,
            t.deltaY = e.deltaY,
            t.deltaZ = e.deltaZ
        }
        copyPointerData(e, t) {
            e instanceof Pt && t instanceof Pt && (t.pointerId = e.pointerId,
            t.width = e.width,
            t.height = e.height,
            t.isPrimary = e.isPrimary,
            t.pointerType = e.pointerType,
            t.pressure = e.pressure,
            t.tangentialPressure = e.tangentialPressure,
            t.tiltX = e.tiltX,
            t.tiltY = e.tiltY,
            t.twist = e.twist)
        }
        copyMouseData(e, t) {
            e instanceof Tr && t instanceof Tr && (t.altKey = e.altKey,
            t.button = e.button,
            t.buttons = e.buttons,
            t.client.copyFrom(e.client),
            t.ctrlKey = e.ctrlKey,
            t.metaKey = e.metaKey,
            t.movement.copyFrom(e.movement),
            t.screen.copyFrom(e.screen),
            t.shiftKey = e.shiftKey,
            t.global.copyFrom(e.global))
        }
        copyData(e, t) {
            t.isTrusted = e.isTrusted,
            t.srcElement = e.srcElement,
            t.timeStamp = performance.now(),
            t.type = e.type,
            t.detail = e.detail,
            t.view = e.view,
            t.which = e.which,
            t.layer.copyFrom(e.layer),
            t.page.copyFrom(e.page)
        }
        trackingData(e) {
            return this.mappingState.trackingData[e] || (this.mappingState.trackingData[e] = {
                pressTargetsByButton: {},
                clicksByButton: {},
                overTarget: null
            }),
            this.mappingState.trackingData[e]
        }
        allocateEvent(e) {
            this.eventPool.has(e) || this.eventPool.set(e, []);
            let t = this.eventPool.get(e).pop() || new e(this);
            return t.eventPhase = t.NONE,
            t.currentTarget = null,
            t.defaultPrevented = !1,
            t.path = null,
            t.target = null,
            t
        }
        freeEvent(e) {
            if (e.manager !== this)
                throw new Error("It is illegal to free an event not managed by this EventBoundary!");
            let t = e.constructor;
            this.eventPool.has(t) || this.eventPool.set(t, []),
            this.eventPool.get(t).push(e)
        }
        _notifyListeners(e, t) {
            let r = e.currentTarget._events[t];
            if (r)
                if ("fn"in r)
                    r.once && e.currentTarget.removeListener(t, r.fn, void 0, !0),
                    r.fn.call(r.context, e);
                else
                    for (let s = 0, n = r.length; s < n && !e.propagationImmediatelyStopped; s++)
                        r[s].once && e.currentTarget.removeListener(t, r[s].fn, void 0, !0),
                        r[s].fn.call(r[s].context, e)
        }
    }
      , D_ = Object.defineProperty
      , Vu = Object.getOwnPropertySymbols
      , k_ = Object.prototype.hasOwnProperty
      , U_ = Object.prototype.propertyIsEnumerable
      , Wu = (i, e, t) => e in i ? D_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , L_ = (i, e) => {
        for (var t in e || (e = {}))
            k_.call(e, t) && Wu(i, t, e[t]);
        if (Vu)
            for (var t of Vu(e))
                U_.call(e, t) && Wu(i, t, e[t]);
        return i
    }
      , N_ = 1
      , X_ = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
    }
      , Xc = class jc {
        constructor(e) {
            this.supportsTouchEvents = "ontouchstart"in globalThis,
            this.supportsPointerEvents = !!globalThis.PointerEvent,
            this.domElement = null,
            this.resolution = 1,
            this.renderer = e,
            this.rootBoundary = new Nc(null),
            li.init(this),
            this.autoPreventDefault = !0,
            this._eventsAdded = !1,
            this._rootPointerEvent = new Pt(null),
            this._rootWheelEvent = new Ri(null),
            this.cursorStyles = {
                default: "inherit",
                pointer: "pointer"
            },
            this.features = new Proxy(L_({}, jc.defaultEventFeatures),{
                set: (t, r, s) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = s),
                t[r] = s,
                !0)
            }),
            this._onPointerDown = this._onPointerDown.bind(this),
            this._onPointerMove = this._onPointerMove.bind(this),
            this._onPointerUp = this._onPointerUp.bind(this),
            this._onPointerOverOut = this._onPointerOverOut.bind(this),
            this.onWheel = this.onWheel.bind(this)
        }
        static get defaultEventMode() {
            return this._defaultEventMode
        }
        init(e) {
            var t, r;
            let {canvas: s, resolution: n} = this.renderer;
            this.setTargetElement(s),
            this.resolution = n,
            jc._defaultEventMode = (t = e.eventMode) != null ? t : "passive",
            Object.assign(this.features, (r = e.eventFeatures) != null ? r : {}),
            this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
        }
        resolutionChange(e) {
            this.resolution = e
        }
        destroy() {
            li.destroy(),
            this.setTargetElement(null),
            this.renderer = null,
            this._currentCursor = null
        }
        setCursor(e) {
            e || (e = "default");
            let t = !0;
            if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (t = !1),
            this._currentCursor === e)
                return;
            this._currentCursor = e;
            let r = this.cursorStyles[e];
            if (r)
                switch (typeof r) {
                case "string":
                    t && (this.domElement.style.cursor = r);
                    break;
                case "function":
                    r(e);
                    break;
                case "object":
                    t && Object.assign(this.domElement.style, r);
                    break
                }
            else
                t && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e)
        }
        get pointer() {
            return this._rootPointerEvent
        }
        _onPointerDown(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let t = this._normalizeToPointerData(e);
            this.autoPreventDefault && t[0].isNormalized && (e.cancelable || !("cancelable"in e)) && e.preventDefault();
            for (let r = 0, s = t.length; r < s; r++) {
                let n = t[r]
                  , a = this._bootstrapEvent(this._rootPointerEvent, n);
                this.rootBoundary.mapEvent(a)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerMove(e) {
            if (!this.features.move)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
            li.pointerMoved();
            let t = this._normalizeToPointerData(e);
            for (let r = 0, s = t.length; r < s; r++) {
                let n = this._bootstrapEvent(this._rootPointerEvent, t[r]);
                this.rootBoundary.mapEvent(n)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerUp(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let t = e.target;
            e.composedPath && e.composedPath().length > 0 && (t = e.composedPath()[0]);
            let r = t !== this.domElement ? "outside" : ""
              , s = this._normalizeToPointerData(e);
            for (let n = 0, a = s.length; n < a; n++) {
                let o = this._bootstrapEvent(this._rootPointerEvent, s[n]);
                o.type += r,
                this.rootBoundary.mapEvent(o)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerOverOut(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let t = this._normalizeToPointerData(e);
            for (let r = 0, s = t.length; r < s; r++) {
                let n = this._bootstrapEvent(this._rootPointerEvent, t[r]);
                this.rootBoundary.mapEvent(n)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onWheel(e) {
            if (!this.features.wheel)
                return;
            let t = this.normalizeWheelEvent(e);
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
            this.rootBoundary.mapEvent(t)
        }
        setTargetElement(e) {
            this._removeEvents(),
            this.domElement = e,
            li.domElement = e,
            this._addEvents()
        }
        _addEvents() {
            if (this._eventsAdded || !this.domElement)
                return;
            li.addTickerListener();
            let e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none",
            e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none")),
            this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0),
            this.domElement.addEventListener("pointerdown", this._onPointerDown, !0),
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0),
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0),
            globalThis.addEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0),
            this.domElement.addEventListener("mousedown", this._onPointerDown, !0),
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0),
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0),
            globalThis.addEventListener("mouseup", this._onPointerUp, !0),
            this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, !0),
            this.domElement.addEventListener("touchend", this._onPointerUp, !0),
            this.domElement.addEventListener("touchmove", this._onPointerMove, !0))),
            this.domElement.addEventListener("wheel", this.onWheel, {
                passive: !0,
                capture: !0
            }),
            this._eventsAdded = !0
        }
        _removeEvents() {
            if (!this._eventsAdded || !this.domElement)
                return;
            li.removeTickerListener();
            let e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "",
            e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = "")),
            this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0),
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0),
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0),
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0),
            globalThis.removeEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0),
            this.domElement.removeEventListener("mousedown", this._onPointerDown, !0),
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0),
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0),
            globalThis.removeEventListener("mouseup", this._onPointerUp, !0),
            this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0),
            this.domElement.removeEventListener("touchend", this._onPointerUp, !0),
            this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))),
            this.domElement.removeEventListener("wheel", this.onWheel, !0),
            this.domElement = null,
            this._eventsAdded = !1
        }
        mapPositionToPoint(e, t, r) {
            let s = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
                x: 0,
                y: 0,
                width: this.domElement.width,
                height: this.domElement.height,
                left: 0,
                top: 0
            }
              , n = 1 / this.resolution;
            e.x = (t - s.left) * (this.domElement.width / s.width) * n,
            e.y = (r - s.top) * (this.domElement.height / s.height) * n
        }
        _normalizeToPointerData(e) {
            let t = [];
            if (this.supportsTouchEvents && e instanceof TouchEvent)
                for (let r = 0, s = e.changedTouches.length; r < s; r++) {
                    let n = e.changedTouches[r];
                    typeof n.button > "u" && (n.button = 0),
                    typeof n.buttons > "u" && (n.buttons = 1),
                    typeof n.isPrimary > "u" && (n.isPrimary = e.touches.length === 1 && e.type === "touchstart"),
                    typeof n.width > "u" && (n.width = n.radiusX || 1),
                    typeof n.height > "u" && (n.height = n.radiusY || 1),
                    typeof n.tiltX > "u" && (n.tiltX = 0),
                    typeof n.tiltY > "u" && (n.tiltY = 0),
                    typeof n.pointerType > "u" && (n.pointerType = "touch"),
                    typeof n.pointerId > "u" && (n.pointerId = n.identifier || 0),
                    typeof n.pressure > "u" && (n.pressure = n.force || .5),
                    typeof n.twist > "u" && (n.twist = 0),
                    typeof n.tangentialPressure > "u" && (n.tangentialPressure = 0),
                    typeof n.layerX > "u" && (n.layerX = n.offsetX = n.clientX),
                    typeof n.layerY > "u" && (n.layerY = n.offsetY = n.clientY),
                    n.isNormalized = !0,
                    n.type = e.type,
                    t.push(n)
                }
            else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
                let r = e;
                typeof r.isPrimary > "u" && (r.isPrimary = !0),
                typeof r.width > "u" && (r.width = 1),
                typeof r.height > "u" && (r.height = 1),
                typeof r.tiltX > "u" && (r.tiltX = 0),
                typeof r.tiltY > "u" && (r.tiltY = 0),
                typeof r.pointerType > "u" && (r.pointerType = "mouse"),
                typeof r.pointerId > "u" && (r.pointerId = N_),
                typeof r.pressure > "u" && (r.pressure = .5),
                typeof r.twist > "u" && (r.twist = 0),
                typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0),
                r.isNormalized = !0,
                t.push(r)
            } else
                t.push(e);
            return t
        }
        normalizeWheelEvent(e) {
            let t = this._rootWheelEvent;
            return this._transferMouseData(t, e),
            t.deltaX = e.deltaX,
            t.deltaY = e.deltaY,
            t.deltaZ = e.deltaZ,
            t.deltaMode = e.deltaMode,
            this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
            t.global.copyFrom(t.screen),
            t.offset.copyFrom(t.screen),
            t.nativeEvent = e,
            t.type = e.type,
            t
        }
        _bootstrapEvent(e, t) {
            return e.originalEvent = null,
            e.nativeEvent = t,
            e.pointerId = t.pointerId,
            e.width = t.width,
            e.height = t.height,
            e.isPrimary = t.isPrimary,
            e.pointerType = t.pointerType,
            e.pressure = t.pressure,
            e.tangentialPressure = t.tangentialPressure,
            e.tiltX = t.tiltX,
            e.tiltY = t.tiltY,
            e.twist = t.twist,
            this._transferMouseData(e, t),
            this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
            e.global.copyFrom(e.screen),
            e.offset.copyFrom(e.screen),
            e.isTrusted = t.isTrusted,
            e.type === "pointerleave" && (e.type = "pointerout"),
            e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")),
            e.type.startsWith("touch") && (e.type = X_[e.type] || e.type),
            e
        }
        _transferMouseData(e, t) {
            e.isTrusted = t.isTrusted,
            e.srcElement = t.srcElement,
            e.timeStamp = performance.now(),
            e.type = t.type,
            e.altKey = t.altKey,
            e.button = t.button,
            e.buttons = t.buttons,
            e.client.x = t.clientX,
            e.client.y = t.clientY,
            e.ctrlKey = t.ctrlKey,
            e.metaKey = t.metaKey,
            e.movement.x = t.movementX,
            e.movement.y = t.movementY,
            e.page.x = t.pageX,
            e.page.y = t.pageY,
            e.relatedTarget = null,
            e.shiftKey = t.shiftKey
        }
    }
    ;
    Xc.extension = {
        name: "events",
        type: [O.WebGLSystem, O.CanvasSystem, O.WebGPUSystem],
        priority: -1
    },
    Xc.defaultEventFeatures = {
        move: !0,
        globalMove: !0,
        click: !0,
        wheel: !0
    };
    var rb = Xc
      , j_ = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
            return this.eventMode === "dynamic" || this.eventMode === "static"
        },
        set interactive(i) {
            this.eventMode = i ? "static" : "passive"
        },
        _internalEventMode: void 0,
        get eventMode() {
            var i;
            return (i = this._internalEventMode) != null ? i : rb.defaultEventMode
        },
        set eventMode(i) {
            this._internalEventMode = i
        },
        isInteractive() {
            return this.eventMode === "static" || this.eventMode === "dynamic"
        },
        interactiveChildren: !0,
        hitArea: null,
        addEventListener(i, e, t) {
            let r = typeof t == "boolean" && t || typeof t == "object" && t.capture
              , s = typeof t == "object" ? t.signal : void 0
              , n = typeof t == "object" ? t.once === !0 : !1
              , a = typeof e == "function" ? void 0 : e;
            i = r ? `${i}capture` : i;
            let o = typeof e == "function" ? e : e.handleEvent
              , l = this;
            s && s.addEventListener("abort", () => {
                l.off(i, o, a)
            }
            ),
            n ? l.once(i, o, a) : l.on(i, o, a)
        },
        removeEventListener(i, e, t) {
            let r = typeof t == "boolean" && t || typeof t == "object" && t.capture
              , s = typeof e == "function" ? void 0 : e;
            i = r ? `${i}capture` : i,
            e = typeof e == "function" ? e : e.handleEvent,
            this.off(i, e, s)
        },
        dispatchEvent(i) {
            if (!(i instanceof fs))
                throw new Error("Container cannot propagate events outside of the Federated Events API");
            return i.defaultPrevented = !1,
            i.path = null,
            i.target = this,
            i.manager.dispatchEvent(i),
            !i.defaultPrevented
        }
    };
    be.add(rb),
    be.mixin(Te, j_);
    var Tn = class {
        constructor(e) {
            this._attachedDomElements = [],
            this._renderer = e,
            this._renderer.runners.postrender.add(this),
            this._renderer.runners.init.add(this),
            this._domElement = document.createElement("div"),
            this._domElement.style.position = "absolute",
            this._domElement.style.top = "0",
            this._domElement.style.left = "0",
            this._domElement.style.pointerEvents = "none",
            this._domElement.style.zIndex = "1000"
        }
        init() {
            this._canvasObserver = new xn({
                domElement: this._domElement,
                renderer: this._renderer
            })
        }
        addRenderable(e, t) {
            this._attachedDomElements.includes(e) || this._attachedDomElements.push(e)
        }
        updateRenderable(e) {}
        validateRenderable(e) {
            return !0
        }
        postrender() {
            let e = this._attachedDomElements;
            if (e.length === 0) {
                this._domElement.remove();
                return
            }
            this._canvasObserver.ensureAttached();
            for (let t = 0; t < e.length; t++) {
                let r = e[t]
                  , s = r.element;
                if (!r.parent || r.globalDisplayStatus < 7)
                    s?.remove(),
                    e.splice(t, 1),
                    t--;
                else {
                    this._domElement.contains(s) || (s.style.position = "absolute",
                    s.style.pointerEvents = "auto",
                    this._domElement.appendChild(s));
                    let n = r.worldTransform
                      , a = r._anchor
                      , o = r.width * a.x
                      , l = r.height * a.y;
                    s.style.transformOrigin = `${o}px ${l}px`,
                    s.style.transform = `matrix(${n.a}, ${n.b}, ${n.c}, ${n.d}, ${n.tx - o}, ${n.ty - l})`,
                    s.style.opacity = r.groupAlpha.toString()
                }
            }
        }
        destroy() {
            var e;
            this._renderer.runners.postrender.remove(this);
            for (let t = 0; t < this._attachedDomElements.length; t++)
                (e = this._attachedDomElements[t].element) == null || e.remove();
            this._attachedDomElements.length = 0,
            this._domElement.remove(),
            this._canvasObserver.destroy(),
            this._renderer = null
        }
    }
    ;
    Tn.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "dom"
    };
    var pi = class extends Te {
        constructor(e) {
            super(e),
            this.canBundle = !0,
            this.allowChildren = !1,
            this._roundPixels = 0,
            this._lastUsed = -1,
            this._gpuData = Object.create(null),
            this._bounds = new at(0,1,0,0),
            this._boundsDirty = !0
        }
        get bounds() {
            return this._boundsDirty ? (this.updateBounds(),
            this._boundsDirty = !1,
            this._bounds) : this._bounds
        }
        get roundPixels() {
            return !!this._roundPixels
        }
        set roundPixels(e) {
            this._roundPixels = e ? 1 : 0
        }
        containsPoint(e) {
            let t = this.bounds
              , {x: r, y: s} = e;
            return r >= t.minX && r <= t.maxX && s >= t.minY && s <= t.maxY
        }
        onViewUpdate() {
            if (this._didViewChangeTick++,
            this._boundsDirty = !0,
            this.didViewUpdate)
                return;
            this.didViewUpdate = !0;
            let e = this.renderGroup || this.parentRenderGroup;
            e && e.onChildViewUpdate(this)
        }
        destroy(e) {
            var t, r;
            super.destroy(e),
            this._bounds = null;
            for (let s in this._gpuData)
                (r = (t = this._gpuData[s]).destroy) == null || r.call(t);
            this._gpuData = null
        }
        collectRenderablesSimple(e, t, r) {
            let {renderPipes: s} = t;
            s.blendMode.pushBlendMode(this, this.groupBlendMode, e),
            s[this.renderPipeId].addRenderable(this, e),
            this.didViewUpdate = !1;
            let n = this.children
              , a = n.length;
            for (let o = 0; o < a; o++)
                n[o].collectRenderables(e, t, r);
            s.blendMode.popBlendMode(e)
        }
    }
    ;
    be.add(Tn);
    var Xt = (i => (i[i.Low = 0] = "Low",
    i[i.Normal = 1] = "Normal",
    i[i.High = 2] = "High",
    i))(Xt || {})
      , H_ = {
        createCanvas: (i, e) => {
            let t = document.createElement("canvas");
            return t.width = i,
            t.height = e,
            t
        }
        ,
        createImage: () => new Image,
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => {
            var i;
            return (i = document.baseURI) != null ? i : window.location.href
        }
        ,
        getFontFaceSet: () => document.fonts,
        fetch: (i, e) => fetch(i, e),
        parseXML: i => new DOMParser().parseFromString(i, "text/xml")
    }
      , Yu = H_
      , ye = {
        get() {
            return Yu
        },
        set(i) {
            Yu = i
        }
    };
    function Ht(i) {
        if (typeof i != "string")
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`)
    }
    function Dr(i) {
        return i.split("?")[0].split("#")[0]
    }
    function z_(i) {
        return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
    }
    function V_(i, e, t) {
        return i.replace(new RegExp(z_(e),"g"), t)
    }
    function W_(i, e) {
        let t = ""
          , r = 0
          , s = -1
          , n = 0
          , a = -1;
        for (let o = 0; o <= i.length; ++o) {
            if (o < i.length)
                a = i.charCodeAt(o);
            else {
                if (a === 47)
                    break;
                a = 47
            }
            if (a === 47) {
                if (!(s === o - 1 || n === 1))
                    if (s !== o - 1 && n === 2) {
                        if (t.length < 2 || r !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
                            if (t.length > 2) {
                                let l = t.lastIndexOf("/");
                                if (l !== t.length - 1) {
                                    l === -1 ? (t = "",
                                    r = 0) : (t = t.slice(0, l),
                                    r = t.length - 1 - t.lastIndexOf("/")),
                                    s = o,
                                    n = 0;
                                    continue
                                }
                            } else if (t.length === 2 || t.length === 1) {
                                t = "",
                                r = 0,
                                s = o,
                                n = 0;
                                continue
                            }
                        }
                        e && (t.length > 0 ? t += "/.." : t = "..",
                        r = 2)
                    } else
                        t.length > 0 ? t += `/${i.slice(s + 1, o)}` : t = i.slice(s + 1, o),
                        r = o - s - 1;
                s = o,
                n = 0
            } else
                a === 46 && n !== -1 ? ++n : n = -1
        }
        return t
    }
    var Mt = {
        toPosix(i) {
            return V_(i, "\\", "/")
        },
        isUrl(i) {
            return /^https?:/.test(this.toPosix(i))
        },
        isDataUrl(i) {
            return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i)
        },
        isBlobUrl(i) {
            return i.startsWith("blob:")
        },
        hasProtocol(i) {
            return /^[^/:]+:/.test(this.toPosix(i))
        },
        getProtocol(i) {
            Ht(i),
            i = this.toPosix(i);
            let e = /^file:\/\/\//.exec(i);
            if (e)
                return e[0];
            let t = /^[^/:]+:\/{0,2}/.exec(i);
            return t ? t[0] : ""
        },
        toAbsolute(i, e, t) {
            if (Ht(i),
            this.isDataUrl(i) || this.isBlobUrl(i))
                return i;
            let r = Dr(this.toPosix(e ?? ye.get().getBaseUrl()))
              , s = Dr(this.toPosix(t ?? this.rootname(r)));
            return i = this.toPosix(i),
            i.startsWith("/") ? Mt.join(s, i.slice(1)) : this.isAbsolute(i) ? i : this.join(r, i)
        },
        normalize(i) {
            if (Ht(i),
            i.length === 0)
                return ".";
            if (this.isDataUrl(i) || this.isBlobUrl(i))
                return i;
            i = this.toPosix(i);
            let e = ""
              , t = i.startsWith("/");
            this.hasProtocol(i) && (e = this.rootname(i),
            i = i.slice(e.length));
            let r = i.endsWith("/");
            return i = W_(i, !1),
            i.length > 0 && r && (i += "/"),
            t ? `/${i}` : e + i
        },
        isAbsolute(i) {
            return Ht(i),
            i = this.toPosix(i),
            this.hasProtocol(i) ? !0 : i.startsWith("/")
        },
        join(...i) {
            var e;
            if (i.length === 0)
                return ".";
            let t;
            for (let r = 0; r < i.length; ++r) {
                let s = i[r];
                if (Ht(s),
                s.length > 0)
                    if (t === void 0)
                        t = s;
                    else {
                        let n = (e = i[r - 1]) != null ? e : "";
                        this.joinExtensions.includes(this.extname(n).toLowerCase()) ? t += `/../${s}` : t += `/${s}`
                    }
            }
            return t === void 0 ? "." : this.normalize(t)
        },
        dirname(i) {
            if (Ht(i),
            i.length === 0)
                return ".";
            i = this.toPosix(i);
            let e = i.charCodeAt(0)
              , t = e === 47
              , r = -1
              , s = !0
              , n = this.getProtocol(i)
              , a = i;
            i = i.slice(n.length);
            for (let o = i.length - 1; o >= 1; --o)
                if (e = i.charCodeAt(o),
                e === 47) {
                    if (!s) {
                        r = o;
                        break
                    }
                } else
                    s = !1;
            return r === -1 ? t ? "/" : this.isUrl(a) ? n + i : n : t && r === 1 ? "//" : n + i.slice(0, r)
        },
        rootname(i) {
            Ht(i),
            i = this.toPosix(i);
            let e = "";
            if (i.startsWith("/") ? e = "/" : e = this.getProtocol(i),
            this.isUrl(i)) {
                let t = i.indexOf("/", e.length);
                t !== -1 ? e = i.slice(0, t) : e = i,
                e.endsWith("/") || (e += "/")
            }
            return e
        },
        basename(i, e) {
            Ht(i),
            e && Ht(e),
            i = Dr(this.toPosix(i));
            let t = 0, r = -1, s = !0, n;
            if (e !== void 0 && e.length > 0 && e.length <= i.length) {
                if (e.length === i.length && e === i)
                    return "";
                let a = e.length - 1
                  , o = -1;
                for (n = i.length - 1; n >= 0; --n) {
                    let l = i.charCodeAt(n);
                    if (l === 47) {
                        if (!s) {
                            t = n + 1;
                            break
                        }
                    } else
                        o === -1 && (s = !1,
                        o = n + 1),
                        a >= 0 && (l === e.charCodeAt(a) ? --a === -1 && (r = n) : (a = -1,
                        r = o))
                }
                return t === r ? r = o : r === -1 && (r = i.length),
                i.slice(t, r)
            }
            for (n = i.length - 1; n >= 0; --n)
                if (i.charCodeAt(n) === 47) {
                    if (!s) {
                        t = n + 1;
                        break
                    }
                } else
                    r === -1 && (s = !1,
                    r = n + 1);
            return r === -1 ? "" : i.slice(t, r)
        },
        extname(i) {
            Ht(i),
            i = Dr(this.toPosix(i));
            let e = -1
              , t = 0
              , r = -1
              , s = !0
              , n = 0;
            for (let a = i.length - 1; a >= 0; --a) {
                let o = i.charCodeAt(a);
                if (o === 47) {
                    if (!s) {
                        t = a + 1;
                        break
                    }
                    continue
                }
                r === -1 && (s = !1,
                r = a + 1),
                o === 46 ? e === -1 ? e = a : n !== 1 && (n = 1) : e !== -1 && (n = -1)
            }
            return e === -1 || r === -1 || n === 0 || n === 1 && e === r - 1 && e === t + 1 ? "" : i.slice(e, r)
        },
        parse(i) {
            Ht(i);
            let e = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
            };
            if (i.length === 0)
                return e;
            i = Dr(this.toPosix(i));
            let t = i.charCodeAt(0), r = this.isAbsolute(i), s, n = "";
            e.root = this.rootname(i),
            r || this.hasProtocol(i) ? s = 1 : s = 0;
            let a = -1
              , o = 0
              , l = -1
              , u = !0
              , d = i.length - 1
              , f = 0;
            for (; d >= s; --d) {
                if (t = i.charCodeAt(d),
                t === 47) {
                    if (!u) {
                        o = d + 1;
                        break
                    }
                    continue
                }
                l === -1 && (u = !1,
                l = d + 1),
                t === 46 ? a === -1 ? a = d : f !== 1 && (f = 1) : a !== -1 && (f = -1)
            }
            return a === -1 || l === -1 || f === 0 || f === 1 && a === l - 1 && a === o + 1 ? l !== -1 && (o === 0 && r ? e.base = e.name = i.slice(1, l) : e.base = e.name = i.slice(o, l)) : (o === 0 && r ? (e.name = i.slice(1, a),
            e.base = i.slice(1, l)) : (e.name = i.slice(o, a),
            e.base = i.slice(o, l)),
            e.ext = i.slice(a, l)),
            e.dir = this.dirname(i),
            n && (e.dir = n + e.dir),
            e
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"]
    }
      , Vt = (i, e, t=!1) => (Array.isArray(i) || (i = [i]),
    e ? i.map(r => typeof r == "string" || t ? e(r) : r) : i);
    function sb(i, e, t, r, s) {
        let n = e[t];
        for (let a = 0; a < n.length; a++) {
            let o = n[a];
            t < e.length - 1 ? sb(i.replace(r[t], o), e, t + 1, r, s) : s.push(i.replace(r[t], o))
        }
    }
    function Y_(i) {
        let e = /\{(.*?)\}/g
          , t = i.match(e)
          , r = [];
        if (t) {
            let s = [];
            t.forEach(n => {
                let a = n.substring(1, n.length - 1).split(",");
                s.push(a)
            }
            ),
            sb(i, s, 0, t, r)
        } else
            r.push(i);
        return r
    }
    var Sn = i => !Array.isArray(i)
      , $_ = Object.defineProperty
      , K_ = Object.defineProperties
      , q_ = Object.getOwnPropertyDescriptors
      , $u = Object.getOwnPropertySymbols
      , Z_ = Object.prototype.hasOwnProperty
      , Q_ = Object.prototype.propertyIsEnumerable
      , Ku = (i, e, t) => e in i ? $_(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , nr = (i, e) => {
        for (var t in e || (e = {}))
            Z_.call(e, t) && Ku(i, t, e[t]);
        if ($u)
            for (var t of $u(e))
                Q_.call(e, t) && Ku(i, t, e[t]);
        return i
    }
      , J_ = (i, e) => K_(i, q_(e))
      , bi = class {
        constructor() {
            this._defaultBundleIdentifierOptions = {
                connector: "-",
                createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
                extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, "")
            },
            this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector,
            this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId,
            this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,
            this._assetMap = {},
            this._preferredOrder = [],
            this._parsers = [],
            this._resolverHash = {},
            this._bundles = {}
        }
        setBundleIdentifier(e) {
            var t, r, s;
            if (this._bundleIdConnector = (t = e.connector) != null ? t : this._bundleIdConnector,
            this._createBundleAssetId = (r = e.createBundleAssetId) != null ? r : this._createBundleAssetId,
            this._extractAssetIdFromBundle = (s = e.extractAssetIdFromBundle) != null ? s : this._extractAssetIdFromBundle,
            this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
                throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
        }
        prefer(...e) {
            e.forEach(t => {
                this._preferredOrder.push(t),
                t.priority || (t.priority = Object.keys(t.params))
            }
            ),
            this._resolverHash = {}
        }
        set basePath(e) {
            this._basePath = e
        }
        get basePath() {
            return this._basePath
        }
        set rootPath(e) {
            this._rootPath = e
        }
        get rootPath() {
            return this._rootPath
        }
        get parsers() {
            return this._parsers
        }
        reset() {
            this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
            this._assetMap = {},
            this._preferredOrder = [],
            this._resolverHash = {},
            this._rootPath = null,
            this._basePath = null,
            this._manifest = null,
            this._bundles = {},
            this._defaultSearchParams = null
        }
        setDefaultSearchParams(e) {
            if (typeof e == "string")
                this._defaultSearchParams = e;
            else {
                let t = e;
                this._defaultSearchParams = Object.keys(t).map(r => `${encodeURIComponent(r)}=${encodeURIComponent(t[r])}`).join("&")
            }
        }
        getAlias(e) {
            let {alias: t, src: r} = e;
            return Vt(t || r, s => typeof s == "string" ? s : Array.isArray(s) ? s.map(n => {
                var a;
                return (a = n?.src) != null ? a : n
            }
            ) : s != null && s.src ? s.src : s, !0)
        }
        addManifest(e) {
            this._manifest,
            this._manifest = e,
            e.bundles.forEach(t => {
                this.addBundle(t.name, t.assets)
            }
            )
        }
        addBundle(e, t) {
            let r = []
              , s = t;
            Array.isArray(t) || (s = Object.entries(t).map( ([n,a]) => typeof a == "string" || Array.isArray(a) ? {
                alias: n,
                src: a
            } : nr({
                alias: n
            }, a))),
            s.forEach(n => {
                let a = n.src, o = n.alias, l;
                if (typeof o == "string") {
                    let u = this._createBundleAssetId(e, o);
                    r.push(u),
                    l = [o, u]
                } else {
                    let u = o.map(d => this._createBundleAssetId(e, d));
                    r.push(...u),
                    l = [...o, ...u]
                }
                this.add(J_(nr({}, n), {
                    alias: l,
                    src: a
                }))
            }
            ),
            this._bundles[e] = r
        }
        add(e) {
            let t = [];
            Array.isArray(e) ? t.push(...e) : t.push(e);
            let r;
            Vt(t).forEach(s => {
                let {src: n} = s
                  , {data: a, format: o, loadParser: l, parser: u} = s
                  , d = Vt(n).map(m => typeof m == "string" ? Y_(m) : Array.isArray(m) ? m : [m])
                  , f = this.getAlias(s)
                  , b = [];
                d.forEach(m => {
                    m.forEach(x => {
                        var v, S, w, E;
                        let P = {};
                        if (typeof x != "object") {
                            P.src = x;
                            for (let C = 0; C < this._parsers.length; C++) {
                                let L = this._parsers[C];
                                if (L.test(x)) {
                                    P = L.parse(x);
                                    break
                                }
                            }
                        } else
                            a = (v = x.data) != null ? v : a,
                            o = (S = x.format) != null ? S : o,
                            (x.loadParser || x.parser) && (l = (w = x.loadParser) != null ? w : l,
                            u = (E = x.parser) != null ? E : u),
                            P = nr(nr({}, P), x);
                        if (!f)
                            throw new Error(`[Resolver] alias is undefined for this asset: ${P.src}`);
                        P = this._buildResolvedAsset(P, {
                            aliases: f,
                            data: a,
                            format: o,
                            loadParser: l,
                            parser: u
                        }),
                        b.push(P)
                    }
                    )
                }
                ),
                f.forEach(m => {
                    this._assetMap[m] = b
                }
                )
            }
            )
        }
        resolveBundle(e) {
            let t = Sn(e);
            e = Vt(e);
            let r = {};
            return e.forEach(s => {
                let n = this._bundles[s];
                if (n) {
                    let a = this.resolve(n)
                      , o = {};
                    for (let l in a) {
                        let u = a[l];
                        o[this._extractAssetIdFromBundle(s, l)] = u
                    }
                    r[s] = o
                }
            }
            ),
            t ? r[e[0]] : r
        }
        resolveUrl(e) {
            let t = this.resolve(e);
            if (typeof e != "string") {
                let r = {};
                for (let s in t)
                    r[s] = t[s].src;
                return r
            }
            return t.src
        }
        resolve(e) {
            let t = Sn(e);
            e = Vt(e);
            let r = {};
            return e.forEach(s => {
                if (!this._resolverHash[s])
                    if (this._assetMap[s]) {
                        let n = this._assetMap[s]
                          , a = this._getPreferredOrder(n);
                        a?.priority.forEach(o => {
                            a.params[o].forEach(l => {
                                let u = n.filter(d => d[o] ? d[o] === l : !1);
                                u.length && (n = u)
                            }
                            )
                        }
                        ),
                        this._resolverHash[s] = n[0]
                    } else
                        this._resolverHash[s] = this._buildResolvedAsset({
                            alias: [s],
                            src: s
                        }, {});
                r[s] = this._resolverHash[s]
            }
            ),
            t ? r[e[0]] : r
        }
        hasKey(e) {
            return !!this._assetMap[e]
        }
        hasBundle(e) {
            return !!this._bundles[e]
        }
        _getPreferredOrder(e) {
            for (let t = 0; t < e.length; t++) {
                let r = e[t]
                  , s = this._preferredOrder.find(n => n.params.format.includes(r.format));
                if (s)
                    return s
            }
            return this._preferredOrder[0]
        }
        _appendDefaultSearchParams(e) {
            if (!this._defaultSearchParams)
                return e;
            let t = /\?/.test(e) ? "&" : "?";
            return `${e}${t}${this._defaultSearchParams}`
        }
        _buildResolvedAsset(e, t) {
            var r, s;
            let {aliases: n, data: a, loadParser: o, parser: l, format: u} = t;
            return (this._basePath || this._rootPath) && (e.src = Mt.toAbsolute(e.src, this._basePath, this._rootPath)),
            e.alias = (r = n ?? e.alias) != null ? r : [e.src],
            e.src = this._appendDefaultSearchParams(e.src),
            e.data = nr(nr({}, a || {}), e.data),
            e.loadParser = o ?? e.loadParser,
            e.parser = l ?? e.parser,
            e.format = (s = u ?? e.format) != null ? s : e2(e.src),
            e
        }
    }
    ;
    bi.RETINA_PREFIX = /@([0-9\.]+)x/;
    function e2(i) {
        return i.split(".").pop().split("?").shift().split("#").shift()
    }
    var Hc = (i, e) => {
        let t = e.split("?")[1];
        return t && (i += `?${t}`),
        i
    }
      , nb = class Zr {
        constructor(e, t) {
            this.linkedSheets = [];
            let r = e;
            e?.source instanceof Xe && (r = {
                texture: e,
                data: t
            });
            let {texture: s, data: n, cachePrefix: a=""} = r;
            this.cachePrefix = a,
            this._texture = s instanceof Z ? s : null,
            this.textureSource = s.source,
            this.textures = {},
            this.animations = {},
            this.data = n;
            let o = parseFloat(n.meta.scale);
            o ? (this.resolution = o,
            s.source.resolution = this.resolution) : this.resolution = s.source._resolution,
            this._frames = this.data.frames,
            this._frameKeys = Object.keys(this._frames),
            this._batchIndex = 0,
            this._callback = null
        }
        parse() {
            return new Promise(e => {
                this._callback = e,
                this._batchIndex = 0,
                this._frameKeys.length <= Zr.BATCH_SIZE ? (this._processFrames(0),
                this._processAnimations(),
                this._parseComplete()) : this._nextBatch()
            }
            )
        }
        _processFrames(e) {
            let t = e
              , r = Zr.BATCH_SIZE;
            for (; t - e < r && t < this._frameKeys.length; ) {
                let s = this._frameKeys[t]
                  , n = this._frames[s]
                  , a = n.frame;
                if (a) {
                    let o = null
                      , l = null
                      , u = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame
                      , d = new Oe(0,0,Math.floor(u.w) / this.resolution,Math.floor(u.h) / this.resolution);
                    n.rotated ? o = new Oe(Math.floor(a.x) / this.resolution,Math.floor(a.y) / this.resolution,Math.floor(a.h) / this.resolution,Math.floor(a.w) / this.resolution) : o = new Oe(Math.floor(a.x) / this.resolution,Math.floor(a.y) / this.resolution,Math.floor(a.w) / this.resolution,Math.floor(a.h) / this.resolution),
                    n.trimmed !== !1 && n.spriteSourceSize && (l = new Oe(Math.floor(n.spriteSourceSize.x) / this.resolution,Math.floor(n.spriteSourceSize.y) / this.resolution,Math.floor(a.w) / this.resolution,Math.floor(a.h) / this.resolution)),
                    this.textures[s] = new Z({
                        source: this.textureSource,
                        frame: o,
                        orig: d,
                        trim: l,
                        rotate: n.rotated ? 2 : 0,
                        defaultAnchor: n.anchor,
                        defaultBorders: n.borders,
                        label: s.toString()
                    })
                }
                t++
            }
        }
        _processAnimations() {
            let e = this.data.animations || {};
            for (let t in e) {
                this.animations[t] = [];
                for (let r = 0; r < e[t].length; r++) {
                    let s = e[t][r];
                    this.animations[t].push(this.textures[s])
                }
            }
        }
        _parseComplete() {
            let e = this._callback;
            this._callback = null,
            this._batchIndex = 0,
            e.call(this, this.textures)
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * Zr.BATCH_SIZE),
            this._batchIndex++,
            setTimeout( () => {
                this._batchIndex * Zr.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(),
                this._parseComplete())
            }
            , 0)
        }
        destroy(e=!1) {
            var t;
            for (let r in this.textures)
                this.textures[r].destroy();
            this._frames = null,
            this._frameKeys = null,
            this.data = null,
            this.textures = null,
            e && ((t = this._texture) == null || t.destroy(),
            this.textureSource.destroy()),
            this._texture = null,
            this.textureSource = null,
            this.linkedSheets = []
        }
    }
    ;
    nb.BATCH_SIZE = 1e3;
    var qu = nb
      , t2 = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"];
    function ab(i, e, t) {
        let r = {};
        if (i.forEach(s => {
            r[s] = e
        }
        ),
        Object.keys(e.textures).forEach(s => {
            r[`${e.cachePrefix}${s}`] = e.textures[s]
        }
        ),
        !t) {
            let s = Mt.dirname(i[0]);
            e.linkedSheets.forEach( (n, a) => {
                let o = ab([`${s}/${e.data.meta.related_multi_packs[a]}`], n, !0);
                Object.assign(r, o)
            }
            )
        }
        return r
    }
    var i2 = {
        extension: O.Asset,
        cache: {
            test: i => i instanceof qu,
            getCacheableAssets: (i, e) => ab(i, e, !1)
        },
        resolver: {
            extension: {
                type: O.ResolveParser,
                name: "resolveSpritesheet"
            },
            test: i => {
                let e = i.split("?")[0].split(".")
                  , t = e.pop()
                  , r = e.pop();
                return t === "json" && t2.includes(r)
            }
            ,
            parse: i => {
                var e, t;
                let r = i.split(".");
                return {
                    resolution: parseFloat((t = (e = bi.RETINA_PREFIX.exec(i)) == null ? void 0 : e[1]) != null ? t : "1"),
                    format: r[r.length - 2],
                    src: i
                }
            }
        },
        loader: {
            name: "spritesheetLoader",
            id: "spritesheet",
            extension: {
                type: O.LoadParser,
                priority: Xt.Normal,
                name: "spritesheetLoader"
            },
            async testParse(i, e) {
                return Mt.extname(e.src).toLowerCase() === ".json" && !!i.frames
            },
            async parse(i, e, t) {
                var r, s, n;
                let {texture: a, imageFilename: o, textureOptions: l, cachePrefix: u} = (r = e?.data) != null ? r : {}
                  , d = Mt.dirname(e.src);
                d && d.lastIndexOf("/") !== d.length - 1 && (d += "/");
                let f;
                if (a instanceof Z)
                    f = a;
                else {
                    let x = Hc(d + (o ?? i.meta.image), e.src);
                    f = (await t.load([{
                        src: x,
                        data: l
                    }]))[x]
                }
                let b = new qu({
                    texture: f.source,
                    data: i,
                    cachePrefix: u
                });
                await b.parse();
                let m = (s = i?.meta) == null ? void 0 : s.related_multi_packs;
                if (Array.isArray(m)) {
                    let x = [];
                    for (let S of m) {
                        if (typeof S != "string")
                            continue;
                        let w = d + S;
                        (n = e.data) != null && n.ignoreMultiPack || (w = Hc(w, e.src),
                        x.push(t.load({
                            src: w,
                            data: {
                                textureOptions: l,
                                ignoreMultiPack: !0
                            }
                        })))
                    }
                    let v = await Promise.all(x);
                    b.linkedSheets = v,
                    v.forEach(S => {
                        S.linkedSheets = [b].concat(b.linkedSheets.filter(w => w !== S))
                    }
                    )
                }
                return b
            },
            async unload(i, e, t) {
                await t.unload(i.textureSource._sourceOrigin),
                i.destroy(!1)
            }
        }
    };
    be.add(i2);
    function ob(i, e, t) {
        let {width: r, height: s} = t.orig
          , n = t.trim;
        if (n) {
            let a = n.width
              , o = n.height;
            i.minX = n.x - e._x * r,
            i.maxX = i.minX + a,
            i.minY = n.y - e._y * s,
            i.maxY = i.minY + o
        } else
            i.minX = -e._x * r,
            i.maxX = i.minX + r,
            i.minY = -e._y * s,
            i.maxY = i.minY + s
    }
    var r2 = Object.defineProperty
      , wn = Object.getOwnPropertySymbols
      , cb = Object.prototype.hasOwnProperty
      , lb = Object.prototype.propertyIsEnumerable
      , Zu = (i, e, t) => e in i ? r2(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , s2 = (i, e) => {
        for (var t in e || (e = {}))
            cb.call(e, t) && Zu(i, t, e[t]);
        if (wn)
            for (var t of wn(e))
                lb.call(e, t) && Zu(i, t, e[t]);
        return i
    }
      , n2 = (i, e) => {
        var t = {};
        for (var r in i)
            cb.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && wn)
            for (var r of wn(i))
                e.indexOf(r) < 0 && lb.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Fe = class i extends pi {
        constructor(e=Z.EMPTY) {
            e instanceof Z && (e = {
                texture: e
            });
            let t = e
              , {texture: r=Z.EMPTY, anchor: s, roundPixels: n, width: a, height: o} = t
              , l = n2(t, ["texture", "anchor", "roundPixels", "width", "height"]);
            super(s2({
                label: "Sprite"
            }, l)),
            this.renderPipeId = "sprite",
            this.batched = !0,
            this._visualBounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            },
            this._anchor = new ze({
                _onUpdate: () => {
                    this.onViewUpdate()
                }
            }),
            s ? this.anchor = s : r.defaultAnchor && (this.anchor = r.defaultAnchor),
            this.texture = r,
            this.allowChildren = !1,
            this.roundPixels = n ?? !1,
            a !== void 0 && (this.width = a),
            o !== void 0 && (this.height = o)
        }
        static from(e, t=!1) {
            return e instanceof Z ? new i(e) : new i(Z.from(e, t))
        }
        set texture(e) {
            e || (e = Z.EMPTY);
            let t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            this._texture = e,
            this._width && this._setWidth(this._width, this._texture.orig.width),
            this._height && this._setHeight(this._height, this._texture.orig.height),
            this.onViewUpdate())
        }
        get texture() {
            return this._texture
        }
        get visualBounds() {
            return ob(this._visualBounds, this._anchor, this._texture),
            this._visualBounds
        }
        get sourceBounds() {
            return this.visualBounds
        }
        updateBounds() {
            let e = this._anchor
              , t = this._texture
              , r = this._bounds
              , {width: s, height: n} = t.orig;
            r.minX = -e._x * s,
            r.maxX = r.minX + s,
            r.minY = -e._y * n,
            r.maxY = r.minY + n
        }
        destroy(e=!1) {
            if (super.destroy(e),
            typeof e == "boolean" ? e : e?.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(t)
            }
            this._texture = null,
            this._visualBounds = null,
            this._bounds = null,
            this._anchor = null,
            this._gpuData = null
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get width() {
            return Math.abs(this.scale.x) * this._texture.orig.width
        }
        set width(e) {
            this._setWidth(e, this._texture.orig.width),
            this._width = e
        }
        get height() {
            return Math.abs(this.scale.y) * this._texture.orig.height
        }
        set height(e) {
            this._setHeight(e, this._texture.orig.height),
            this._height = e
        }
        getSize(e) {
            return e || (e = {}),
            e.width = Math.abs(this.scale.x) * this._texture.orig.width,
            e.height = Math.abs(this.scale.y) * this._texture.orig.height,
            e
        }
        setSize(e, t) {
            var r;
            typeof e == "object" ? (t = (r = e.height) != null ? r : e.width,
            e = e.width) : t != null || (t = e),
            e !== void 0 && this._setWidth(e, this._texture.orig.width),
            t !== void 0 && this._setHeight(t, this._texture.orig.height)
        }
    }
      , a2 = new at;
    function hb(i, e, t) {
        let r = a2;
        i.measurable = !0,
        fo(i, t, r),
        e.addBoundsMask(r),
        i.measurable = !1
    }
    function ub(i, e, t) {
        let r = ui.get();
        i.measurable = !0;
        let s = pt.get().identity()
          , n = db(i, t, s);
        Eh(i, r, n),
        i.measurable = !1,
        e.addBoundsMask(r),
        pt.return(s),
        ui.return(r)
    }
    function db(i, e, t) {
        return i && i !== e && (db(i.parent, e, t),
        i.updateLocalTransform(),
        t.append(i.localTransform)),
        t
    }
    var An = class {
        constructor(e) {
            this.priority = 0,
            this.inverse = !1,
            this.pipe = "alphaMask",
            e != null && e.mask && this.init(e.mask)
        }
        init(e) {
            this.mask = e,
            this.renderMaskToTexture = !(e instanceof Fe),
            this.mask.renderable = this.renderMaskToTexture,
            this.mask.includeInBuild = !this.renderMaskToTexture,
            this.mask.measurable = !1
        }
        reset() {
            this.mask.measurable = !0,
            this.mask = null
        }
        addBounds(e, t) {
            this.inverse || hb(this.mask, e, t)
        }
        addLocalBounds(e, t) {
            ub(this.mask, e, t)
        }
        containsPoint(e, t) {
            let r = this.mask;
            return t(r, e)
        }
        destroy() {
            this.reset()
        }
        static test(e) {
            return e instanceof Fe
        }
    }
    ;
    An.extension = O.MaskEffect;
    var En = class {
        constructor(e) {
            this.priority = 0,
            this.pipe = "colorMask",
            e != null && e.mask && this.init(e.mask)
        }
        init(e) {
            this.mask = e
        }
        destroy() {}
        static test(e) {
            return typeof e == "number"
        }
    }
    ;
    En.extension = O.MaskEffect;
    var Pn = class {
        constructor(e) {
            this.priority = 0,
            this.pipe = "stencilMask",
            e != null && e.mask && this.init(e.mask)
        }
        init(e) {
            this.mask = e,
            this.mask.includeInBuild = !1,
            this.mask.measurable = !1
        }
        reset() {
            this.mask.measurable = !0,
            this.mask.includeInBuild = !0,
            this.mask = null
        }
        addBounds(e, t) {
            hb(this.mask, e, t)
        }
        addLocalBounds(e, t) {
            ub(this.mask, e, t)
        }
        containsPoint(e, t) {
            let r = this.mask;
            return t(r, e)
        }
        destroy() {
            this.reset()
        }
        static test(e) {
            return e instanceof Te
        }
    }
    ;
    Pn.extension = O.MaskEffect;
    var Wt = class extends Xe {
        constructor(e) {
            e.resource || (e.resource = ye.get().createCanvas()),
            e.width || (e.width = e.resource.width,
            e.autoDensity || (e.width /= e.resolution)),
            e.height || (e.height = e.resource.height,
            e.autoDensity || (e.height /= e.resolution)),
            super(e),
            this.uploadMethodId = "image",
            this.autoDensity = e.autoDensity,
            this.resizeCanvas(),
            this.transparent = !!e.transparent
        }
        resizeCanvas() {
            this.autoDensity && "style"in this.resource && (this.resource.style.width = `${this.width}px`,
            this.resource.style.height = `${this.height}px`),
            (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth,
            this.resource.height = this.pixelHeight)
        }
        resize(e=this.width, t=this.height, r=this._resolution) {
            let s = super.resize(e, t, r);
            return s && this.resizeCanvas(),
            s
        }
        static test(e) {
            return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas
        }
        get context2D() {
            return this._context2D || (this._context2D = this.resource.getContext("2d"))
        }
    }
    ;
    Wt.extension = O.TextureSource;
    var mi = class extends Xe {
        constructor(e) {
            super(e),
            this.uploadMethodId = "image",
            this.autoGarbageCollect = !0
        }
        static test(e) {
            return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame
        }
    }
    ;
    mi.extension = O.TextureSource;
    var Uo;
    async function fb() {
        return Uo != null || (Uo = (async () => {
            var i;
            let e = ye.get().createCanvas(1, 1).getContext("webgl");
            if (!e)
                return "premultiply-alpha-on-upload";
            let t = await new Promise(a => {
                let o = document.createElement("video");
                o.onloadeddata = () => a(o),
                o.onerror = () => a(null),
                o.autoplay = !1,
                o.crossOrigin = "anonymous",
                o.preload = "auto",
                o.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",
                o.load()
            }
            );
            if (!t)
                return "premultiply-alpha-on-upload";
            let r = e.createTexture();
            e.bindTexture(e.TEXTURE_2D, r);
            let s = e.createFramebuffer();
            e.bindFramebuffer(e.FRAMEBUFFER, s),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0),
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
            let n = new Uint8Array(4);
            return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, n),
            e.deleteFramebuffer(s),
            e.deleteTexture(r),
            (i = e.getExtension("WEBGL_lose_context")) == null || i.loseContext(),
            n[0] <= n[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload"
        }
        )()),
        Uo
    }
    var o2 = Object.defineProperty
      , c2 = Object.defineProperties
      , l2 = Object.getOwnPropertyDescriptors
      , Qu = Object.getOwnPropertySymbols
      , h2 = Object.prototype.hasOwnProperty
      , u2 = Object.prototype.propertyIsEnumerable
      , Ju = (i, e, t) => e in i ? o2(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , zc = (i, e) => {
        for (var t in e || (e = {}))
            h2.call(e, t) && Ju(i, t, e[t]);
        if (Qu)
            for (var t of Qu(e))
                u2.call(e, t) && Ju(i, t, e[t]);
        return i
    }
      , d2 = (i, e) => c2(i, l2(e))
      , cn = class pb extends Xe {
        constructor(e) {
            var t;
            super(e),
            this.isReady = !1,
            this.uploadMethodId = "video",
            e = zc(zc({}, pb.defaultOptions), e),
            this._autoUpdate = !0,
            this._isConnectedToTicker = !1,
            this._updateFPS = e.updateFPS || 0,
            this._msToNextUpdate = 0,
            this.autoPlay = e.autoPlay !== !1,
            this.alphaMode = (t = e.alphaMode) != null ? t : "premultiply-alpha-on-upload",
            this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this),
            this._videoFrameRequestCallbackHandle = null,
            this._load = null,
            this._resolve = null,
            this._reject = null,
            this._onCanPlay = this._onCanPlay.bind(this),
            this._onCanPlayThrough = this._onCanPlayThrough.bind(this),
            this._onError = this._onError.bind(this),
            this._onPlayStart = this._onPlayStart.bind(this),
            this._onPlayStop = this._onPlayStop.bind(this),
            this._onSeeked = this._onSeeked.bind(this),
            e.autoLoad !== !1 && this.load()
        }
        updateFrame() {
            if (!this.destroyed) {
                if (this._updateFPS) {
                    let e = nt.shared.elapsedMS * this.resource.playbackRate;
                    this._msToNextUpdate = Math.floor(this._msToNextUpdate - e)
                }
                (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0),
                this.isValid && this.update()
            }
        }
        _videoFrameRequestCallback() {
            this.updateFrame(),
            this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback)
        }
        get isValid() {
            return !!this.resource.videoWidth && !!this.resource.videoHeight
        }
        async load() {
            if (this._load)
                return this._load;
            let e = this.resource
              , t = this.options;
            return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0),
            e.addEventListener("play", this._onPlayStart),
            e.addEventListener("pause", this._onPlayStop),
            e.addEventListener("seeked", this._onSeeked),
            this._isSourceReady() ? this._mediaReady() : (t.preload || e.addEventListener("canplay", this._onCanPlay),
            e.addEventListener("canplaythrough", this._onCanPlayThrough),
            e.addEventListener("error", this._onError, !0)),
            this.alphaMode = await fb(),
            this._load = new Promise( (r, s) => {
                this.isValid ? r(this) : (this._resolve = r,
                this._reject = s,
                t.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout( () => {
                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`))
                }
                )),
                e.load())
            }
            ),
            this._load
        }
        _onError(e) {
            this.resource.removeEventListener("error", this._onError, !0),
            this.emit("error", e),
            this._reject && (this._reject(e),
            this._reject = null,
            this._resolve = null)
        }
        _isSourcePlaying() {
            let e = this.resource;
            return !e.paused && !e.ended
        }
        _isSourceReady() {
            return this.resource.readyState > 2
        }
        _onPlayStart() {
            this.isValid || this._mediaReady(),
            this._configureAutoUpdate()
        }
        _onPlayStop() {
            this._configureAutoUpdate()
        }
        _onSeeked() {
            this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0,
            this.updateFrame(),
            this._msToNextUpdate = 0)
        }
        _onCanPlay() {
            this.resource.removeEventListener("canplay", this._onCanPlay),
            this._mediaReady()
        }
        _onCanPlayThrough() {
            this.resource.removeEventListener("canplaythrough", this._onCanPlay),
            this._preloadTimeout && (clearTimeout(this._preloadTimeout),
            this._preloadTimeout = void 0),
            this._mediaReady()
        }
        _mediaReady() {
            let e = this.resource;
            this.isValid && (this.isReady = !0,
            this.resize(e.videoWidth, e.videoHeight)),
            this._msToNextUpdate = 0,
            this.updateFrame(),
            this._msToNextUpdate = 0,
            this._resolve && (this._resolve(this),
            this._resolve = null,
            this._reject = null),
            this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play()
        }
        destroy() {
            this._configureAutoUpdate();
            let e = this.resource;
            e && (e.removeEventListener("play", this._onPlayStart),
            e.removeEventListener("pause", this._onPlayStop),
            e.removeEventListener("seeked", this._onSeeked),
            e.removeEventListener("canplay", this._onCanPlay),
            e.removeEventListener("canplaythrough", this._onCanPlayThrough),
            e.removeEventListener("error", this._onError, !0),
            e.pause(),
            e.src = "",
            e.load()),
            super.destroy()
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(e) {
            e !== this._autoUpdate && (this._autoUpdate = e,
            this._configureAutoUpdate())
        }
        get updateFPS() {
            return this._updateFPS
        }
        set updateFPS(e) {
            e !== this._updateFPS && (this._updateFPS = e,
            this._configureAutoUpdate())
        }
        _configureAutoUpdate() {
            this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (nt.shared.remove(this.updateFrame, this),
            this._isConnectedToTicker = !1,
            this._msToNextUpdate = 0),
            this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
            this._videoFrameRequestCallbackHandle = null),
            this._isConnectedToTicker || (nt.shared.add(this.updateFrame, this),
            this._isConnectedToTicker = !0,
            this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
            this._videoFrameRequestCallbackHandle = null),
            this._isConnectedToTicker && (nt.shared.remove(this.updateFrame, this),
            this._isConnectedToTicker = !1,
            this._msToNextUpdate = 0))
        }
        static test(e) {
            return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement
        }
    }
    ;
    cn.extension = O.TextureSource,
    cn.defaultOptions = d2(zc({}, Xe.defaultOptions), {
        autoLoad: !0,
        autoPlay: !0,
        updateFPS: 0,
        crossorigin: !0,
        loop: !1,
        muted: !0,
        playsinline: !0,
        preload: !1
    }),
    cn.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
    };
    var ss = cn
      , f2 = class {
        constructor() {
            this._parsers = [],
            this._cache = new Map,
            this._cacheMap = new Map
        }
        reset() {
            this._cacheMap.clear(),
            this._cache.clear()
        }
        has(i) {
            return this._cache.has(i)
        }
        get(i) {
            return this._cache.get(i)
        }
        set(i, e) {
            let t = Vt(i), r;
            for (let o = 0; o < this.parsers.length; o++) {
                let l = this.parsers[o];
                if (l.test(e)) {
                    r = l.getCacheableAssets(t, e);
                    break
                }
            }
            let s = new Map(Object.entries(r || {}));
            r || t.forEach(o => {
                s.set(o, e)
            }
            );
            let n = [...s.keys()]
              , a = {
                cacheKeys: n,
                keys: t
            };
            t.forEach(o => {
                this._cacheMap.set(o, a)
            }
            ),
            n.forEach(o => {
                let l = r ? r[o] : e;
                this._cache.has(o) && this._cache.get(o),
                this._cache.set(o, s.get(o))
            }
            )
        }
        remove(i) {
            if (!this._cacheMap.has(i))
                return;
            let e = this._cacheMap.get(i);
            e.cacheKeys.forEach(t => {
                this._cache.delete(t)
            }
            ),
            e.keys.forEach(t => {
                this._cacheMap.delete(t)
            }
            )
        }
        get parsers() {
            return this._parsers
        }
    }
      , Ge = new f2
      , Vc = [];
    be.handleByList(O.TextureSource, Vc);
    function bb(i={}) {
        let e = i && i.resource
          , t = e ? i.resource : i
          , r = e ? i : {
            resource: i
        };
        for (let s = 0; s < Vc.length; s++) {
            let n = Vc[s];
            if (n.test(t))
                return new n(r)
        }
        throw new Error(`Could not find a source type for resource: ${r.resource}`)
    }
    function p2(i={}, e=!1) {
        let t = i && i.resource
          , r = t ? i.resource : i
          , s = t ? i : {
            resource: i
        };
        if (!e && Ge.has(r))
            return Ge.get(r);
        let n = new Z({
            source: bb(s)
        });
        return n.on("destroy", () => {
            Ge.has(r) && Ge.remove(r)
        }
        ),
        e || Ge.set(r, n),
        n
    }
    function b2(i, e=!1) {
        return typeof i == "string" ? Ge.get(i) : i instanceof Xe ? new Z({
            source: i
        }) : p2(i, e)
    }
    Z.from = b2,
    Xe.from = bb,
    be.add(An, En, Pn, ss, mi, Wt, us);
    var Yt = class {
        constructor(e) {
            this.resources = Object.create(null),
            this._dirty = !0;
            let t = 0;
            for (let r in e) {
                let s = e[r];
                this.setResource(s, t++)
            }
            this._updateKey()
        }
        _updateKey() {
            if (!this._dirty)
                return;
            this._dirty = !1;
            let e = []
              , t = 0;
            for (let r in this.resources)
                e[t++] = this.resources[r]._resourceId;
            this._key = e.join("|")
        }
        setResource(e, t) {
            var r, s;
            let n = this.resources[t];
            e !== n && (n && ((r = e.off) == null || r.call(e, "change", this.onResourceChange, this)),
            (s = e.on) == null || s.call(e, "change", this.onResourceChange, this),
            this.resources[t] = e,
            this._dirty = !0)
        }
        getResource(e) {
            return this.resources[e]
        }
        _touch(e) {
            let t = this.resources;
            for (let r in t)
                t[r]._touched = e
        }
        destroy() {
            var e;
            let t = this.resources;
            for (let r in t) {
                let s = t[r];
                (e = s.off) == null || e.call(s, "change", this.onResourceChange, this)
            }
            this.resources = null
        }
        onResourceChange(e) {
            if (this._dirty = !0,
            e.destroyed) {
                let t = this.resources;
                for (let r in t)
                    t[r] === e && (t[r] = null)
            } else
                this._updateKey()
        }
    }
      , mb = {};
    function Rh(i, e, t) {
        let r = 2166136261;
        for (let s = 0; s < e; s++)
            r ^= i[s].uid,
            r = Math.imul(r, 16777619),
            r >>>= 0;
        return mb[r] || m2(i, e, r, t)
    }
    function m2(i, e, t, r) {
        let s = {}
          , n = 0;
        for (let o = 0; o < r; o++) {
            let l = o < e ? i[o] : Z.EMPTY.source;
            s[n++] = l.source,
            s[n++] = l.style
        }
        let a = new Yt(s);
        return mb[t] = a,
        a
    }
    var Pi = class {
        constructor(e) {
            typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e,
            this.uint32View = new Uint32Array(this.rawBinaryData),
            this.float32View = new Float32Array(this.rawBinaryData),
            this.size = this.rawBinaryData.byteLength
        }
        get int8View() {
            return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
            this._int8View
        }
        get uint8View() {
            return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
            this._uint8View
        }
        get int16View() {
            return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
            this._int16View
        }
        get int32View() {
            return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
            this._int32View
        }
        get float64View() {
            return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)),
            this._float64Array
        }
        get bigUint64View() {
            return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)),
            this._bigUint64Array
        }
        view(e) {
            return this[`${e}View`]
        }
        destroy() {
            this.rawBinaryData = null,
            this._int8View = null,
            this._uint8View = null,
            this._int16View = null,
            this.uint16View = null,
            this._int32View = null,
            this.uint32View = null,
            this.float32View = null
        }
        static sizeOf(e) {
            switch (e) {
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${e} isn't a valid view type`)
            }
        }
    }
      , ed = new Set
      , td = "8.0.0";
    var pr = {
        quiet: !1,
        noColor: !1
    }
      , Rn = (i, e, t=3) => {
        if (pr.quiet || ed.has(e))
            return;
        let r = new Error().stack
          , s = `${e}
Deprecated since v${i}`
          , n = typeof console.groupCollapsed == "function" && !pr.noColor;
        typeof r > "u" || (r = r.split(`
`).splice(t).join(`
`)),
        ed.add(e)
    }
    ;
    Object.defineProperties(Rn, {
        quiet: {
            get: () => pr.quiet,
            set: i => {
                pr.quiet = i
            }
            ,
            enumerable: !0,
            configurable: !1
        },
        noColor: {
            get: () => pr.noColor,
            set: i => {
                pr.noColor = i
            }
            ,
            enumerable: !0,
            configurable: !1
        }
    });
    function Wc(i, e) {
        let t = i.byteLength / 8 | 0
          , r = new Float64Array(i,0,t);
        new Float64Array(e,0,t).set(r);
        let s = i.byteLength - t * 8;
        if (s > 0) {
            let n = new Uint8Array(i,t * 8,s);
            new Uint8Array(e,t * 8,s).set(n)
        }
    }
    var g2 = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
    }
      , qe = (i => (i[i.DISABLED = 0] = "DISABLED",
    i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD",
    i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE",
    i[i.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE",
    i[i.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE",
    i[i.NONE = 5] = "NONE",
    i))(qe || {});
    function ps(i, e) {
        return e.alphaMode === "no-premultiply-alpha" && g2[i] || i
    }
    var kr;
    function gb() {
        return (!kr || kr != null && kr.isContextLost()) && (kr = ye.get().createCanvas().getContext("webgl", {})),
        kr
    }
    var _2 = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);
    function x2(i) {
        let e = "";
        for (let t = 0; t < i; ++t)
            t > 0 && (e += `
else `),
            t < i - 1 && (e += `if(test == ${t}.0){}`);
        return e
    }
    function _b(i, e) {
        if (i === 0)
            throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        let t = e.createShader(e.FRAGMENT_SHADER);
        try {
            for (; ; ) {
                let r = _2.replace(/%forloop%/gi, x2(i));
                if (e.shaderSource(t, r),
                e.compileShader(t),
                !e.getShaderParameter(t, e.COMPILE_STATUS))
                    i = i / 2 | 0;
                else
                    break
            }
        } finally {
            e.deleteShader(t)
        }
        return i
    }
    var ar = null;
    function y2() {
        var i;
        if (ar)
            return ar;
        let e = gb();
        return ar = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
        ar = _b(ar, e),
        (i = e.getExtension("WEBGL_lose_context")) == null || i.loseContext(),
        ar
    }
    var Yc = class {
        constructor() {
            this.ids = Object.create(null),
            this.textures = [],
            this.count = 0
        }
        clear() {
            for (let e = 0; e < this.count; e++) {
                let t = this.textures[e];
                this.textures[e] = null,
                this.ids[t.uid] = null
            }
            this.count = 0
        }
    }
      , v2 = Object.defineProperty
      , id = Object.getOwnPropertySymbols
      , T2 = Object.prototype.hasOwnProperty
      , S2 = Object.prototype.propertyIsEnumerable
      , rd = (i, e, t) => e in i ? v2(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , sd = (i, e) => {
        for (var t in e || (e = {}))
            T2.call(e, t) && rd(i, t, e[t]);
        if (id)
            for (var t of id(e))
                S2.call(e, t) && rd(i, t, e[t]);
        return i
    }
      , $c = class {
        constructor() {
            this.renderPipeId = "batch",
            this.action = "startBatch",
            this.start = 0,
            this.size = 0,
            this.textures = new Yc,
            this.blendMode = "normal",
            this.topology = "triangle-strip",
            this.canBundle = !0
        }
        destroy() {
            this.textures = null,
            this.gpuBindGroup = null,
            this.bindGroup = null,
            this.batcher = null
        }
    }
      , ns = []
      , Mn = 0;
    Pr.register({
        clear: () => {
            if (ns.length > 0)
                for (let i of ns)
                    i && i.destroy();
            ns.length = 0,
            Mn = 0
        }
    });
    function nd() {
        return Mn > 0 ? ns[--Mn] : new $c
    }
    function ad(i) {
        ns[Mn++] = i
    }
    var Ur = 0
      , xb = class yb {
        constructor(e) {
            this.uid = Le("batcher"),
            this.dirty = !0,
            this.batchIndex = 0,
            this.batches = [],
            this._elements = [],
            e = sd(sd({}, yb.defaultOptions), e),
            e.maxTextures || (Rn("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options"),
            e.maxTextures = y2());
            let {maxTextures: t, attributesInitialSize: r, indicesInitialSize: s} = e;
            this.attributeBuffer = new Pi(r * 4),
            this.indexBuffer = new Uint16Array(s),
            this.maxTextures = t
        }
        begin() {
            this.elementSize = 0,
            this.elementStart = 0,
            this.indexSize = 0,
            this.attributeSize = 0;
            for (let e = 0; e < this.batchIndex; e++)
                ad(this.batches[e]);
            this.batchIndex = 0,
            this._batchIndexStart = 0,
            this._batchIndexSize = 0,
            this.dirty = !0
        }
        add(e) {
            this._elements[this.elementSize++] = e,
            e._indexStart = this.indexSize,
            e._attributeStart = this.attributeSize,
            e._batcher = this,
            this.indexSize += e.indexSize,
            this.attributeSize += e.attributeSize * this.vertexSize
        }
        checkAndUpdateTexture(e, t) {
            let r = e._batch.textures.ids[t._source.uid];
            return !r && r !== 0 ? !1 : (e._textureId = r,
            e.texture = t,
            !0)
        }
        updateElement(e) {
            this.dirty = !0;
            let t = this.attributeBuffer;
            e.packAsQuad ? this.packQuadAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId)
        }
        break(e) {
            let t = this._elements;
            if (!t[this.elementStart])
                return;
            let r = nd()
              , s = r.textures;
            s.clear();
            let n = t[this.elementStart]
              , a = ps(n.blendMode, n.texture._source)
              , o = n.topology;
            this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4),
            this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
            let l = this.attributeBuffer.float32View
              , u = this.attributeBuffer.uint32View
              , d = this.indexBuffer
              , f = this._batchIndexSize
              , b = this._batchIndexStart
              , m = "startBatch"
              , x = this.maxTextures;
            for (let v = this.elementStart; v < this.elementSize; ++v) {
                let S = t[v];
                t[v] = null;
                let w = S.texture._source
                  , E = ps(S.blendMode, w)
                  , P = a !== E || o !== S.topology;
                if (w._batchTick === Ur && !P) {
                    S._textureId = w._textureBindLocation,
                    f += S.indexSize,
                    S.packAsQuad ? (this.packQuadAttributes(S, l, u, S._attributeStart, S._textureId),
                    this.packQuadIndex(d, S._indexStart, S._attributeStart / this.vertexSize)) : (this.packAttributes(S, l, u, S._attributeStart, S._textureId),
                    this.packIndex(S, d, S._indexStart, S._attributeStart / this.vertexSize)),
                    S._batch = r;
                    continue
                }
                w._batchTick = Ur,
                (s.count >= x || P) && (this._finishBatch(r, b, f - b, s, a, o, e, m),
                m = "renderBatch",
                b = f,
                a = E,
                o = S.topology,
                r = nd(),
                s = r.textures,
                s.clear(),
                ++Ur),
                S._textureId = w._textureBindLocation = s.count,
                s.ids[w.uid] = s.count,
                s.textures[s.count++] = w,
                S._batch = r,
                f += S.indexSize,
                S.packAsQuad ? (this.packQuadAttributes(S, l, u, S._attributeStart, S._textureId),
                this.packQuadIndex(d, S._indexStart, S._attributeStart / this.vertexSize)) : (this.packAttributes(S, l, u, S._attributeStart, S._textureId),
                this.packIndex(S, d, S._indexStart, S._attributeStart / this.vertexSize))
            }
            s.count > 0 && (this._finishBatch(r, b, f - b, s, a, o, e, m),
            b = f,
            ++Ur),
            this.elementStart = this.elementSize,
            this._batchIndexStart = b,
            this._batchIndexSize = f
        }
        _finishBatch(e, t, r, s, n, a, o, l) {
            e.gpuBindGroup = null,
            e.bindGroup = null,
            e.action = l,
            e.batcher = this,
            e.textures = s,
            e.blendMode = n,
            e.topology = a,
            e.start = t,
            e.size = r,
            ++Ur,
            this.batches[this.batchIndex++] = e,
            o.add(e)
        }
        finish(e) {
            this.break(e)
        }
        ensureAttributeBuffer(e) {
            e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4)
        }
        ensureIndexBuffer(e) {
            e <= this.indexBuffer.length || this._resizeIndexBuffer(e)
        }
        _resizeAttributeBuffer(e) {
            let t = Math.max(e, this.attributeBuffer.size * 2)
              , r = new Pi(t);
            Wc(this.attributeBuffer.rawBinaryData, r.rawBinaryData),
            this.attributeBuffer = r
        }
        _resizeIndexBuffer(e) {
            let t = this.indexBuffer
              , r = Math.max(e, t.length * 1.5);
            r += r % 2;
            let s = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
            if (s.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT)
                for (let n = 0; n < t.length; n++)
                    s[n] = t[n];
            else
                Wc(t.buffer, s.buffer);
            this.indexBuffer = s
        }
        packQuadIndex(e, t, r) {
            e[t] = r + 0,
            e[t + 1] = r + 1,
            e[t + 2] = r + 2,
            e[t + 3] = r + 0,
            e[t + 4] = r + 2,
            e[t + 5] = r + 3
        }
        packIndex(e, t, r, s) {
            let n = e.indices
              , a = e.indexSize
              , o = e.indexOffset
              , l = e.attributeOffset;
            for (let u = 0; u < a; u++)
                t[r++] = s + n[u + o] - l
        }
        destroy() {
            if (this.batches !== null) {
                for (let e = 0; e < this.batches.length; e++)
                    ad(this.batches[e]);
                this.batches = null;
                for (let e = 0; e < this._elements.length; e++)
                    this._elements[e] && (this._elements[e]._batch = null);
                this._elements = null,
                this.indexBuffer = null,
                this.attributeBuffer.destroy(),
                this.attributeBuffer = null
            }
        }
    }
    ;
    xb.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
    };
    var w2 = xb
      , Pe = (i => (i[i.MAP_READ = 1] = "MAP_READ",
    i[i.MAP_WRITE = 2] = "MAP_WRITE",
    i[i.COPY_SRC = 4] = "COPY_SRC",
    i[i.COPY_DST = 8] = "COPY_DST",
    i[i.INDEX = 16] = "INDEX",
    i[i.VERTEX = 32] = "VERTEX",
    i[i.UNIFORM = 64] = "UNIFORM",
    i[i.STORAGE = 128] = "STORAGE",
    i[i.INDIRECT = 256] = "INDIRECT",
    i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE",
    i[i.STATIC = 1024] = "STATIC",
    i))(Pe || {})
      , bt = class extends Ot {
        constructor(e) {
            let {data: t, size: r} = e
              , {usage: s, label: n, shrinkToFit: a} = e;
            super(),
            this.uid = Le("buffer"),
            this._resourceType = "buffer",
            this._resourceId = Le("resource"),
            this._touched = 0,
            this._updateID = 1,
            this._dataInt32 = null,
            this.shrinkToFit = !0,
            this.destroyed = !1,
            t instanceof Array && (t = new Float32Array(t)),
            this._data = t,
            r != null || (r = t?.byteLength);
            let o = !!t;
            this.descriptor = {
                size: r,
                usage: s,
                mappedAtCreation: o,
                label: n
            },
            this.shrinkToFit = a ?? !0
        }
        get data() {
            return this._data
        }
        set data(e) {
            this.setDataWithSize(e, e.length, !0)
        }
        get dataInt32() {
            return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)),
            this._dataInt32
        }
        get static() {
            return !!(this.descriptor.usage & Pe.STATIC)
        }
        set static(e) {
            e ? this.descriptor.usage |= Pe.STATIC : this.descriptor.usage &= ~Pe.STATIC
        }
        setDataWithSize(e, t, r) {
            if (this._updateID++,
            this._updateSize = t * e.BYTES_PER_ELEMENT,
            this._data === e) {
                r && this.emit("update", this);
                return
            }
            let s = this._data;
            if (this._data = e,
            this._dataInt32 = null,
            !s || s.length !== e.length) {
                !this.shrinkToFit && s && e.byteLength < s.byteLength ? r && this.emit("update", this) : (this.descriptor.size = e.byteLength,
                this._resourceId = Le("resource"),
                this.emit("change", this));
                return
            }
            r && this.emit("update", this)
        }
        update(e) {
            this._updateSize = e ?? this._updateSize,
            this._updateID++,
            this.emit("update", this)
        }
        destroy() {
            this.destroyed = !0,
            this.emit("destroy", this),
            this.emit("change", this),
            this._data = null,
            this.descriptor = null,
            this.removeAllListeners()
        }
    }
    ;
    function vb(i, e) {
        if (!(i instanceof bt)) {
            let t = e ? Pe.INDEX : Pe.VERTEX;
            i instanceof Array && (e ? (i = new Uint32Array(i),
            t = Pe.INDEX | Pe.COPY_DST) : (i = new Float32Array(i),
            t = Pe.VERTEX | Pe.COPY_DST)),
            i = new bt({
                data: i,
                label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
                usage: t
            })
        }
        return i
    }
    function A2(i, e, t) {
        let r = i.getAttribute(e);
        if (!r)
            return t.minX = 0,
            t.minY = 0,
            t.maxX = 0,
            t.maxY = 0,
            t;
        let s = r.buffer.data
          , n = 1 / 0
          , a = 1 / 0
          , o = -1 / 0
          , l = -1 / 0
          , u = s.BYTES_PER_ELEMENT
          , d = (r.offset || 0) / u
          , f = (r.stride || 8) / u;
        for (let b = d; b < s.length; b += f) {
            let m = s[b]
              , x = s[b + 1];
            m > o && (o = m),
            x > l && (l = x),
            m < n && (n = m),
            x < a && (a = x)
        }
        return t.minX = n,
        t.minY = a,
        t.maxX = o,
        t.maxY = l,
        t
    }
    function E2(i) {
        return (i instanceof bt || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
            buffer: i
        }),
        i.buffer = vb(i.buffer, !1),
        i
    }
    var si = class extends Ot {
        constructor(e={}) {
            var t;
            super(),
            this.uid = Le("geometry"),
            this._layoutKey = 0,
            this.instanceCount = 1,
            this._bounds = new at,
            this._boundsDirty = !0;
            let {attributes: r, indexBuffer: s, topology: n} = e;
            if (this.buffers = [],
            this.attributes = {},
            r)
                for (let a in r)
                    this.addAttribute(a, r[a]);
            this.instanceCount = (t = e.instanceCount) != null ? t : 1,
            s && this.addIndex(s),
            this.topology = n || "triangle-list"
        }
        onBufferUpdate() {
            this._boundsDirty = !0,
            this.emit("update", this)
        }
        getAttribute(e) {
            return this.attributes[e]
        }
        getIndex() {
            return this.indexBuffer
        }
        getBuffer(e) {
            return this.getAttribute(e).buffer
        }
        getSize() {
            for (let e in this.attributes) {
                let t = this.attributes[e];
                return t.buffer.data.length / (t.stride / 4 || t.size)
            }
            return 0
        }
        addAttribute(e, t) {
            let r = E2(t);
            this.buffers.indexOf(r.buffer) === -1 && (this.buffers.push(r.buffer),
            r.buffer.on("update", this.onBufferUpdate, this),
            r.buffer.on("change", this.onBufferUpdate, this)),
            this.attributes[e] = r
        }
        addIndex(e) {
            this.indexBuffer = vb(e, !0),
            this.buffers.push(this.indexBuffer)
        }
        get bounds() {
            return this._boundsDirty ? (this._boundsDirty = !1,
            A2(this, "aPosition", this._bounds)) : this._bounds
        }
        destroy(e=!1) {
            this.emit("destroy", this),
            this.removeAllListeners(),
            e && this.buffers.forEach(t => t.destroy()),
            this.attributes = null,
            this.buffers = null,
            this.indexBuffer = null,
            this._bounds = null
        }
    }
      , P2 = new Float32Array(1)
      , R2 = new Uint32Array(1)
      , Kc = class extends si {
        constructor() {
            let e = new bt({
                data: P2,
                label: "attribute-batch-buffer",
                usage: Pe.VERTEX | Pe.COPY_DST,
                shrinkToFit: !1
            })
              , t = new bt({
                data: R2,
                label: "index-batch-buffer",
                usage: Pe.INDEX | Pe.COPY_DST,
                shrinkToFit: !1
            })
              , r = 24;
            super({
                attributes: {
                    aPosition: {
                        buffer: e,
                        format: "float32x2",
                        stride: r,
                        offset: 0
                    },
                    aUV: {
                        buffer: e,
                        format: "float32x2",
                        stride: r,
                        offset: 8
                    },
                    aColor: {
                        buffer: e,
                        format: "unorm8x4",
                        stride: r,
                        offset: 16
                    },
                    aTextureIdAndRound: {
                        buffer: e,
                        format: "uint16x2",
                        stride: r,
                        offset: 20
                    }
                },
                indexBuffer: t
            })
        }
    }
      , Lo = Object.create(null)
      , od = Object.create(null);
    function bs(i, e) {
        let t = od[i];
        return t === void 0 && (Lo[e] === void 0 && (Lo[e] = 1),
        od[i] = t = Lo[e]++),
        t
    }
    var zs;
    function M2() {
        if (!zs) {
            zs = "mediump";
            let i = gb();
            i && i.getShaderPrecisionFormat && (zs = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump")
        }
        return zs
    }
    function C2(i, e, t) {
        return e ? i : t ? (i = i.replace("out vec4 finalColor;", ""),
        `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `
    }
    function O2(i, e, t) {
        let r = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
        if (i.substring(0, 9) !== "precision") {
            let s = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
            return s === "highp" && r !== "highp" && (s = "mediump"),
            `precision ${s} float;
${i}`
        } else if (r !== "highp" && i.substring(0, 15) === "precision highp")
            return i.replace("precision highp", "precision mediump");
        return i
    }
    function I2(i, e) {
        return e ? `#version 300 es
${i}` : i
    }
    var G2 = {}
      , B2 = {};
    function F2(i, {name: e="pixi-program"}, t=!0) {
        e = e.replace(/\s+/g, "-"),
        e += t ? "-fragment" : "-vertex";
        let r = t ? G2 : B2;
        return r[e] ? (r[e]++,
        e += `-${r[e]}`) : r[e] = 1,
        i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${e}`}
${i}`
    }
    function D2(i, e) {
        return e ? i.replace("#version 300 es", "") : i
    }
    var k2 = Object.defineProperty
      , cd = Object.getOwnPropertySymbols
      , U2 = Object.prototype.hasOwnProperty
      , L2 = Object.prototype.propertyIsEnumerable
      , ld = (i, e, t) => e in i ? k2(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , hd = (i, e) => {
        for (var t in e || (e = {}))
            U2.call(e, t) && ld(i, t, e[t]);
        if (cd)
            for (var t of cd(e))
                L2.call(e, t) && ld(i, t, e[t]);
        return i
    }
      , No = {
        stripVersion: D2,
        ensurePrecision: O2,
        addProgramDefines: C2,
        setProgramName: F2,
        insertVersion: I2
    }
      , Lr = Object.create(null)
      , Tb = class qc {
        constructor(e) {
            e = hd(hd({}, qc.defaultOptions), e);
            let t = e.fragment.indexOf("#version 300 es") !== -1
              , r = {
                stripVersion: t,
                ensurePrecision: {
                    requestedFragmentPrecision: e.preferredFragmentPrecision,
                    requestedVertexPrecision: e.preferredVertexPrecision,
                    maxSupportedVertexPrecision: "highp",
                    maxSupportedFragmentPrecision: M2()
                },
                setProgramName: {
                    name: e.name
                },
                addProgramDefines: t,
                insertVersion: t
            }
              , s = e.fragment
              , n = e.vertex;
            Object.keys(No).forEach(a => {
                let o = r[a];
                s = No[a](s, o, !0),
                n = No[a](n, o, !1)
            }
            ),
            this.fragment = s,
            this.vertex = n,
            this.transformFeedbackVaryings = e.transformFeedbackVaryings,
            this._key = bs(`${this.vertex}:${this.fragment}`, "gl-program")
        }
        destroy() {
            this.fragment = null,
            this.vertex = null,
            this._attributeData = null,
            this._uniformData = null,
            this._uniformBlockData = null,
            this.transformFeedbackVaryings = null,
            Lr[this._cacheKey] = null
        }
        static from(e) {
            let t = `${e.vertex}:${e.fragment}`;
            return Lr[t] || (Lr[t] = new qc(e),
            Lr[t]._cacheKey = t),
            Lr[t]
        }
    }
    ;
    Tb.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
    };
    var yi = Tb
      , ud = {
        uint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        uint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        sint8x2: {
            size: 2,
            stride: 2,
            normalised: !1
        },
        sint8x4: {
            size: 4,
            stride: 4,
            normalised: !1
        },
        unorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        unorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        snorm8x2: {
            size: 2,
            stride: 2,
            normalised: !0
        },
        snorm8x4: {
            size: 4,
            stride: 4,
            normalised: !0
        },
        uint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        uint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        sint16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        sint16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        unorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        unorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        snorm16x2: {
            size: 2,
            stride: 4,
            normalised: !0
        },
        snorm16x4: {
            size: 4,
            stride: 8,
            normalised: !0
        },
        float16x2: {
            size: 2,
            stride: 4,
            normalised: !1
        },
        float16x4: {
            size: 4,
            stride: 8,
            normalised: !1
        },
        float32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        float32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        float32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        float32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        uint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        uint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        uint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        uint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        },
        sint32: {
            size: 1,
            stride: 4,
            normalised: !1
        },
        sint32x2: {
            size: 2,
            stride: 8,
            normalised: !1
        },
        sint32x3: {
            size: 3,
            stride: 12,
            normalised: !1
        },
        sint32x4: {
            size: 4,
            stride: 16,
            normalised: !1
        }
    };
    function Mi(i) {
        var e;
        return (e = ud[i]) != null ? e : ud.float32
    }
    var N2 = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
    };
    function X2({source: i, entryPoint: e}) {
        var t;
        let r = {}
          , s = i.indexOf(`fn ${e}`);
        if (s !== -1) {
            let n = i.indexOf("->", s);
            if (n !== -1) {
                let a = i.substring(s, n), o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g, l;
                for (; (l = o.exec(a)) !== null; ) {
                    let u = (t = N2[l[3]]) != null ? t : "float32";
                    r[l[2]] = {
                        location: parseInt(l[1], 10),
                        format: u,
                        stride: Mi(u).stride,
                        offset: 0,
                        instance: !1,
                        start: 0
                    }
                }
            }
        }
        return r
    }
    function Xo(i) {
        var e, t, r;
        let s = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g
          , n = /@group\((\d+)\)/
          , a = /@binding\((\d+)\)/
          , o = /var(<[^>]+>)? (\w+)/
          , l = /:\s*(\w+)/
          , u = /struct\s+(\w+)\s*{([^}]+)}/g
          , d = /(\w+)\s*:\s*([\w\<\>]+)/g
          , f = /struct\s+(\w+)/
          , b = (e = i.match(s)) == null ? void 0 : e.map(x => ({
            group: parseInt(x.match(n)[1], 10),
            binding: parseInt(x.match(a)[1], 10),
            name: x.match(o)[2],
            isUniform: x.match(o)[1] === "<uniform>",
            type: x.match(l)[1]
        }));
        if (!b)
            return {
                groups: [],
                structs: []
            };
        let m = (r = (t = i.match(u)) == null ? void 0 : t.map(x => {
            let v = x.match(f)[1]
              , S = x.match(d).reduce( (w, E) => {
                let[P,C] = E.split(":");
                return w[P.trim()] = C.trim(),
                w
            }
            , {});
            return S ? {
                name: v,
                members: S
            } : null
        }
        ).filter( ({name: x}) => b.some(v => v.type === x))) != null ? r : [];
        return {
            groups: b,
            structs: m
        }
    }
    var Qr = (i => (i[i.VERTEX = 1] = "VERTEX",
    i[i.FRAGMENT = 2] = "FRAGMENT",
    i[i.COMPUTE = 4] = "COMPUTE",
    i))(Qr || {});
    function j2({groups: i}) {
        let e = [];
        for (let t = 0; t < i.length; t++) {
            let r = i[t];
            e[r.group] || (e[r.group] = []),
            r.isUniform ? e[r.group].push({
                binding: r.binding,
                visibility: Qr.VERTEX | Qr.FRAGMENT,
                buffer: {
                    type: "uniform"
                }
            }) : r.type === "sampler" ? e[r.group].push({
                binding: r.binding,
                visibility: Qr.FRAGMENT,
                sampler: {
                    type: "filtering"
                }
            }) : r.type === "texture_2d" && e[r.group].push({
                binding: r.binding,
                visibility: Qr.FRAGMENT,
                texture: {
                    sampleType: "float",
                    viewDimension: "2d",
                    multisampled: !1
                }
            })
        }
        return e
    }
    function H2({groups: i}) {
        let e = [];
        for (let t = 0; t < i.length; t++) {
            let r = i[t];
            e[r.group] || (e[r.group] = {}),
            e[r.group][r.name] = r.binding
        }
        return e
    }
    function z2(i, e) {
        let t = new Set
          , r = new Set
          , s = [...i.structs, ...e.structs].filter(a => t.has(a.name) ? !1 : (t.add(a.name),
        !0))
          , n = [...i.groups, ...e.groups].filter(a => {
            let o = `${a.name}-${a.binding}`;
            return r.has(o) ? !1 : (r.add(o),
            !0)
        }
        );
        return {
            structs: s,
            groups: n
        }
    }
    var Nr = Object.create(null)
      , ni = class i {
        constructor(e) {
            this._layoutKey = 0,
            this._attributeLocationsKey = 0;
            var t, r;
            let {fragment: s, vertex: n, layout: a, gpuLayout: o, name: l} = e;
            if (this.name = l,
            this.fragment = s,
            this.vertex = n,
            s.source === n.source) {
                let u = Xo(s.source);
                this.structsAndGroups = u
            } else {
                let u = Xo(n.source)
                  , d = Xo(s.source);
                this.structsAndGroups = z2(u, d)
            }
            this.layout = a ?? H2(this.structsAndGroups),
            this.gpuLayout = o ?? j2(this.structsAndGroups),
            this.autoAssignGlobalUniforms = ((t = this.layout[0]) == null ? void 0 : t.globalUniforms) !== void 0,
            this.autoAssignLocalUniforms = ((r = this.layout[1]) == null ? void 0 : r.localUniforms) !== void 0,
            this._generateProgramKey()
        }
        _generateProgramKey() {
            let {vertex: e, fragment: t} = this
              , r = e.source + t.source + e.entryPoint + t.entryPoint;
            this._layoutKey = bs(r, "program")
        }
        get attributeData() {
            var e;
            return (e = this._attributeData) != null || (this._attributeData = X2(this.vertex)),
            this._attributeData
        }
        destroy() {
            this.gpuLayout = null,
            this.layout = null,
            this.structsAndGroups = null,
            this.fragment = null,
            this.vertex = null,
            Nr[this._cacheKey] = null
        }
        static from(e) {
            let t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
            return Nr[t] || (Nr[t] = new i(e),
            Nr[t]._cacheKey = t),
            Nr[t]
        }
    }
    ;
    function dd(i, e, t) {
        if (i)
            for (let r in i) {
                let s = r.toLocaleLowerCase()
                  , n = e[s];
                if (n) {
                    let a = i[r];
                    r === "header" && (a = a.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")),
                    t && n.push(`//----${t}----//`),
                    n.push(a)
                }
            }
    }
    var V2 = /\{\{(.*?)\}\}/g;
    function fd(i) {
        var e, t;
        let r = {};
        return ((t = (e = i.match(V2)) == null ? void 0 : e.map(s => s.replace(/[{()}]/g, ""))) != null ? t : []).forEach(s => {
            r[s] = []
        }
        ),
        r
    }
    function pd(i, e) {
        let t, r = /@in\s+([^;]+);/g;
        for (; (t = r.exec(i)) !== null; )
            e.push(t[1])
    }
    function bd(i, e, t=!1) {
        let r = [];
        pd(e, r),
        i.forEach(o => {
            o.header && pd(o.header, r)
        }
        );
        let s = r;
        t && s.sort();
        let n = s.map( (o, l) => `       @location(${l}) ${o},`).join(`
`)
          , a = e.replace(/@in\s+[^;]+;\s*/g, "");
        return a = a.replace("{{in}}", `
${n}
`),
        a
    }
    function md(i, e) {
        let t, r = /@out\s+([^;]+);/g;
        for (; (t = r.exec(i)) !== null; )
            e.push(t[1])
    }
    function W2(i) {
        let e = /\b(\w+)\s*:/g.exec(i);
        return e ? e[1] : ""
    }
    function Y2(i) {
        let e = /@.*?\s+/g;
        return i.replace(e, "")
    }
    function $2(i, e) {
        let t = [];
        md(e, t),
        i.forEach(l => {
            l.header && md(l.header, t)
        }
        );
        let r = 0
          , s = t.sort().map(l => l.indexOf("builtin") > -1 ? l : `@location(${r++}) ${l}`).join(`,
`)
          , n = t.sort().map(l => `       var ${Y2(l)};`).join(`
`)
          , a = `return VSOutput(
            ${t.sort().map(l => ` ${W2(l)}`).join(`,
`)});`
          , o = e.replace(/@out\s+[^;]+;\s*/g, "");
        return o = o.replace("{{struct}}", `
${s}
`),
        o = o.replace("{{start}}", `
${n}
`),
        o = o.replace("{{return}}", `
${a}
`),
        o
    }
    function gd(i, e) {
        let t = i;
        for (let r in e) {
            let s = e[r];
            s.join(`
`).length ? t = t.replace(`{{${r}}}`, `//-----${r} START-----//
${s.join(`
`)}
//----${r} FINISH----//`) : t = t.replace(`{{${r}}}`, "")
        }
        return t
    }
    var Yi = Object.create(null)
      , jo = new Map
      , K2 = 0;
    function q2({template: i, bits: e}) {
        let t = Sb(i, e);
        if (Yi[t])
            return Yi[t];
        let {vertex: r, fragment: s} = Q2(i, e);
        return Yi[t] = wb(r, s, e),
        Yi[t]
    }
    function Z2({template: i, bits: e}) {
        let t = Sb(i, e);
        return Yi[t] || (Yi[t] = wb(i.vertex, i.fragment, e)),
        Yi[t]
    }
    function Q2(i, e) {
        let t = e.map(a => a.vertex).filter(a => !!a)
          , r = e.map(a => a.fragment).filter(a => !!a)
          , s = bd(t, i.vertex, !0);
        s = $2(t, s);
        let n = bd(r, i.fragment, !0);
        return {
            vertex: s,
            fragment: n
        }
    }
    function Sb(i, e) {
        return e.map(t => (jo.has(t) || jo.set(t, K2++),
        jo.get(t))).sort( (t, r) => t - r).join("-") + i.vertex + i.fragment
    }
    function wb(i, e, t) {
        let r = fd(i)
          , s = fd(e);
        return t.forEach(n => {
            dd(n.vertex, r, n.name),
            dd(n.fragment, s, n.name)
        }
        ),
        {
            vertex: gd(i, r),
            fragment: gd(e, s)
        }
    }
    var J2 = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
      , ex = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
      , tx = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
      , ix = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`
      , rx = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
    };
    var sx = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        }
    }
      , nx = Object.defineProperty
      , _d = Object.getOwnPropertySymbols
      , ax = Object.prototype.hasOwnProperty
      , ox = Object.prototype.propertyIsEnumerable
      , xd = (i, e, t) => e in i ? nx(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , cx = (i, e) => {
        for (var t in e || (e = {}))
            ax.call(e, t) && xd(i, t, e[t]);
        if (_d)
            for (var t of _d(e))
                ox.call(e, t) && xd(i, t, e[t]);
        return i
    }
    ;
    function Ps({bits: i, name: e}) {
        let t = q2({
            template: {
                fragment: ex,
                vertex: J2
            },
            bits: [rx, ...i]
        });
        return ni.from({
            name: e,
            vertex: {
                source: t.vertex,
                entryPoint: "main"
            },
            fragment: {
                source: t.fragment,
                entryPoint: "main"
            }
        })
    }
    function Rs({bits: i, name: e}) {
        return new yi(cx({
            name: e
        }, Z2({
            template: {
                vertex: tx,
                fragment: ix
            },
            bits: [sx, ...i]
        })))
    }
    var Mh = {
        name: "color-bit",
        vertex: {
            header: `
            @in aColor: vec4<f32>;
        `,
            main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
    }
      , Ch = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
    }
      , Ho = {};
    function lx(i) {
        let e = [];
        if (i === 1)
            e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),
            e.push("@group(1) @binding(1) var textureSampler1: sampler;");
        else {
            let t = 0;
            for (let r = 0; r < i; r++)
                e.push(`@group(1) @binding(${t++}) var textureSource${r + 1}: texture_2d<f32>;`),
                e.push(`@group(1) @binding(${t++}) var textureSampler${r + 1}: sampler;`)
        }
        return e.join(`
`)
    }
    function hx(i) {
        let e = [];
        if (i === 1)
            e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
        else {
            e.push("switch vTextureId {");
            for (let t = 0; t < i; t++)
                t === i - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`),
                e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`),
                e.push("      break;}");
            e.push("}")
        }
        return e.join(`
`)
    }
    function Oh(i) {
        return Ho[i] || (Ho[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
            },
            fragment: {
                header: `
                @in @interpolate(flat) vTextureId: u32;

                ${lx(i)}
            `,
                main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${hx(i)}
            `
            }
        }),
        Ho[i]
    }
    var zo = {};
    function ux(i) {
        let e = [];
        for (let t = 0; t < i; t++)
            t > 0 && e.push("else"),
            t < i - 1 && e.push(`if(vTextureId < ${t}.5)`),
            e.push("{"),
            e.push(`	outColor = texture(uTextures[${t}], vUV);`),
            e.push("}");
        return e.join(`
`)
    }
    function Ih(i) {
        return zo[i] || (zo[i] = {
            name: "texture-batch-bit",
            vertex: {
                header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
                main: `
                vTextureId = aTextureIdAndRound.y;
            `,
                end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
            },
            fragment: {
                header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
                main: `

                ${ux(i)}
            `
            }
        }),
        zo[i]
    }
    var Ms = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    }
      , Cs = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    }
      , Ab = ["f32", "i32", "vec2<f32>", "vec3<f32>", "vec4<f32>", "mat2x2<f32>", "mat3x3<f32>", "mat4x4<f32>", "mat3x2<f32>", "mat4x2<f32>", "mat2x3<f32>", "mat4x3<f32>", "mat2x4<f32>", "mat3x4<f32>", "vec2<i32>", "vec3<i32>", "vec4<i32>"]
      , dx = Ab.reduce( (i, e) => (i[e] = !0,
    i), {});
    function fx(i, e) {
        switch (i) {
        case "f32":
            return 0;
        case "vec2<f32>":
            return new Float32Array(2 * e);
        case "vec3<f32>":
            return new Float32Array(3 * e);
        case "vec4<f32>":
            return new Float32Array(4 * e);
        case "mat2x2<f32>":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3x3<f32>":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4x4<f32>":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
        }
        return null
    }
    var px = Object.defineProperty
      , yd = Object.getOwnPropertySymbols
      , bx = Object.prototype.hasOwnProperty
      , mx = Object.prototype.propertyIsEnumerable
      , vd = (i, e, t) => e in i ? px(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Td = (i, e) => {
        for (var t in e || (e = {}))
            bx.call(e, t) && vd(i, t, e[t]);
        if (yd)
            for (var t of yd(e))
                mx.call(e, t) && vd(i, t, e[t]);
        return i
    }
      , Eb = class Pb {
        constructor(e, t) {
            this._touched = 0,
            this.uid = Le("uniform"),
            this._resourceType = "uniformGroup",
            this._resourceId = Le("resource"),
            this.isUniformGroup = !0,
            this._dirtyId = 0,
            this.destroyed = !1;
            var r, s;
            t = Td(Td({}, Pb.defaultOptions), t),
            this.uniformStructures = e;
            let n = {};
            for (let a in e) {
                let o = e[a];
                if (o.name = a,
                o.size = (r = o.size) != null ? r : 1,
                !dx[o.type]) {
                    let l = o.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
                    if (l) {
                        let[,u,d] = l;
                        throw new Error(`Uniform type ${o.type} is not supported. Use type: '${u}', size: ${d} instead.`)
                    }
                    throw new Error(`Uniform type ${o.type} is not supported. Supported uniform types are: ${Ab.join(", ")}`)
                }
                (s = o.value) != null || (o.value = fx(o.type, o.size)),
                n[a] = o.value
            }
            this.uniforms = n,
            this._dirtyId = 1,
            this.ubo = t.ubo,
            this.isStatic = t.isStatic,
            this._signature = bs(Object.keys(n).map(a => `${a}-${e[a].type}`).join("-"), "uniform-group")
        }
        update() {
            this._dirtyId++
        }
    }
    ;
    Eb.defaultOptions = {
        ubo: !1,
        isStatic: !1
    };
    var ot = Eb
      , Sd = {};
    function Gh(i) {
        let e = Sd[i];
        if (e)
            return e;
        let t = new Int32Array(i);
        for (let r = 0; r < i; r++)
            t[r] = r;
        return e = Sd[i] = new ot({
            uTextures: {
                value: t,
                type: "i32",
                size: i
            }
        },{
            isStatic: !0
        }),
        e
    }
    var Ct = (i => (i[i.WEBGL = 1] = "WEBGL",
    i[i.WEBGPU = 2] = "WEBGPU",
    i[i.BOTH = 3] = "BOTH",
    i))(Ct || {})
      , gx = Object.defineProperty
      , Cn = Object.getOwnPropertySymbols
      , Rb = Object.prototype.hasOwnProperty
      , Mb = Object.prototype.propertyIsEnumerable
      , wd = (i, e, t) => e in i ? gx(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , _x = (i, e) => {
        for (var t in e || (e = {}))
            Rb.call(e, t) && wd(i, t, e[t]);
        if (Cn)
            for (var t of Cn(e))
                Mb.call(e, t) && wd(i, t, e[t]);
        return i
    }
      , xx = (i, e) => {
        var t = {};
        for (var r in i)
            Rb.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && Cn)
            for (var r of Cn(i))
                e.indexOf(r) < 0 && Mb.call(i, r) && (t[r] = i[r]);
        return t
    }
      , vt = class i extends Ot {
        constructor(e) {
            super(),
            this.uid = Le("shader"),
            this._uniformBindMap = Object.create(null),
            this._ownedBindGroups = [];
            let {gpuProgram: t, glProgram: r, groups: s, resources: n, compatibleRenderers: a, groupMap: o} = e;
            this.gpuProgram = t,
            this.glProgram = r,
            a === void 0 && (a = 0,
            t && (a |= Ct.WEBGPU),
            r && (a |= Ct.WEBGL)),
            this.compatibleRenderers = a;
            let l = {};
            if (!n && !s && (n = {}),
            n && s)
                throw new Error("[Shader] Cannot have both resources and groups");
            if (!t && s && !o)
                throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
            if (!t && s && o)
                for (let u in o)
                    for (let d in o[u]) {
                        let f = o[u][d];
                        l[f] = {
                            group: u,
                            binding: d,
                            name: f
                        }
                    }
            else if (t && s && !o) {
                let u = t.structsAndGroups.groups;
                o = {},
                u.forEach(d => {
                    o[d.group] = o[d.group] || {},
                    o[d.group][d.binding] = d.name,
                    l[d.name] = d
                }
                )
            } else if (n) {
                s = {},
                o = {},
                t && t.structsAndGroups.groups.forEach(d => {
                    o[d.group] = o[d.group] || {},
                    o[d.group][d.binding] = d.name,
                    l[d.name] = d
                }
                );
                let u = 0;
                for (let d in n)
                    l[d] || (s[99] || (s[99] = new Yt,
                    this._ownedBindGroups.push(s[99])),
                    l[d] = {
                        group: 99,
                        binding: u,
                        name: d
                    },
                    o[99] = o[99] || {},
                    o[99][u] = d,
                    u++);
                for (let d in n) {
                    let f = d
                      , b = n[d];
                    !b.source && !b._resourceType && (b = new ot(b));
                    let m = l[f];
                    m && (s[m.group] || (s[m.group] = new Yt,
                    this._ownedBindGroups.push(s[m.group])),
                    s[m.group].setResource(b, m.binding))
                }
            }
            this.groups = s,
            this._uniformBindMap = o,
            this.resources = this._buildResourceAccessor(s, l)
        }
        addResource(e, t, r) {
            var s, n;
            (s = this._uniformBindMap)[t] || (s[t] = {}),
            (n = this._uniformBindMap[t])[r] || (n[r] = e),
            this.groups[t] || (this.groups[t] = new Yt,
            this._ownedBindGroups.push(this.groups[t]))
        }
        _buildResourceAccessor(e, t) {
            let r = {};
            for (let s in t) {
                let n = t[s];
                Object.defineProperty(r, n.name, {
                    get() {
                        return e[n.group].getResource(n.binding)
                    },
                    set(a) {
                        e[n.group].setResource(a, n.binding)
                    }
                })
            }
            return r
        }
        destroy(e=!1) {
            var t, r;
            this.emit("destroy", this),
            e && ((t = this.gpuProgram) == null || t.destroy(),
            (r = this.glProgram) == null || r.destroy()),
            this.gpuProgram = null,
            this.glProgram = null,
            this.removeAllListeners(),
            this._uniformBindMap = null,
            this._ownedBindGroups.forEach(s => {
                s.destroy()
            }
            ),
            this._ownedBindGroups = null,
            this.resources = null,
            this.groups = null
        }
        static from(e) {
            let t = e, {gpu: r, gl: s} = t, n = xx(t, ["gpu", "gl"]), a, o;
            return r && (a = ni.from(r)),
            s && (o = yi.from(s)),
            new i(_x({
                gpuProgram: a,
                glProgram: o
            }, n))
        }
    }
      , Zc = class extends vt {
        constructor(e) {
            let t = Rs({
                name: "batch",
                bits: [Ch, Ih(e), Cs]
            })
              , r = Ps({
                name: "batch",
                bits: [Mh, Oh(e), Ms]
            });
            super({
                glProgram: t,
                gpuProgram: r,
                resources: {
                    batchSamplers: Gh(e)
                }
            })
        }
    }
      , Vo = null
      , Cb = class Ob extends w2 {
        constructor(e) {
            super(e),
            this.geometry = new Kc,
            this.name = Ob.extension.name,
            this.vertexSize = 6,
            Vo != null || (Vo = new Zc(e.maxTextures)),
            this.shader = Vo
        }
        packAttributes(e, t, r, s, n) {
            let a = n << 16 | e.roundPixels & 65535
              , o = e.transform
              , l = o.a
              , u = o.b
              , d = o.c
              , f = o.d
              , b = o.tx
              , m = o.ty
              , {positions: x, uvs: v} = e
              , S = e.color
              , w = e.attributeOffset
              , E = w + e.attributeSize;
            for (let P = w; P < E; P++) {
                let C = P * 2
                  , L = x[C]
                  , F = x[C + 1];
                t[s++] = l * L + d * F + b,
                t[s++] = f * F + u * L + m,
                t[s++] = v[C],
                t[s++] = v[C + 1],
                r[s++] = S,
                r[s++] = a
            }
        }
        packQuadAttributes(e, t, r, s, n) {
            let a = e.texture
              , o = e.transform
              , l = o.a
              , u = o.b
              , d = o.c
              , f = o.d
              , b = o.tx
              , m = o.ty
              , x = e.bounds
              , v = x.maxX
              , S = x.minX
              , w = x.maxY
              , E = x.minY
              , P = a.uvs
              , C = e.color
              , L = n << 16 | e.roundPixels & 65535;
            t[s + 0] = l * S + d * E + b,
            t[s + 1] = f * E + u * S + m,
            t[s + 2] = P.x0,
            t[s + 3] = P.y0,
            r[s + 4] = C,
            r[s + 5] = L,
            t[s + 6] = l * v + d * E + b,
            t[s + 7] = f * E + u * v + m,
            t[s + 8] = P.x1,
            t[s + 9] = P.y1,
            r[s + 10] = C,
            r[s + 11] = L,
            t[s + 12] = l * v + d * w + b,
            t[s + 13] = f * w + u * v + m,
            t[s + 14] = P.x2,
            t[s + 15] = P.y2,
            r[s + 16] = C,
            r[s + 17] = L,
            t[s + 18] = l * S + d * w + b,
            t[s + 19] = f * w + u * S + m,
            t[s + 20] = P.x3,
            t[s + 21] = P.y3,
            r[s + 22] = C,
            r[s + 23] = L
        }
    }
    ;
    Cb.extension = {
        type: [O.Batcher],
        name: "default"
    };
    var Bh = Cb;
    function yx(i, e, t, r, s, n, a, o=null) {
        let l = 0;
        t *= e,
        s *= n;
        let u = o.a
          , d = o.b
          , f = o.c
          , b = o.d
          , m = o.tx
          , x = o.ty;
        for (; l < a; ) {
            let v = i[t]
              , S = i[t + 1];
            r[s] = u * v + f * S + m,
            r[s + 1] = d * v + b * S + x,
            s += n,
            t += e,
            l++
        }
    }
    function vx(i, e, t, r) {
        let s = 0;
        for (e *= t; s < r; )
            i[e] = 0,
            i[e + 1] = 0,
            e += t,
            s++
    }
    function Ib(i, e, t, r, s) {
        let n = e.a
          , a = e.b
          , o = e.c
          , l = e.d
          , u = e.tx
          , d = e.ty;
        t || (t = 0),
        r || (r = 2),
        s || (s = i.length / r - t);
        let f = t * r;
        for (let b = 0; b < s; b++) {
            let m = i[f]
              , x = i[f + 1];
            i[f] = n * m + o * x + u,
            i[f + 1] = a * m + l * x + d,
            f += r
        }
    }
    var Tx = new ce
      , ms = class {
        constructor() {
            this.packAsQuad = !1,
            this.batcherName = "default",
            this.topology = "triangle-list",
            this.applyTransform = !0,
            this.roundPixels = 0,
            this._batcher = null,
            this._batch = null
        }
        get uvs() {
            return this.geometryData.uvs
        }
        get positions() {
            return this.geometryData.vertices
        }
        get indices() {
            return this.geometryData.indices
        }
        get blendMode() {
            return this.renderable && this.applyTransform ? this.renderable.groupBlendMode : "normal"
        }
        get color() {
            let e = this.baseColor
              , t = e >> 16 | e & 65280 | (e & 255) << 16
              , r = this.renderable;
            return r ? Y0(t, r.groupColor) + (this.alpha * r.groupAlpha * 255 << 24) : t + (this.alpha * 255 << 24)
        }
        get transform() {
            var e;
            return ((e = this.renderable) == null ? void 0 : e.groupTransform) || Tx
        }
        copyTo(e) {
            e.indexOffset = this.indexOffset,
            e.indexSize = this.indexSize,
            e.attributeOffset = this.attributeOffset,
            e.attributeSize = this.attributeSize,
            e.baseColor = this.baseColor,
            e.alpha = this.alpha,
            e.texture = this.texture,
            e.geometryData = this.geometryData,
            e.topology = this.topology
        }
        reset() {
            this.applyTransform = !0,
            this.renderable = null,
            this.topology = "triangle-list"
        }
        destroy() {
            this.renderable = null,
            this.texture = null,
            this.geometryData = null,
            this._batcher.destroy(),
            this._batcher = null,
            this._batch.destroy(),
            this._batch = null
        }
    }
      , Sx = Object.defineProperty
      , wx = Object.defineProperties
      , Ax = Object.getOwnPropertyDescriptors
      , Ad = Object.getOwnPropertySymbols
      , Ex = Object.prototype.hasOwnProperty
      , Px = Object.prototype.propertyIsEnumerable
      , Ed = (i, e, t) => e in i ? Sx(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , On = (i, e) => {
        for (var t in e || (e = {}))
            Ex.call(e, t) && Ed(i, t, e[t]);
        if (Ad)
            for (var t of Ad(e))
                Px.call(e, t) && Ed(i, t, e[t]);
        return i
    }
      , In = (i, e) => wx(i, Ax(e))
      , gs = {
        extension: {
            type: O.ShapeBuilder,
            name: "circle"
        },
        build(i, e) {
            let t, r, s, n, a, o;
            if (i.type === "circle") {
                let C = i;
                if (a = o = C.radius,
                a <= 0)
                    return !1;
                t = C.x,
                r = C.y,
                s = n = 0
            } else if (i.type === "ellipse") {
                let C = i;
                if (a = C.halfWidth,
                o = C.halfHeight,
                a <= 0 || o <= 0)
                    return !1;
                t = C.x,
                r = C.y,
                s = n = 0
            } else {
                let C = i
                  , L = C.width / 2
                  , F = C.height / 2;
                t = C.x + L,
                r = C.y + F,
                a = o = Math.max(0, Math.min(C.radius, Math.min(L, F))),
                s = L - a,
                n = F - o
            }
            if (s < 0 || n < 0)
                return !1;
            let l = Math.ceil(2.3 * Math.sqrt(a + o))
              , u = l * 8 + (s ? 4 : 0) + (n ? 4 : 0);
            if (u === 0)
                return !1;
            if (l === 0)
                return e[0] = e[6] = t + s,
                e[1] = e[3] = r + n,
                e[2] = e[4] = t - s,
                e[5] = e[7] = r - n,
                !0;
            let d = 0
              , f = l * 4 + (s ? 2 : 0) + 2
              , b = f
              , m = u
              , x = s + a
              , v = n
              , S = t + x
              , w = t - x
              , E = r + v;
            if (e[d++] = S,
            e[d++] = E,
            e[--f] = E,
            e[--f] = w,
            n) {
                let C = r - v;
                e[b++] = w,
                e[b++] = C,
                e[--m] = C,
                e[--m] = S
            }
            for (let C = 1; C < l; C++) {
                let L = Math.PI / 2 * (C / l)
                  , F = s + Math.cos(L) * a
                  , X = n + Math.sin(L) * o
                  , ie = t + F
                  , te = t - F
                  , V = r + X
                  , K = r - X;
                e[d++] = ie,
                e[d++] = V,
                e[--f] = V,
                e[--f] = te,
                e[b++] = te,
                e[b++] = K,
                e[--m] = K,
                e[--m] = ie
            }
            x = s,
            v = n + o,
            S = t + x,
            w = t - x,
            E = r + v;
            let P = r - v;
            return e[d++] = S,
            e[d++] = E,
            e[--m] = P,
            e[--m] = S,
            s && (e[d++] = w,
            e[d++] = E,
            e[--m] = P,
            e[--m] = w),
            !0
        },
        triangulate(i, e, t, r, s, n) {
            if (i.length === 0)
                return;
            let a = 0
              , o = 0;
            for (let d = 0; d < i.length; d += 2)
                a += i[d],
                o += i[d + 1];
            a /= i.length / 2,
            o /= i.length / 2;
            let l = r;
            e[l * t] = a,
            e[l * t + 1] = o;
            let u = l++;
            for (let d = 0; d < i.length; d += 2)
                e[l * t] = i[d],
                e[l * t + 1] = i[d + 1],
                d > 0 && (s[n++] = l,
                s[n++] = u,
                s[n++] = l - 1),
                l++;
            s[n++] = u + 1,
            s[n++] = u,
            s[n++] = l - 1
        }
    }
      , Rx = In(On({}, gs), {
        extension: In(On({}, gs.extension), {
            name: "ellipse"
        })
    })
      , Mx = In(On({}, gs), {
        extension: In(On({}, gs.extension), {
            name: "roundedRectangle"
        })
    })
      , Gb = 1e-4
      , Pd = 1e-4;
    function Cx(i) {
        let e = i.length;
        if (e < 6)
            return 1;
        let t = 0;
        for (let r = 0, s = i[e - 2], n = i[e - 1]; r < e; r += 2) {
            let a = i[r]
              , o = i[r + 1];
            t += (a - s) * (o + n),
            s = a,
            n = o
        }
        return t < 0 ? -1 : 1
    }
    function Rd(i, e, t, r, s, n, a, o) {
        let l = i - t * s, u = e - r * s, d = i + t * n, f = e + r * n, b, m;
        a ? (b = r,
        m = -t) : (b = -r,
        m = t);
        let x = l + b
          , v = u + m
          , S = d + b
          , w = f + m;
        return o.push(x, v),
        o.push(S, w),
        2
    }
    function Ui(i, e, t, r, s, n, a, o) {
        let l = t - i
          , u = r - e
          , d = Math.atan2(l, u)
          , f = Math.atan2(s - i, n - e);
        o && d < f ? d += Math.PI * 2 : !o && d > f && (f += Math.PI * 2);
        let b = d
          , m = f - d
          , x = Math.abs(m)
          , v = Math.sqrt(l * l + u * u)
          , S = (15 * x * Math.sqrt(v) / Math.PI >> 0) + 1
          , w = m / S;
        if (b += w,
        o) {
            a.push(i, e),
            a.push(t, r);
            for (let E = 1, P = b; E < S; E++,
            P += w)
                a.push(i, e),
                a.push(i + Math.sin(P) * v, e + Math.cos(P) * v);
            a.push(i, e),
            a.push(s, n)
        } else {
            a.push(t, r),
            a.push(i, e);
            for (let E = 1, P = b; E < S; E++,
            P += w)
                a.push(i + Math.sin(P) * v, e + Math.cos(P) * v),
                a.push(i, e);
            a.push(s, n),
            a.push(i, e)
        }
        return S * 2
    }
    function Ox(i, e, t, r, s, n) {
        let a = Gb;
        if (i.length === 0)
            return;
        let o = e
          , l = o.alignment;
        if (e.alignment !== .5) {
            let Re = Cx(i);
            t && (Re *= -1),
            l = (l - .5) * Re + .5
        }
        let u = new Ue(i[0],i[1])
          , d = new Ue(i[i.length - 2],i[i.length - 1])
          , f = r
          , b = Math.abs(u.x - d.x) < a && Math.abs(u.y - d.y) < a;
        if (f) {
            i = i.slice(),
            b && (i.pop(),
            i.pop(),
            d.set(i[i.length - 2], i[i.length - 1]));
            let Re = (u.x + d.x) * .5
              , mt = (d.y + u.y) * .5;
            i.unshift(Re, mt),
            i.push(Re, mt)
        }
        let m = s
          , x = i.length / 2
          , v = i.length
          , S = m.length / 2
          , w = o.width / 2
          , E = w * w
          , P = o.miterLimit * o.miterLimit
          , C = i[0]
          , L = i[1]
          , F = i[2]
          , X = i[3]
          , ie = 0
          , te = 0
          , V = -(L - X)
          , K = C - F
          , W = 0
          , J = 0
          , he = Math.sqrt(V * V + K * K);
        V /= he,
        K /= he,
        V *= w,
        K *= w;
        let je = l
          , re = (1 - je) * 2
          , ne = je * 2;
        f || (o.cap === "round" ? v += Ui(C - V * (re - ne) * .5, L - K * (re - ne) * .5, C - V * re, L - K * re, C + V * ne, L + K * ne, m, !0) + 2 : o.cap === "square" && (v += Rd(C, L, V, K, re, ne, !0, m))),
        m.push(C - V * re, L - K * re),
        m.push(C + V * ne, L + K * ne);
        for (let Re = 1; Re < x - 1; ++Re) {
            C = i[(Re - 1) * 2],
            L = i[(Re - 1) * 2 + 1],
            F = i[Re * 2],
            X = i[Re * 2 + 1],
            ie = i[(Re + 1) * 2],
            te = i[(Re + 1) * 2 + 1],
            V = -(L - X),
            K = C - F,
            he = Math.sqrt(V * V + K * K),
            V /= he,
            K /= he,
            V *= w,
            K *= w,
            W = -(X - te),
            J = F - ie,
            he = Math.sqrt(W * W + J * J),
            W /= he,
            J /= he,
            W *= w,
            J *= w;
            let mt = F - C
              , Qe = L - X
              , It = F - ie
              , gt = te - X
              , wi = mt * It + Qe * gt
              , et = Qe * It - gt * mt
              , Gt = et < 0;
            if (Math.abs(et) < .001 * Math.abs(wi)) {
                m.push(F - V * re, X - K * re),
                m.push(F + V * ne, X + K * ne),
                wi >= 0 && (o.join === "round" ? v += Ui(F, X, F - V * re, X - K * re, F - W * re, X - J * re, m, !1) + 4 : v += 2,
                m.push(F - W * ne, X - J * ne),
                m.push(F + W * re, X + J * re));
                continue
            }
            let Ne = (-V + C) * (-K + X) - (-V + F) * (-K + L)
              , ti = (-W + ie) * (-J + X) - (-W + F) * (-J + te)
              , Bt = (mt * ti - It * Ne) / et
              , it = (gt * Ne - Qe * ti) / et
              , ee = (Bt - F) * (Bt - F) + (it - X) * (it - X)
              , xe = F + (Bt - F) * re
              , Me = X + (it - X) * re
              , ut = F - (Bt - F) * ne
              , Ft = X - (it - X) * ne
              , ir = Math.min(mt * mt + Qe * Qe, It * It + gt * gt)
              , Fi = Gt ? re : ne
              , rr = ir + Fi * Fi * E;
            ee <= rr ? o.join === "bevel" || ee / E > P ? (Gt ? (m.push(xe, Me),
            m.push(F + V * ne, X + K * ne),
            m.push(xe, Me),
            m.push(F + W * ne, X + J * ne)) : (m.push(F - V * re, X - K * re),
            m.push(ut, Ft),
            m.push(F - W * re, X - J * re),
            m.push(ut, Ft)),
            v += 2) : o.join === "round" ? Gt ? (m.push(xe, Me),
            m.push(F + V * ne, X + K * ne),
            v += Ui(F, X, F + V * ne, X + K * ne, F + W * ne, X + J * ne, m, !0) + 4,
            m.push(xe, Me),
            m.push(F + W * ne, X + J * ne)) : (m.push(F - V * re, X - K * re),
            m.push(ut, Ft),
            v += Ui(F, X, F - V * re, X - K * re, F - W * re, X - J * re, m, !1) + 4,
            m.push(F - W * re, X - J * re),
            m.push(ut, Ft)) : (m.push(xe, Me),
            m.push(ut, Ft)) : (m.push(F - V * re, X - K * re),
            m.push(F + V * ne, X + K * ne),
            o.join === "round" ? Gt ? v += Ui(F, X, F + V * ne, X + K * ne, F + W * ne, X + J * ne, m, !0) + 2 : v += Ui(F, X, F - V * re, X - K * re, F - W * re, X - J * re, m, !1) + 2 : o.join === "miter" && ee / E <= P && (Gt ? (m.push(ut, Ft),
            m.push(ut, Ft)) : (m.push(xe, Me),
            m.push(xe, Me)),
            v += 2),
            m.push(F - W * re, X - J * re),
            m.push(F + W * ne, X + J * ne),
            v += 2)
        }
        C = i[(x - 2) * 2],
        L = i[(x - 2) * 2 + 1],
        F = i[(x - 1) * 2],
        X = i[(x - 1) * 2 + 1],
        V = -(L - X),
        K = C - F,
        he = Math.sqrt(V * V + K * K),
        V /= he,
        K /= he,
        V *= w,
        K *= w,
        m.push(F - V * re, X - K * re),
        m.push(F + V * ne, X + K * ne),
        f || (o.cap === "round" ? v += Ui(F - V * (re - ne) * .5, X - K * (re - ne) * .5, F - V * re, X - K * re, F + V * ne, X + K * ne, m, !1) + 2 : o.cap === "square" && (v += Rd(F, X, V, K, re, ne, !1, m)));
        let ei = Pd * Pd;
        for (let Re = S; Re < v + S - 2; ++Re)
            C = m[Re * 2],
            L = m[Re * 2 + 1],
            F = m[(Re + 1) * 2],
            X = m[(Re + 1) * 2 + 1],
            ie = m[(Re + 2) * 2],
            te = m[(Re + 2) * 2 + 1],
            !(Math.abs(C * (X - te) + F * (te - L) + ie * (L - X)) < ei) && n.push(Re, Re + 1, Re + 2)
    }
    function Ix(i, e, t, r) {
        let s = Gb;
        if (i.length === 0)
            return;
        let n = i[0]
          , a = i[1]
          , o = i[i.length - 2]
          , l = i[i.length - 1]
          , u = e || Math.abs(n - o) < s && Math.abs(a - l) < s
          , d = t
          , f = i.length / 2
          , b = d.length / 2;
        for (let m = 0; m < f; m++)
            d.push(i[m * 2]),
            d.push(i[m * 2 + 1]);
        for (let m = 0; m < f - 1; m++)
            r.push(b + m, b + m + 1);
        u && r.push(b + f - 1, b)
    }
    function Md(i, e, t=2) {
        let r = e && e.length
          , s = r ? e[0] * t : i.length
          , n = Bb(i, 0, s, t, !0)
          , a = [];
        if (!n || n.next === n.prev)
            return a;
        let o, l, u;
        if (r && (n = kx(i, e, n, t)),
        i.length > 80 * t) {
            o = i[0],
            l = i[1];
            let d = o
              , f = l;
            for (let b = t; b < s; b += t) {
                let m = i[b]
                  , x = i[b + 1];
                m < o && (o = m),
                x < l && (l = x),
                m > d && (d = m),
                x > f && (f = x)
            }
            u = Math.max(d - o, f - l),
            u = u !== 0 ? 32767 / u : 0
        }
        return _s(n, a, t, o, l, u, 0),
        a
    }
    function Bb(i, e, t, r, s) {
        let n;
        if (s === $x(i, e, t, r) > 0)
            for (let a = e; a < t; a += r)
                n = Cd(a / r | 0, i[a], i[a + 1], n);
        else
            for (let a = t - r; a >= e; a -= r)
                n = Cd(a / r | 0, i[a], i[a + 1], n);
        return n && Sr(n, n.next) && (ys(n),
        n = n.next),
        n
    }
    function qi(i, e) {
        if (!i)
            return i;
        e || (e = i);
        let t = i, r;
        do
            if (r = !1,
            !t.steiner && (Sr(t, t.next) || Ve(t.prev, t, t.next) === 0)) {
                if (ys(t),
                t = e = t.prev,
                t === t.next)
                    break;
                r = !0
            } else
                t = t.next;
        while (r || t !== e);
        return e
    }
    function _s(i, e, t, r, s, n, a) {
        if (!i)
            return;
        !a && n && jx(i, r, s, n);
        let o = i;
        for (; i.prev !== i.next; ) {
            let l = i.prev
              , u = i.next;
            if (n ? Bx(i, r, s, n) : Gx(i)) {
                e.push(l.i, i.i, u.i),
                ys(i),
                i = u.next,
                o = u.next;
                continue
            }
            if (i = u,
            i === o) {
                a ? a === 1 ? (i = Fx(qi(i), e),
                _s(i, e, t, r, s, n, 2)) : a === 2 && Dx(i, e, t, r, s, n) : _s(qi(i), e, t, r, s, n, 1);
                break
            }
        }
    }
    function Gx(i) {
        let e = i.prev
          , t = i
          , r = i.next;
        if (Ve(e, t, r) >= 0)
            return !1;
        let s = e.x
          , n = t.x
          , a = r.x
          , o = e.y
          , l = t.y
          , u = r.y
          , d = Math.min(s, n, a)
          , f = Math.min(o, l, u)
          , b = Math.max(s, n, a)
          , m = Math.max(o, l, u)
          , x = r.next;
        for (; x !== e; ) {
            if (x.x >= d && x.x <= b && x.y >= f && x.y <= m && Jr(s, o, n, l, a, u, x.x, x.y) && Ve(x.prev, x, x.next) >= 0)
                return !1;
            x = x.next
        }
        return !0
    }
    function Bx(i, e, t, r) {
        let s = i.prev
          , n = i
          , a = i.next;
        if (Ve(s, n, a) >= 0)
            return !1;
        let o = s.x
          , l = n.x
          , u = a.x
          , d = s.y
          , f = n.y
          , b = a.y
          , m = Math.min(o, l, u)
          , x = Math.min(d, f, b)
          , v = Math.max(o, l, u)
          , S = Math.max(d, f, b)
          , w = Qc(m, x, e, t, r)
          , E = Qc(v, S, e, t, r)
          , P = i.prevZ
          , C = i.nextZ;
        for (; P && P.z >= w && C && C.z <= E; ) {
            if (P.x >= m && P.x <= v && P.y >= x && P.y <= S && P !== s && P !== a && Jr(o, d, l, f, u, b, P.x, P.y) && Ve(P.prev, P, P.next) >= 0 || (P = P.prevZ,
            C.x >= m && C.x <= v && C.y >= x && C.y <= S && C !== s && C !== a && Jr(o, d, l, f, u, b, C.x, C.y) && Ve(C.prev, C, C.next) >= 0))
                return !1;
            C = C.nextZ
        }
        for (; P && P.z >= w; ) {
            if (P.x >= m && P.x <= v && P.y >= x && P.y <= S && P !== s && P !== a && Jr(o, d, l, f, u, b, P.x, P.y) && Ve(P.prev, P, P.next) >= 0)
                return !1;
            P = P.prevZ
        }
        for (; C && C.z <= E; ) {
            if (C.x >= m && C.x <= v && C.y >= x && C.y <= S && C !== s && C !== a && Jr(o, d, l, f, u, b, C.x, C.y) && Ve(C.prev, C, C.next) >= 0)
                return !1;
            C = C.nextZ
        }
        return !0
    }
    function Fx(i, e) {
        let t = i;
        do {
            let r = t.prev
              , s = t.next.next;
            !Sr(r, s) && Db(r, t, t.next, s) && xs(r, s) && xs(s, r) && (e.push(r.i, t.i, s.i),
            ys(t),
            ys(t.next),
            t = i = s),
            t = t.next
        } while (t !== i);
        return qi(t)
    }
    function Dx(i, e, t, r, s, n) {
        let a = i;
        do {
            let o = a.next.next;
            for (; o !== a.prev; ) {
                if (a.i !== o.i && Vx(a, o)) {
                    let l = kb(a, o);
                    a = qi(a, a.next),
                    l = qi(l, l.next),
                    _s(a, e, t, r, s, n, 0),
                    _s(l, e, t, r, s, n, 0);
                    return
                }
                o = o.next
            }
            a = a.next
        } while (a !== i)
    }
    function kx(i, e, t, r) {
        let s = [];
        for (let n = 0, a = e.length; n < a; n++) {
            let o = e[n] * r
              , l = n < a - 1 ? e[n + 1] * r : i.length
              , u = Bb(i, o, l, r, !1);
            u === u.next && (u.steiner = !0),
            s.push(zx(u))
        }
        s.sort(Ux);
        for (let n = 0; n < s.length; n++)
            t = Lx(s[n], t);
        return t
    }
    function Ux(i, e) {
        let t = i.x - e.x;
        if (t === 0 && (t = i.y - e.y,
        t === 0)) {
            let r = (i.next.y - i.y) / (i.next.x - i.x)
              , s = (e.next.y - e.y) / (e.next.x - e.x);
            t = r - s
        }
        return t
    }
    function Lx(i, e) {
        let t = Nx(i, e);
        if (!t)
            return e;
        let r = kb(t, i);
        return qi(r, r.next),
        qi(t, t.next)
    }
    function Nx(i, e) {
        let t = e, r = i.x, s = i.y, n = -1 / 0, a;
        if (Sr(i, t))
            return t;
        do {
            if (Sr(i, t.next))
                return t.next;
            if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
                let f = t.x + (s - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
                if (f <= r && f > n && (n = f,
                a = t.x < t.next.x ? t : t.next,
                f === r))
                    return a
            }
            t = t.next
        } while (t !== e);
        if (!a)
            return null;
        let o = a
          , l = a.x
          , u = a.y
          , d = 1 / 0;
        t = a;
        do {
            if (r >= t.x && t.x >= l && r !== t.x && Fb(s < u ? r : n, s, l, u, s < u ? n : r, s, t.x, t.y)) {
                let f = Math.abs(s - t.y) / (r - t.x);
                xs(t, i) && (f < d || f === d && (t.x > a.x || t.x === a.x && Xx(a, t))) && (a = t,
                d = f)
            }
            t = t.next
        } while (t !== o);
        return a
    }
    function Xx(i, e) {
        return Ve(i.prev, i, e.prev) < 0 && Ve(e.next, i, i.next) < 0
    }
    function jx(i, e, t, r) {
        let s = i;
        do
            s.z === 0 && (s.z = Qc(s.x, s.y, e, t, r)),
            s.prevZ = s.prev,
            s.nextZ = s.next,
            s = s.next;
        while (s !== i);
        s.prevZ.nextZ = null,
        s.prevZ = null,
        Hx(s)
    }
    function Hx(i) {
        let e, t = 1;
        do {
            let r = i, s;
            i = null;
            let n = null;
            for (e = 0; r; ) {
                e++;
                let a = r
                  , o = 0;
                for (let u = 0; u < t && (o++,
                a = a.nextZ,
                !!a); u++)
                    ;
                let l = t;
                for (; o > 0 || l > 0 && a; )
                    o !== 0 && (l === 0 || !a || r.z <= a.z) ? (s = r,
                    r = r.nextZ,
                    o--) : (s = a,
                    a = a.nextZ,
                    l--),
                    n ? n.nextZ = s : i = s,
                    s.prevZ = n,
                    n = s;
                r = a
            }
            n.nextZ = null,
            t *= 2
        } while (e > 1);
        return i
    }
    function Qc(i, e, t, r, s) {
        return i = (i - t) * s | 0,
        e = (e - r) * s | 0,
        i = (i | i << 8) & 16711935,
        i = (i | i << 4) & 252645135,
        i = (i | i << 2) & 858993459,
        i = (i | i << 1) & 1431655765,
        e = (e | e << 8) & 16711935,
        e = (e | e << 4) & 252645135,
        e = (e | e << 2) & 858993459,
        e = (e | e << 1) & 1431655765,
        i | e << 1
    }
    function zx(i) {
        let e = i
          , t = i;
        do
            (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
            e = e.next;
        while (e !== i);
        return t
    }
    function Fb(i, e, t, r, s, n, a, o) {
        return (s - a) * (e - o) >= (i - a) * (n - o) && (i - a) * (r - o) >= (t - a) * (e - o) && (t - a) * (n - o) >= (s - a) * (r - o)
    }
    function Jr(i, e, t, r, s, n, a, o) {
        return !(i === a && e === o) && Fb(i, e, t, r, s, n, a, o)
    }
    function Vx(i, e) {
        return i.next.i !== e.i && i.prev.i !== e.i && !Wx(i, e) && (xs(i, e) && xs(e, i) && Yx(i, e) && (Ve(i.prev, i, e.prev) || Ve(i, e.prev, e)) || Sr(i, e) && Ve(i.prev, i, i.next) > 0 && Ve(e.prev, e, e.next) > 0)
    }
    function Ve(i, e, t) {
        return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y)
    }
    function Sr(i, e) {
        return i.x === e.x && i.y === e.y
    }
    function Db(i, e, t, r) {
        let s = Ws(Ve(i, e, t))
          , n = Ws(Ve(i, e, r))
          , a = Ws(Ve(t, r, i))
          , o = Ws(Ve(t, r, e));
        return !!(s !== n && a !== o || s === 0 && Vs(i, t, e) || n === 0 && Vs(i, r, e) || a === 0 && Vs(t, i, r) || o === 0 && Vs(t, e, r))
    }
    function Vs(i, e, t) {
        return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y)
    }
    function Ws(i) {
        return i > 0 ? 1 : i < 0 ? -1 : 0
    }
    function Wx(i, e) {
        let t = i;
        do {
            if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && Db(t, t.next, i, e))
                return !0;
            t = t.next
        } while (t !== i);
        return !1
    }
    function xs(i, e) {
        return Ve(i.prev, i, i.next) < 0 ? Ve(i, e, i.next) >= 0 && Ve(i, i.prev, e) >= 0 : Ve(i, e, i.prev) < 0 || Ve(i, i.next, e) < 0
    }
    function Yx(i, e) {
        let t = i
          , r = !1
          , s = (i.x + e.x) / 2
          , n = (i.y + e.y) / 2;
        do
            t.y > n != t.next.y > n && t.next.y !== t.y && s < (t.next.x - t.x) * (n - t.y) / (t.next.y - t.y) + t.x && (r = !r),
            t = t.next;
        while (t !== i);
        return r
    }
    function kb(i, e) {
        let t = Jc(i.i, i.x, i.y)
          , r = Jc(e.i, e.x, e.y)
          , s = i.next
          , n = e.prev;
        return i.next = e,
        e.prev = i,
        t.next = s,
        s.prev = t,
        r.next = t,
        t.prev = r,
        n.next = r,
        r.prev = n,
        r
    }
    function Cd(i, e, t, r) {
        let s = Jc(i, e, t);
        return r ? (s.next = r.next,
        s.prev = r,
        r.next.prev = s,
        r.next = s) : (s.prev = s,
        s.next = s),
        s
    }
    function ys(i) {
        i.next.prev = i.prev,
        i.prev.next = i.next,
        i.prevZ && (i.prevZ.nextZ = i.nextZ),
        i.nextZ && (i.nextZ.prevZ = i.prevZ)
    }
    function Jc(i, e, t) {
        return {
            i,
            x: e,
            y: t,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
        }
    }
    function $x(i, e, t, r) {
        let s = 0;
        for (let n = e, a = t - r; n < t; n += r)
            s += (i[a] - i[n]) * (i[n + 1] + i[a + 1]),
            a = n;
        return s
    }
    var Kx = Md.default || Md;
    function Ub(i, e, t, r, s, n, a) {
        let o = Kx(i, e, 2);
        if (!o)
            return;
        for (let u = 0; u < o.length; u += 3)
            n[a++] = o[u] + s,
            n[a++] = o[u + 1] + s,
            n[a++] = o[u + 2] + s;
        let l = s * r;
        for (let u = 0; u < i.length; u += 2)
            t[l] = i[u],
            t[l + 1] = i[u + 1],
            l += r
    }
    var qx = []
      , Zx = {
        extension: {
            type: O.ShapeBuilder,
            name: "polygon"
        },
        build(i, e) {
            for (let t = 0; t < i.points.length; t++)
                e[t] = i.points[t];
            return !0
        },
        triangulate(i, e, t, r, s, n) {
            Ub(i, qx, e, t, r, s, n)
        }
    }
      , Qx = {
        extension: {
            type: O.ShapeBuilder,
            name: "rectangle"
        },
        build(i, e) {
            let t = i
              , r = t.x
              , s = t.y
              , n = t.width
              , a = t.height;
            return n > 0 && a > 0 ? (e[0] = r,
            e[1] = s,
            e[2] = r + n,
            e[3] = s,
            e[4] = r + n,
            e[5] = s + a,
            e[6] = r,
            e[7] = s + a,
            !0) : !1
        },
        triangulate(i, e, t, r, s, n) {
            let a = 0;
            r *= t,
            e[r + a] = i[0],
            e[r + a + 1] = i[1],
            a += t,
            e[r + a] = i[2],
            e[r + a + 1] = i[3],
            a += t,
            e[r + a] = i[6],
            e[r + a + 1] = i[7],
            a += t,
            e[r + a] = i[4],
            e[r + a + 1] = i[5],
            a += t;
            let o = r / t;
            s[n++] = o,
            s[n++] = o + 1,
            s[n++] = o + 2,
            s[n++] = o + 1,
            s[n++] = o + 3,
            s[n++] = o + 2
        }
    }
      , Jx = {
        extension: {
            type: O.ShapeBuilder,
            name: "triangle"
        },
        build(i, e) {
            return e[0] = i.x,
            e[1] = i.y,
            e[2] = i.x2,
            e[3] = i.y2,
            e[4] = i.x3,
            e[5] = i.y3,
            !0
        },
        triangulate(i, e, t, r, s, n) {
            let a = 0;
            r *= t,
            e[r + a] = i[0],
            e[r + a + 1] = i[1],
            a += t,
            e[r + a] = i[2],
            e[r + a + 1] = i[3],
            a += t,
            e[r + a] = i[4],
            e[r + a + 1] = i[5];
            let o = r / t;
            s[n++] = o,
            s[n++] = o + 1,
            s[n++] = o + 2
        }
    }
      , ey = Object.defineProperty
      , Od = Object.getOwnPropertySymbols
      , ty = Object.prototype.hasOwnProperty
      , iy = Object.prototype.propertyIsEnumerable
      , Id = (i, e, t) => e in i ? ey(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Gd = (i, e) => {
        for (var t in e || (e = {}))
            ty.call(e, t) && Id(i, t, e[t]);
        if (Od)
            for (var t of Od(e))
                iy.call(e, t) && Id(i, t, e[t]);
        return i
    }
      , Bd = [{
        offset: 0,
        color: "white"
    }, {
        offset: 1,
        color: "black"
    }]
      , el = class tl {
        constructor(...e) {
            this.uid = Le("fillGradient"),
            this._tick = 0,
            this.type = "linear",
            this.colorStops = [];
            var t;
            let r = ry(e)
              , s = r.type === "radial" ? tl.defaultRadialOptions : tl.defaultLinearOptions;
            r = Gd(Gd({}, s), vr(r)),
            this._textureSize = r.textureSize,
            this._wrapMode = r.wrapMode,
            r.type === "radial" ? (this.center = r.center,
            this.outerCenter = (t = r.outerCenter) != null ? t : this.center,
            this.innerRadius = r.innerRadius,
            this.outerRadius = r.outerRadius,
            this.scale = r.scale,
            this.rotation = r.rotation) : (this.start = r.start,
            this.end = r.end),
            this.textureSpace = r.textureSpace,
            this.type = r.type,
            r.colorStops.forEach(n => {
                this.addColorStop(n.offset, n.color)
            }
            )
        }
        addColorStop(e, t) {
            return this.colorStops.push({
                offset: e,
                color: Be.shared.setValue(t).toHexa()
            }),
            this
        }
        buildLinearGradient() {
            if (this.texture)
                return;
            let {x: e, y: t} = this.start
              , {x: r, y: s} = this.end
              , n = r - e
              , a = s - t
              , o = n < 0 || a < 0;
            if (this._wrapMode === "clamp-to-edge") {
                if (n < 0) {
                    let S = e;
                    e = r,
                    r = S,
                    n *= -1
                }
                if (a < 0) {
                    let S = t;
                    t = s,
                    s = S,
                    a *= -1
                }
            }
            let l = this.colorStops.length ? this.colorStops : Bd
              , u = this._textureSize
              , {canvas: d, context: f} = Dd(u, 1)
              , b = o ? f.createLinearGradient(this._textureSize, 0, 0, 0) : f.createLinearGradient(0, 0, this._textureSize, 0);
            Fd(b, l),
            f.fillStyle = b,
            f.fillRect(0, 0, u, 1),
            this.texture = new Z({
                source: new mi({
                    resource: d,
                    addressMode: this._wrapMode
                })
            });
            let m = Math.sqrt(n * n + a * a)
              , x = Math.atan2(a, n)
              , v = new ce;
            v.scale(m / u, 1),
            v.rotate(x),
            v.translate(e, t),
            this.textureSpace === "local" && v.scale(u, u),
            this.transform = v
        }
        buildGradient() {
            this.texture || this._tick++,
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient()
        }
        buildRadialGradient() {
            if (this.texture)
                return;
            let e = this.colorStops.length ? this.colorStops : Bd
              , t = this._textureSize
              , {canvas: r, context: s} = Dd(t, t)
              , {x: n, y: a} = this.center
              , {x: o, y: l} = this.outerCenter
              , u = this.innerRadius
              , d = this.outerRadius
              , f = o - d
              , b = l - d
              , m = t / (d * 2)
              , x = (n - f) * m
              , v = (a - b) * m
              , S = s.createRadialGradient(x, v, u * m, (o - f) * m, (l - b) * m, d * m);
            Fd(S, e),
            s.fillStyle = e[e.length - 1].color,
            s.fillRect(0, 0, t, t),
            s.fillStyle = S,
            s.translate(x, v),
            s.rotate(this.rotation),
            s.scale(1, this.scale),
            s.translate(-x, -v),
            s.fillRect(0, 0, t, t),
            this.texture = new Z({
                source: new mi({
                    resource: r,
                    addressMode: this._wrapMode
                })
            });
            let w = new ce;
            w.scale(1 / m, 1 / m),
            w.translate(f, b),
            this.textureSpace === "local" && w.scale(t, t),
            this.transform = w
        }
        destroy() {
            var e;
            (e = this.texture) == null || e.destroy(!0),
            this.texture = null,
            this.transform = null,
            this.colorStops = [],
            this.start = null,
            this.end = null,
            this.center = null,
            this.outerCenter = null
        }
        get styleKey() {
            return `fill-gradient-${this.uid}-${this._tick}`
        }
    }
    ;
    el.defaultLinearOptions = {
        start: {
            x: 0,
            y: 0
        },
        end: {
            x: 0,
            y: 1
        },
        colorStops: [],
        textureSpace: "local",
        type: "linear",
        textureSize: 256,
        wrapMode: "clamp-to-edge"
    },
    el.defaultRadialOptions = {
        center: {
            x: .5,
            y: .5
        },
        innerRadius: 0,
        outerRadius: .5,
        colorStops: [],
        scale: 1,
        textureSpace: "local",
        type: "radial",
        textureSize: 256,
        wrapMode: "clamp-to-edge"
    };
    var gi = el;
    function Fd(i, e) {
        for (let t = 0; t < e.length; t++) {
            let r = e[t];
            i.addColorStop(r.offset, r.color)
        }
    }
    function Dd(i, e) {
        let t = ye.get().createCanvas(i, e)
          , r = t.getContext("2d");
        return {
            canvas: t,
            context: r
        }
    }
    function ry(i) {
        var e, t;
        let r = (e = i[0]) != null ? e : {};
        return (typeof r == "number" || i[1]) && (r = {
            type: "linear",
            start: {
                x: i[0],
                y: i[1]
            },
            end: {
                x: i[2],
                y: i[3]
            },
            textureSpace: i[4],
            textureSize: (t = i[5]) != null ? t : gi.defaultLinearOptions.textureSize
        }),
        r
    }
    var sy = new ce
      , ny = new Oe;
    function ay(i, e, t, r) {
        let s = e.matrix ? i.copyFrom(e.matrix).invert() : i.identity();
        if (e.textureSpace === "local") {
            let a = t.getBounds(ny);
            e.width && a.pad(e.width);
            let {x: o, y: l} = a
              , u = 1 / a.width
              , d = 1 / a.height
              , f = -o * u
              , b = -l * d
              , m = s.a
              , x = s.b
              , v = s.c
              , S = s.d;
            s.a *= u,
            s.b *= u,
            s.c *= d,
            s.d *= d,
            s.tx = f * m + b * v + s.tx,
            s.ty = f * x + b * S + s.ty
        } else
            s.translate(e.texture.frame.x, e.texture.frame.y),
            s.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
        let n = e.texture.source.style;
        return !(e.fill instanceof gi) && n.addressMode === "clamp-to-edge" && (n.addressMode = "repeat",
        n.update()),
        r && s.append(sy.copyFrom(r).invert()),
        s
    }
    var po = {};
    be.handleByMap(O.ShapeBuilder, po),
    be.add(Qx, Zx, Jx, gs, Rx, Mx);
    var oy = new Oe
      , cy = new ce;
    function ly(i, e) {
        let {geometryData: t, batches: r} = e;
        r.length = 0,
        t.indices.length = 0,
        t.vertices.length = 0,
        t.uvs.length = 0;
        for (let s = 0; s < i.instructions.length; s++) {
            let n = i.instructions[s];
            if (n.action === "texture")
                hy(n.data, r, t);
            else if (n.action === "fill" || n.action === "stroke") {
                let a = n.action === "stroke"
                  , o = n.data.path.shapePath
                  , l = n.data.style
                  , u = n.data.hole;
                a && u && kd(u.shapePath, l, !0, r, t),
                u && (o.shapePrimitives[o.shapePrimitives.length - 1].holes = u.shapePath.shapePrimitives),
                kd(o, l, a, r, t)
            }
        }
    }
    function hy(i, e, t) {
        let r = []
          , s = po.rectangle
          , n = oy;
        n.x = i.dx,
        n.y = i.dy,
        n.width = i.dw,
        n.height = i.dh;
        let a = i.transform;
        if (!s.build(n, r))
            return;
        let {vertices: o, uvs: l, indices: u} = t
          , d = u.length
          , f = o.length / 2;
        a && Ib(r, a),
        s.triangulate(r, o, 2, f, u, d);
        let b = i.image
          , m = b.uvs;
        l.push(m.x0, m.y0, m.x1, m.y1, m.x3, m.y3, m.x2, m.y2);
        let x = Je.get(ms);
        x.indexOffset = d,
        x.indexSize = u.length - d,
        x.attributeOffset = f,
        x.attributeSize = o.length / 2 - f,
        x.baseColor = i.style,
        x.alpha = i.alpha,
        x.texture = b,
        x.geometryData = t,
        e.push(x)
    }
    function kd(i, e, t, r, s) {
        let {vertices: n, uvs: a, indices: o} = s;
        i.shapePrimitives.forEach( ({shape: l, transform: u, holes: d}) => {
            var f;
            let b = []
              , m = po[l.type];
            if (!m.build(l, b))
                return;
            let x = o.length
              , v = n.length / 2
              , S = "triangle-list";
            if (u && Ib(b, u),
            t) {
                let C = (f = l.closePath) != null ? f : !0
                  , L = e;
                L.pixelLine ? (Ix(b, C, n, o),
                S = "line-list") : Ox(b, L, !1, C, n, o)
            } else if (d) {
                let C = []
                  , L = b.slice();
                uy(d).forEach(F => {
                    C.push(L.length / 2),
                    L.push(...F)
                }
                ),
                Ub(L, C, n, 2, v, o, x)
            } else
                m.triangulate(b, n, 2, v, o, x);
            let w = a.length / 2
              , E = e.texture;
            if (E !== Z.WHITE) {
                let C = ay(cy, e, l, u);
                yx(n, 2, v, a, w, 2, n.length / 2 - v, C)
            } else
                vx(a, w, 2, n.length / 2 - v);
            let P = Je.get(ms);
            P.indexOffset = x,
            P.indexSize = o.length - x,
            P.attributeOffset = v,
            P.attributeSize = n.length / 2 - v,
            P.baseColor = e.color,
            P.alpha = e.alpha,
            P.texture = E,
            P.geometryData = s,
            P.topology = S,
            r.push(P)
        }
        )
    }
    function uy(i) {
        let e = [];
        for (let t = 0; t < i.length; t++) {
            let r = i[t].shape
              , s = [];
            po[r.type].build(r, s) && e.push(s)
        }
        return e
    }
    var il = class {
        constructor() {
            this.batches = [],
            this.geometryData = {
                vertices: [],
                uvs: [],
                indices: []
            }
        }
    }
      , rl = class {
        constructor() {
            this.instructions = new mn
        }
        init(e) {
            this.batcher = new Bh({
                maxTextures: e
            }),
            this.instructions.reset()
        }
        get geometry() {
            return this.batcher.geometry
        }
        destroy() {
            this.batcher.destroy(),
            this.instructions.destroy(),
            this.batcher = null,
            this.instructions = null
        }
    }
      , sl = class nl {
        constructor(e) {
            this._gpuContextHash = {},
            this._graphicsDataContextHash = Object.create(null),
            this._renderer = e,
            e.renderableGC.addManagedHash(this, "_gpuContextHash"),
            e.renderableGC.addManagedHash(this, "_graphicsDataContextHash")
        }
        init(e) {
            var t;
            nl.defaultOptions.bezierSmoothness = (t = e?.bezierSmoothness) != null ? t : nl.defaultOptions.bezierSmoothness
        }
        getContextRenderData(e) {
            return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e)
        }
        updateGpuContext(e) {
            let t = this._gpuContextHash[e.uid] || this._initContext(e);
            if (e.dirty) {
                t ? this._cleanGraphicsContextData(e) : t = this._initContext(e),
                ly(e, t);
                let r = e.batchMode;
                e.customShader || r === "no-batch" ? t.isBatchable = !1 : r === "auto" ? t.isBatchable = t.geometryData.vertices.length < 400 : t.isBatchable = !0,
                e.dirty = !1
            }
            return t
        }
        getGpuContext(e) {
            return this._gpuContextHash[e.uid] || this._initContext(e)
        }
        _initContextRenderData(e) {
            let t = Je.get(rl, {
                maxTextures: this._renderer.limits.maxBatchableTextures
            })
              , {batches: r, geometryData: s} = this._gpuContextHash[e.uid]
              , n = s.vertices.length
              , a = s.indices.length;
            for (let d = 0; d < r.length; d++)
                r[d].applyTransform = !1;
            let o = t.batcher;
            o.ensureAttributeBuffer(n),
            o.ensureIndexBuffer(a),
            o.begin();
            for (let d = 0; d < r.length; d++) {
                let f = r[d];
                o.add(f)
            }
            o.finish(t.instructions);
            let l = o.geometry;
            l.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0),
            l.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, !0);
            let u = o.batches;
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                f.bindGroup = Rh(f.textures.textures, f.textures.count, this._renderer.limits.maxBatchableTextures)
            }
            return this._graphicsDataContextHash[e.uid] = t,
            t
        }
        _initContext(e) {
            let t = new il;
            return t.context = e,
            this._gpuContextHash[e.uid] = t,
            e.on("destroy", this.onGraphicsContextDestroy, this),
            this._gpuContextHash[e.uid]
        }
        onGraphicsContextDestroy(e) {
            this._cleanGraphicsContextData(e),
            e.off("destroy", this.onGraphicsContextDestroy, this),
            this._gpuContextHash[e.uid] = null
        }
        _cleanGraphicsContextData(e) {
            let t = this._gpuContextHash[e.uid];
            t.isBatchable || this._graphicsDataContextHash[e.uid] && (Je.return(this.getContextRenderData(e)),
            this._graphicsDataContextHash[e.uid] = null),
            t.batches && t.batches.forEach(r => {
                Je.return(r)
            }
            )
        }
        destroy() {
            for (let e in this._gpuContextHash)
                this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context)
        }
    }
    ;
    sl.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "graphicsContext"
    },
    sl.defaultOptions = {
        bezierSmoothness: .5
    };
    var Fh = sl
      , dy = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
    }
      , Wo = 0
      , Yo = 1
      , $o = 2
      , Ko = 3
      , qo = 4
      , Zo = 5
      , al = class Lb {
        constructor() {
            this.data = 0,
            this.blendMode = "normal",
            this.polygonOffset = 0,
            this.blend = !0,
            this.depthMask = !0
        }
        get blend() {
            return !!(this.data & 1 << Wo)
        }
        set blend(e) {
            !!(this.data & 1 << Wo) !== e && (this.data ^= 1 << Wo)
        }
        get offsets() {
            return !!(this.data & 1 << Yo)
        }
        set offsets(e) {
            !!(this.data & 1 << Yo) !== e && (this.data ^= 1 << Yo)
        }
        set cullMode(e) {
            if (e === "none") {
                this.culling = !1;
                return
            }
            this.culling = !0,
            this.clockwiseFrontFace = e === "front"
        }
        get cullMode() {
            return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none"
        }
        get culling() {
            return !!(this.data & 1 << $o)
        }
        set culling(e) {
            !!(this.data & 1 << $o) !== e && (this.data ^= 1 << $o)
        }
        get depthTest() {
            return !!(this.data & 1 << Ko)
        }
        set depthTest(e) {
            !!(this.data & 1 << Ko) !== e && (this.data ^= 1 << Ko)
        }
        get depthMask() {
            return !!(this.data & 1 << Zo)
        }
        set depthMask(e) {
            !!(this.data & 1 << Zo) !== e && (this.data ^= 1 << Zo)
        }
        get clockwiseFrontFace() {
            return !!(this.data & 1 << qo)
        }
        set clockwiseFrontFace(e) {
            !!(this.data & 1 << qo) !== e && (this.data ^= 1 << qo)
        }
        get blendMode() {
            return this._blendMode
        }
        set blendMode(e) {
            this.blend = e !== "none",
            this._blendMode = e,
            this._blendModeId = dy[e] || 0
        }
        get polygonOffset() {
            return this._polygonOffset
        }
        set polygonOffset(e) {
            this.offsets = !!e,
            this._polygonOffset = e
        }
        static for2d() {
            let e = new Lb;
            return e.depthTest = !1,
            e.blend = !0,
            e
        }
    }
    ;
    al.default2d = al.for2d();
    var Ut = al;
    function Os(i, e, t) {
        let r = (i >> 24 & 255) / 255;
        e[t++] = (i & 255) / 255 * r,
        e[t++] = (i >> 8 & 255) / 255 * r,
        e[t++] = (i >> 16 & 255) / 255 * r,
        e[t++] = r
    }
    var ol = class {
        constructor() {
            this.batches = [],
            this.batched = !1
        }
        destroy() {
            this.batches.forEach(e => {
                Je.return(e)
            }
            ),
            this.batches.length = 0
        }
    }
      , Gn = class {
        constructor(e, t) {
            this.state = Ut.for2d(),
            this.renderer = e,
            this._adaptor = t,
            this.renderer.runners.contextChange.add(this)
        }
        contextChange() {
            this._adaptor.contextChange(this.renderer)
        }
        validateRenderable(e) {
            let t = e.context
              , r = !!e._gpuData
              , s = this.renderer.graphicsContext.updateGpuContext(t);
            return !!(s.isBatchable || r !== s.isBatchable)
        }
        addRenderable(e, t) {
            let r = this.renderer.graphicsContext.updateGpuContext(e.context);
            e.didViewUpdate && this._rebuild(e),
            r.isBatchable ? this._addToBatcher(e, t) : (this.renderer.renderPipes.batch.break(t),
            t.add(e))
        }
        updateRenderable(e) {
            let t = this._getGpuDataForRenderable(e).batches;
            for (let r = 0; r < t.length; r++) {
                let s = t[r];
                s._batcher.updateElement(s)
            }
        }
        execute(e) {
            if (!e.isRenderable)
                return;
            let t = this.renderer
              , r = e.context;
            if (!t.graphicsContext.getGpuContext(r).batches.length)
                return;
            let s = r.customShader || this._adaptor.shader;
            this.state.blendMode = e.groupBlendMode;
            let n = s.resources.localUniforms.uniforms;
            n.uTransformMatrix = e.groupTransform,
            n.uRound = t._roundPixels | e._roundPixels,
            Os(e.groupColorAlpha, n.uColor, 0),
            this._adaptor.execute(this, e)
        }
        _rebuild(e) {
            let t = this._getGpuDataForRenderable(e)
              , r = this.renderer.graphicsContext.updateGpuContext(e.context);
            t.destroy(),
            r.isBatchable && this._updateBatchesForRenderable(e, t)
        }
        _addToBatcher(e, t) {
            let r = this.renderer.renderPipes.batch
              , s = this._getGpuDataForRenderable(e).batches;
            for (let n = 0; n < s.length; n++) {
                let a = s[n];
                r.addToBatch(a, t)
            }
        }
        _getGpuDataForRenderable(e) {
            return e._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(e)
        }
        _initGpuDataForRenderable(e) {
            let t = new ol;
            return e._gpuData[this.renderer.uid] = t,
            t
        }
        _updateBatchesForRenderable(e, t) {
            let r = e.context
              , s = this.renderer.graphicsContext.getGpuContext(r)
              , n = this.renderer._roundPixels | e._roundPixels;
            t.batches = s.batches.map(a => {
                let o = Je.get(ms);
                return a.copyTo(o),
                o.renderable = e,
                o.roundPixels = n,
                o
            }
            )
        }
        destroy() {
            this.renderer = null,
            this._adaptor.destroy(),
            this._adaptor = null,
            this.state = null
        }
    }
    ;
    Gn.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "graphics"
    },
    be.add(Gn),
    be.add(Fh);
    var vs = class {
        constructor() {
            this.batcherName = "default",
            this.packAsQuad = !1,
            this.indexOffset = 0,
            this.attributeOffset = 0,
            this.roundPixels = 0,
            this._batcher = null,
            this._batch = null,
            this._textureMatrixUpdateId = -1,
            this._uvUpdateId = -1
        }
        get blendMode() {
            return this.renderable.groupBlendMode
        }
        get topology() {
            return this._topology || this.geometry.topology
        }
        set topology(e) {
            this._topology = e
        }
        reset() {
            this.renderable = null,
            this.texture = null,
            this._batcher = null,
            this._batch = null,
            this.geometry = null,
            this._uvUpdateId = -1,
            this._textureMatrixUpdateId = -1
        }
        setTexture(e) {
            this.texture !== e && (this.texture = e,
            this._textureMatrixUpdateId = -1)
        }
        get uvs() {
            let e = this.geometry.getBuffer("aUV")
              , t = e.data
              , r = t
              , s = this.texture.textureMatrix;
            return s.isSimple || (r = this._transformedUvs,
            (this._textureMatrixUpdateId !== s._updateID || this._uvUpdateId !== e._updateID) && ((!r || r.length < t.length) && (r = this._transformedUvs = new Float32Array(t.length)),
            this._textureMatrixUpdateId = s._updateID,
            this._uvUpdateId = e._updateID,
            s.multiplyUvs(t, r))),
            r
        }
        get positions() {
            return this.geometry.positions
        }
        get indices() {
            return this.geometry.indices
        }
        get color() {
            return this.renderable.groupColorAlpha
        }
        get groupTransform() {
            return this.renderable.groupTransform
        }
        get attributeSize() {
            return this.geometry.positions.length / 2
        }
        get indexSize() {
            return this.geometry.indices.length
        }
    }
      , Bn = class {
        destroy() {}
    }
      , Fn = class {
        constructor(e, t) {
            this.localUniforms = new ot({
                uTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }),
            this.localUniformsBindGroup = new Yt({
                0: this.localUniforms
            }),
            this.renderer = e,
            this._adaptor = t,
            this._adaptor.init()
        }
        validateRenderable(e) {
            let t = this._getMeshData(e)
              , r = t.batched
              , s = e.batched;
            if (t.batched = s,
            r !== s)
                return !0;
            if (s) {
                let n = e._geometry;
                if (n.indices.length !== t.indexSize || n.positions.length !== t.vertexSize)
                    return t.indexSize = n.indices.length,
                    t.vertexSize = n.positions.length,
                    !0;
                let a = this._getBatchableMesh(e);
                return a.texture.uid !== e._texture.uid && (a._textureMatrixUpdateId = -1),
                !a._batcher.checkAndUpdateTexture(a, e._texture)
            }
            return !1
        }
        addRenderable(e, t) {
            var r, s;
            let n = this.renderer.renderPipes.batch
              , a = this._getMeshData(e);
            if (e.didViewUpdate && (a.indexSize = (r = e._geometry.indices) == null ? void 0 : r.length,
            a.vertexSize = (s = e._geometry.positions) == null ? void 0 : s.length),
            a.batched) {
                let o = this._getBatchableMesh(e);
                o.setTexture(e._texture),
                o.geometry = e._geometry,
                n.addToBatch(o, t)
            } else
                n.break(t),
                t.add(e)
        }
        updateRenderable(e) {
            if (e.batched) {
                let t = this._getBatchableMesh(e);
                t.setTexture(e._texture),
                t.geometry = e._geometry,
                t._batcher.updateElement(t)
            }
        }
        execute(e) {
            if (!e.isRenderable)
                return;
            e.state.blendMode = ps(e.groupBlendMode, e.texture._source);
            let t = this.localUniforms;
            t.uniforms.uTransformMatrix = e.groupTransform,
            t.uniforms.uRound = this.renderer._roundPixels | e._roundPixels,
            t.update(),
            Os(e.groupColorAlpha, t.uniforms.uColor, 0),
            this._adaptor.execute(this, e)
        }
        _getMeshData(e) {
            var t, r;
            return (t = e._gpuData)[r = this.renderer.uid] || (t[r] = new Bn),
            e._gpuData[this.renderer.uid].meshData || this._initMeshData(e)
        }
        _initMeshData(e) {
            return e._gpuData[this.renderer.uid].meshData = {
                batched: e.batched,
                indexSize: 0,
                vertexSize: 0
            },
            e._gpuData[this.renderer.uid].meshData
        }
        _getBatchableMesh(e) {
            var t, r;
            return (t = e._gpuData)[r = this.renderer.uid] || (t[r] = new Bn),
            e._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(e)
        }
        _initBatchableMesh(e) {
            let t = new vs;
            return t.renderable = e,
            t.setTexture(e._texture),
            t.transform = e.groupTransform,
            t.roundPixels = this.renderer._roundPixels | e._roundPixels,
            e._gpuData[this.renderer.uid].batchableMesh = t,
            t
        }
        destroy() {
            this.localUniforms = null,
            this.localUniformsBindGroup = null,
            this._adaptor.destroy(),
            this._adaptor = null,
            this.renderer = null
        }
    }
    ;
    Fn.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "mesh"
    },
    be.add(Fn);
    var cl = class {
        execute(e, t) {
            let r = e.state
              , s = e.renderer
              , n = t.shader || e.defaultShader;
            n.resources.uTexture = t.texture._source,
            n.resources.uniforms = e.localUniforms;
            let a = s.gl
              , o = e.getBuffers(t);
            s.shader.bind(n),
            s.state.set(r),
            s.geometry.bind(o.geometry, n.glProgram);
            let l = o.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? a.UNSIGNED_SHORT : a.UNSIGNED_INT;
            a.drawElements(a.TRIANGLES, t.particleChildren.length * 6, l, 0)
        }
    }
    ;
    function Ud(i, e=null) {
        let t = i * 6;
        if (t > 65535 ? e || (e = new Uint32Array(t)) : e || (e = new Uint16Array(t)),
        e.length !== t)
            throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${t}`);
        for (let r = 0, s = 0; r < t; r += 6,
        s += 4)
            e[r + 0] = s + 0,
            e[r + 1] = s + 1,
            e[r + 2] = s + 2,
            e[r + 3] = s + 0,
            e[r + 4] = s + 2,
            e[r + 5] = s + 3;
        return e
    }
    function fy(i) {
        return {
            dynamicUpdate: Ld(i, !0),
            staticUpdate: Ld(i, !1)
        }
    }
    function Ld(i, e) {
        let t = [];
        t.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
        let r = 0;
        for (let n in i) {
            let a = i[n];
            if (e !== a.dynamic)
                continue;
            t.push(`offset = index + ${r}`),
            t.push(a.code);
            let o = Mi(a.format);
            r += o.stride / 4
        }
        t.push(`
            index += stride * 4;
        }
    `),
        t.unshift(`
        var stride = ${r};
    `);
        let s = t.join(`
`);
        return new Function("ps","f32v","u32v",s)
    }
    var ll = class {
        constructor(e) {
            this._size = 0,
            this._generateParticleUpdateCache = {};
            var t;
            let r = this._size = (t = e.size) != null ? t : 1e3
              , s = e.properties
              , n = 0
              , a = 0;
            for (let f in s) {
                let b = s[f]
                  , m = Mi(b.format);
                b.dynamic ? a += m.stride : n += m.stride
            }
            this._dynamicStride = a / 4,
            this._staticStride = n / 4,
            this.staticAttributeBuffer = new Pi(r * 4 * n),
            this.dynamicAttributeBuffer = new Pi(r * 4 * a),
            this.indexBuffer = Ud(r);
            let o = new si
              , l = 0
              , u = 0;
            this._staticBuffer = new bt({
                data: new Float32Array(1),
                label: "static-particle-buffer",
                shrinkToFit: !1,
                usage: Pe.VERTEX | Pe.COPY_DST
            }),
            this._dynamicBuffer = new bt({
                data: new Float32Array(1),
                label: "dynamic-particle-buffer",
                shrinkToFit: !1,
                usage: Pe.VERTEX | Pe.COPY_DST
            });
            for (let f in s) {
                let b = s[f]
                  , m = Mi(b.format);
                b.dynamic ? (o.addAttribute(b.attributeName, {
                    buffer: this._dynamicBuffer,
                    stride: this._dynamicStride * 4,
                    offset: l * 4,
                    format: b.format
                }),
                l += m.size) : (o.addAttribute(b.attributeName, {
                    buffer: this._staticBuffer,
                    stride: this._staticStride * 4,
                    offset: u * 4,
                    format: b.format
                }),
                u += m.size)
            }
            o.addIndex(this.indexBuffer);
            let d = this.getParticleUpdate(s);
            this._dynamicUpload = d.dynamicUpdate,
            this._staticUpload = d.staticUpdate,
            this.geometry = o
        }
        getParticleUpdate(e) {
            let t = py(e);
            return this._generateParticleUpdateCache[t] ? this._generateParticleUpdateCache[t] : (this._generateParticleUpdateCache[t] = this.generateParticleUpdate(e),
            this._generateParticleUpdateCache[t])
        }
        generateParticleUpdate(e) {
            return fy(e)
        }
        update(e, t) {
            e.length > this._size && (t = !0,
            this._size = Math.max(e.length, this._size * 1.5 | 0),
            this.staticAttributeBuffer = new Pi(this._size * this._staticStride * 4 * 4),
            this.dynamicAttributeBuffer = new Pi(this._size * this._dynamicStride * 4 * 4),
            this.indexBuffer = Ud(this._size),
            this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0));
            let r = this.dynamicAttributeBuffer;
            if (this._dynamicUpload(e, r.float32View, r.uint32View),
            this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, e.length * this._dynamicStride * 4, !0),
            t) {
                let s = this.staticAttributeBuffer;
                this._staticUpload(e, s.float32View, s.uint32View),
                this._staticBuffer.setDataWithSize(s.float32View, e.length * this._staticStride * 4, !0)
            }
        }
        destroy() {
            this._staticBuffer.destroy(),
            this._dynamicBuffer.destroy(),
            this.geometry.destroy()
        }
    }
    ;
    function py(i) {
        let e = [];
        for (let t in i) {
            let r = i[t];
            e.push(t, r.code, r.dynamic ? "d" : "s")
        }
        return e.join("_")
    }
    var by = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`
      , my = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`
      , Nd = `
struct ParticleUniforms {
  uTranslationMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uRound:f32,
  uResolution:vec2<f32>,
};

fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
{
  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

   if(uniforms.uRound == 1.0) {
       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);
   }

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`
      , hl = class extends vt {
        constructor() {
            let e = yi.from({
                vertex: my,
                fragment: by
            })
              , t = ni.from({
                fragment: {
                    source: Nd,
                    entryPoint: "mainFragment"
                },
                vertex: {
                    source: Nd,
                    entryPoint: "mainVertex"
                }
            });
            super({
                glProgram: e,
                gpuProgram: t,
                resources: {
                    uTexture: Z.WHITE.source,
                    uSampler: new kt({}),
                    uniforms: {
                        uTranslationMatrix: {
                            value: new ce,
                            type: "mat3x3<f32>"
                        },
                        uColor: {
                            value: new Be(16777215),
                            type: "vec4<f32>"
                        },
                        uRound: {
                            value: 1,
                            type: "f32"
                        },
                        uResolution: {
                            value: [0, 0],
                            type: "vec2<f32>"
                        }
                    }
                }
            })
        }
    }
      , Dn = class {
        constructor(e, t) {
            this.state = Ut.for2d(),
            this.localUniforms = new ot({
                uTranslationMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uColor: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uRound: {
                    value: 1,
                    type: "f32"
                },
                uResolution: {
                    value: [0, 0],
                    type: "vec2<f32>"
                }
            }),
            this.renderer = e,
            this.adaptor = t,
            this.defaultShader = new hl,
            this.state = Ut.for2d()
        }
        validateRenderable(e) {
            return !1
        }
        addRenderable(e, t) {
            this.renderer.renderPipes.batch.break(t),
            t.add(e)
        }
        getBuffers(e) {
            return e._gpuData[this.renderer.uid] || this._initBuffer(e)
        }
        _initBuffer(e) {
            return e._gpuData[this.renderer.uid] = new ll({
                size: e.particleChildren.length,
                properties: e._properties
            }),
            e._gpuData[this.renderer.uid]
        }
        updateRenderable(e) {}
        execute(e) {
            let t = e.particleChildren;
            if (t.length === 0)
                return;
            let r = this.renderer
              , s = this.getBuffers(e);
            e.texture || (e.texture = t[0].texture);
            let n = this.state;
            s.update(t, e._childrenDirty),
            e._childrenDirty = !1,
            n.blendMode = ps(e.blendMode, e.texture._source);
            let a = this.localUniforms.uniforms
              , o = a.uTranslationMatrix;
            e.worldTransform.copyTo(o),
            o.prepend(r.globalUniforms.globalUniformData.projectionMatrix),
            a.uResolution = r.globalUniforms.globalUniformData.resolution,
            a.uRound = r._roundPixels | e._roundPixels,
            Os(e.groupColorAlpha, a.uColor, 0),
            this.adaptor.execute(this, e)
        }
        destroy() {
            this.renderer = null,
            this.defaultShader && (this.defaultShader.destroy(),
            this.defaultShader = null)
        }
    }
      , kn = class extends Dn {
        constructor(e) {
            super(e, new cl)
        }
    }
    ;
    kn.extension = {
        type: [O.WebGLPipes],
        name: "particle"
    };
    var ul = class {
        execute(e, t) {
            let r = e.renderer
              , s = t.shader || e.defaultShader;
            s.groups[0] = r.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms, !0),
            s.groups[1] = r.texture.getTextureBindGroup(t.texture);
            let n = e.state
              , a = e.getBuffers(t);
            r.encoder.draw({
                geometry: a.geometry,
                shader: t.shader || e.defaultShader,
                state: n,
                size: t.particleChildren.length * 6
            })
        }
    }
      , Un = class extends Dn {
        constructor(e) {
            super(e, new ul)
        }
    }
    ;
    Un.extension = {
        type: [O.WebGPUPipes],
        name: "particle"
    },
    be.add(kn),
    be.add(Un);
    function dl(i, e) {
        let {texture: t, bounds: r} = i
          , s = e._style._getFinalPadding();
        ob(r, e._anchor, t);
        let n = e._anchor._x * s * 2
          , a = e._anchor._y * s * 2;
        r.minX -= s - n,
        r.minY -= s - a,
        r.maxX -= s - n,
        r.maxY -= s - a
    }
    var wr = class {
        constructor() {
            this.batcherName = "default",
            this.topology = "triangle-list",
            this.attributeSize = 4,
            this.indexSize = 6,
            this.packAsQuad = !0,
            this.roundPixels = 0,
            this._attributeStart = 0,
            this._batcher = null,
            this._batch = null
        }
        get blendMode() {
            return this.renderable.groupBlendMode
        }
        get color() {
            return this.renderable.groupColorAlpha
        }
        reset() {
            this.renderable = null,
            this.texture = null,
            this._batcher = null,
            this._batch = null,
            this.bounds = null
        }
        destroy() {}
    }
      , fl = class extends wr {
        constructor(e) {
            super(),
            this._renderer = e,
            e.runners.resolutionChange.add(this)
        }
        resolutionChange() {
            let e = this.renderable;
            e._autoResolution && e.onViewUpdate()
        }
        destroy() {
            let {canvasText: e} = this._renderer;
            e.getReferenceCount(this.currentKey) === null ? e.returnTexture(this.texture) : e.decreaseReferenceCount(this.currentKey),
            this._renderer.runners.resolutionChange.remove(this),
            this._renderer = null
        }
    }
      , Ln = class {
        constructor(e) {
            this._renderer = e
        }
        validateRenderable(e) {
            let t = this._getGpuText(e)
              , r = e.styleKey;
            return t.currentKey !== r ? !0 : e._didTextUpdate
        }
        addRenderable(e, t) {
            let r = this._getGpuText(e);
            if (e._didTextUpdate) {
                let s = e._autoResolution ? this._renderer.resolution : e.resolution;
                (r.currentKey !== e.styleKey || e.resolution !== s) && this._updateGpuText(e),
                e._didTextUpdate = !1
            }
            this._renderer.renderPipes.batch.addToBatch(r, t)
        }
        updateRenderable(e) {
            let t = this._getGpuText(e);
            t._batcher.updateElement(t)
        }
        _updateGpuText(e) {
            let t = this._getGpuText(e);
            t.texture && this._renderer.canvasText.decreaseReferenceCount(t.currentKey),
            e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution,
            t.texture = this._renderer.canvasText.getManagedTexture(e),
            t.currentKey = e.styleKey,
            dl(t, e)
        }
        _getGpuText(e) {
            return e._gpuData[this._renderer.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
            let t = new fl(this._renderer);
            return t.currentKey = "--",
            t.renderable = e,
            t.transform = e.groupTransform,
            t.bounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            },
            t.roundPixels = this._renderer._roundPixels | e._roundPixels,
            e._gpuData[this._renderer.uid] = t,
            t
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Ln.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "text"
    };
    var Xd = {
        repeat: {
            addressModeU: "repeat",
            addressModeV: "repeat"
        },
        "repeat-x": {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
            addressModeU: "clamp-to-edge",
            addressModeV: "repeat"
        },
        "no-repeat": {
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge"
        }
    }
      , Ar = class {
        constructor(e, t) {
            this.uid = Le("fillPattern"),
            this._tick = 0,
            this.transform = new ce,
            this.texture = e,
            this.transform.scale(1 / e.frame.width, 1 / e.frame.height),
            t && (e.source.style.addressModeU = Xd[t].addressModeU,
            e.source.style.addressModeV = Xd[t].addressModeV)
        }
        setTransform(e) {
            let t = this.texture;
            this.transform.copyFrom(e),
            this.transform.invert(),
            this.transform.scale(1 / t.frame.width, 1 / t.frame.height),
            this._tick++
        }
        get texture() {
            return this._texture
        }
        set texture(e) {
            this._texture !== e && (this._texture = e,
            this._tick++)
        }
        get styleKey() {
            return `fill-pattern-${this.uid}-${this._tick}`
        }
        destroy() {
            this.texture.destroy(!0),
            this.texture = null
        }
    }
      , gy = xy
      , Qo = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
    }
      , _y = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function xy(i) {
        var e = [];
        return i.replace(_y, function(t, r, s) {
            var n = r.toLowerCase();
            for (s = vy(s),
            n == "m" && s.length > 2 && (e.push([r].concat(s.splice(0, 2))),
            n = "l",
            r = r == "m" ? "l" : "L"); ; ) {
                if (s.length == Qo[n])
                    return s.unshift(r),
                    e.push(s);
                if (s.length < Qo[n])
                    throw new Error("malformed path data");
                e.push([r].concat(s.splice(0, Qo[n])))
            }
        }),
        e
    }
    var yy = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function vy(i) {
        var e = i.match(yy);
        return e ? e.map(Number) : []
    }
    var Ty = X0(gy);
    function Sy(i, e) {
        let t = Ty(i)
          , r = []
          , s = null
          , n = 0
          , a = 0;
        for (let o = 0; o < t.length; o++) {
            let l = t[o]
              , u = l[0]
              , d = l;
            switch (u) {
            case "M":
                n = d[1],
                a = d[2],
                e.moveTo(n, a);
                break;
            case "m":
                n += d[1],
                a += d[2],
                e.moveTo(n, a);
                break;
            case "H":
                n = d[1],
                e.lineTo(n, a);
                break;
            case "h":
                n += d[1],
                e.lineTo(n, a);
                break;
            case "V":
                a = d[1],
                e.lineTo(n, a);
                break;
            case "v":
                a += d[1],
                e.lineTo(n, a);
                break;
            case "L":
                n = d[1],
                a = d[2],
                e.lineTo(n, a);
                break;
            case "l":
                n += d[1],
                a += d[2],
                e.lineTo(n, a);
                break;
            case "C":
                n = d[5],
                a = d[6],
                e.bezierCurveTo(d[1], d[2], d[3], d[4], n, a);
                break;
            case "c":
                e.bezierCurveTo(n + d[1], a + d[2], n + d[3], a + d[4], n + d[5], a + d[6]),
                n += d[5],
                a += d[6];
                break;
            case "S":
                n = d[3],
                a = d[4],
                e.bezierCurveToShort(d[1], d[2], n, a);
                break;
            case "s":
                e.bezierCurveToShort(n + d[1], a + d[2], n + d[3], a + d[4]),
                n += d[3],
                a += d[4];
                break;
            case "Q":
                n = d[3],
                a = d[4],
                e.quadraticCurveTo(d[1], d[2], n, a);
                break;
            case "q":
                e.quadraticCurveTo(n + d[1], a + d[2], n + d[3], a + d[4]),
                n += d[3],
                a += d[4];
                break;
            case "T":
                n = d[1],
                a = d[2],
                e.quadraticCurveToShort(n, a);
                break;
            case "t":
                n += d[1],
                a += d[2],
                e.quadraticCurveToShort(n, a);
                break;
            case "A":
                n = d[6],
                a = d[7],
                e.arcToSvg(d[1], d[2], d[3], d[4], d[5], n, a);
                break;
            case "a":
                n += d[6],
                a += d[7],
                e.arcToSvg(d[1], d[2], d[3], d[4], d[5], n, a);
                break;
            case "Z":
            case "z":
                e.closePath(),
                r.length > 0 && (s = r.pop(),
                s ? (n = s.startX,
                a = s.startY) : (n = 0,
                a = 0)),
                s = null;
                break;
            default:
            }
            u !== "Z" && u !== "z" && s === null && (s = {
                startX: n,
                startY: a
            },
            r.push(s))
        }
        return e
    }
    var pl = class i {
        constructor(e=0, t=0, r=0) {
            this.type = "circle",
            this.x = e,
            this.y = t,
            this.radius = r
        }
        clone() {
            return new i(this.x,this.y,this.radius)
        }
        contains(e, t) {
            if (this.radius <= 0)
                return !1;
            let r = this.radius * this.radius
              , s = this.x - e
              , n = this.y - t;
            return s *= s,
            n *= n,
            s + n <= r
        }
        strokeContains(e, t, r, s=.5) {
            if (this.radius === 0)
                return !1;
            let n = this.x - e
              , a = this.y - t
              , o = this.radius
              , l = (1 - s) * r
              , u = Math.sqrt(n * n + a * a);
            return u <= o + l && u > o - (r - l)
        }
        getBounds(e) {
            return e || (e = new Oe),
            e.x = this.x - this.radius,
            e.y = this.y - this.radius,
            e.width = this.radius * 2,
            e.height = this.radius * 2,
            e
        }
        copyFrom(e) {
            return this.x = e.x,
            this.y = e.y,
            this.radius = e.radius,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
    }
      , bl = class i {
        constructor(e=0, t=0, r=0, s=0) {
            this.type = "ellipse",
            this.x = e,
            this.y = t,
            this.halfWidth = r,
            this.halfHeight = s
        }
        clone() {
            return new i(this.x,this.y,this.halfWidth,this.halfHeight)
        }
        contains(e, t) {
            if (this.halfWidth <= 0 || this.halfHeight <= 0)
                return !1;
            let r = (e - this.x) / this.halfWidth
              , s = (t - this.y) / this.halfHeight;
            return r *= r,
            s *= s,
            r + s <= 1
        }
        strokeContains(e, t, r, s=.5) {
            let {halfWidth: n, halfHeight: a} = this;
            if (n <= 0 || a <= 0)
                return !1;
            let o = r * (1 - s)
              , l = r - o
              , u = n - l
              , d = a - l
              , f = n + o
              , b = a + o
              , m = e - this.x
              , x = t - this.y
              , v = m * m / (u * u) + x * x / (d * d)
              , S = m * m / (f * f) + x * x / (b * b);
            return v > 1 && S <= 1
        }
        getBounds(e) {
            return e || (e = new Oe),
            e.x = this.x - this.halfWidth,
            e.y = this.y - this.halfHeight,
            e.width = this.halfWidth * 2,
            e.height = this.halfHeight * 2,
            e
        }
        copyFrom(e) {
            return this.x = e.x,
            this.y = e.y,
            this.halfWidth = e.halfWidth,
            this.halfHeight = e.halfHeight,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
    }
    ;
    function wy(i, e, t, r, s, n) {
        let a = i - t
          , o = e - r
          , l = s - t
          , u = n - r
          , d = a * l + o * u
          , f = l * l + u * u
          , b = -1;
        f !== 0 && (b = d / f);
        let m, x;
        b < 0 ? (m = t,
        x = r) : b > 1 ? (m = s,
        x = n) : (m = t + b * l,
        x = r + b * u);
        let v = i - m
          , S = e - x;
        return v * v + S * S
    }
    var Ay, Ey, as = class i {
        constructor(...e) {
            this.type = "polygon";
            let t = Array.isArray(e[0]) ? e[0] : e;
            if (typeof t[0] != "number") {
                let r = [];
                for (let s = 0, n = t.length; s < n; s++)
                    r.push(t[s].x, t[s].y);
                t = r
            }
            this.points = t,
            this.closePath = !0
        }
        isClockwise() {
            let e = 0
              , t = this.points
              , r = t.length;
            for (let s = 0; s < r; s += 2) {
                let n = t[s]
                  , a = t[s + 1]
                  , o = t[(s + 2) % r]
                  , l = t[(s + 3) % r];
                e += (o - n) * (l + a)
            }
            return e < 0
        }
        containsPolygon(e) {
            let t = this.getBounds(Ay)
              , r = e.getBounds(Ey);
            if (!t.containsRect(r))
                return !1;
            let s = e.points;
            for (let n = 0; n < s.length; n += 2) {
                let a = s[n]
                  , o = s[n + 1];
                if (!this.contains(a, o))
                    return !1
            }
            return !0
        }
        clone() {
            let e = this.points.slice()
              , t = new i(e);
            return t.closePath = this.closePath,
            t
        }
        contains(e, t) {
            let r = !1
              , s = this.points.length / 2;
            for (let n = 0, a = s - 1; n < s; a = n++) {
                let o = this.points[n * 2]
                  , l = this.points[n * 2 + 1]
                  , u = this.points[a * 2]
                  , d = this.points[a * 2 + 1];
                l > t != d > t && e < (u - o) * ((t - l) / (d - l)) + o && (r = !r)
            }
            return r
        }
        strokeContains(e, t, r, s=.5) {
            let n = r * r
              , a = n * (1 - s)
              , o = n - a
              , {points: l} = this
              , u = l.length - (this.closePath ? 0 : 2);
            for (let d = 0; d < u; d += 2) {
                let f = l[d]
                  , b = l[d + 1]
                  , m = l[(d + 2) % l.length]
                  , x = l[(d + 3) % l.length]
                  , v = wy(e, t, f, b, m, x)
                  , S = Math.sign((m - f) * (t - b) - (x - b) * (e - f));
                if (v <= (S < 0 ? o : a))
                    return !0
            }
            return !1
        }
        getBounds(e) {
            e || (e = new Oe);
            let t = this.points
              , r = 1 / 0
              , s = -1 / 0
              , n = 1 / 0
              , a = -1 / 0;
            for (let o = 0, l = t.length; o < l; o += 2) {
                let u = t[o]
                  , d = t[o + 1];
                r = u < r ? u : r,
                s = u > s ? u : s,
                n = d < n ? d : n,
                a = d > a ? d : a
            }
            return e.x = r,
            e.width = s - r,
            e.y = n,
            e.height = a - n,
            e
        }
        copyFrom(e) {
            return this.points = e.points.slice(),
            this.closePath = e.closePath,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
        get lastX() {
            return this.points[this.points.length - 2]
        }
        get lastY() {
            return this.points[this.points.length - 1]
        }
        get x() {
            return this.points[this.points.length - 2]
        }
        get y() {
            return this.points[this.points.length - 1]
        }
        get startX() {
            return this.points[0]
        }
        get startY() {
            return this.points[1]
        }
    }
    , Ys = (i, e, t, r, s, n, a) => {
        let o = i - t
          , l = e - r
          , u = Math.sqrt(o * o + l * l);
        return u >= s - n && u <= s + a
    }
    , ml = class i {
        constructor(e=0, t=0, r=0, s=0, n=20) {
            this.type = "roundedRectangle",
            this.x = e,
            this.y = t,
            this.width = r,
            this.height = s,
            this.radius = n
        }
        getBounds(e) {
            return e || (e = new Oe),
            e.x = this.x,
            e.y = this.y,
            e.width = this.width,
            e.height = this.height,
            e
        }
        clone() {
            return new i(this.x,this.y,this.width,this.height,this.radius)
        }
        copyFrom(e) {
            return this.x = e.x,
            this.y = e.y,
            this.width = e.width,
            this.height = e.height,
            this
        }
        copyTo(e) {
            return e.copyFrom(this),
            e
        }
        contains(e, t) {
            if (this.width <= 0 || this.height <= 0)
                return !1;
            if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
                let r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                if (t >= this.y + r && t <= this.y + this.height - r || e >= this.x + r && e <= this.x + this.width - r)
                    return !0;
                let s = e - (this.x + r)
                  , n = t - (this.y + r)
                  , a = r * r;
                if (s * s + n * n <= a || (s = e - (this.x + this.width - r),
                s * s + n * n <= a) || (n = t - (this.y + this.height - r),
                s * s + n * n <= a) || (s = e - (this.x + r),
                s * s + n * n <= a))
                    return !0
            }
            return !1
        }
        strokeContains(e, t, r, s=.5) {
            let {x: n, y: a, width: o, height: l, radius: u} = this
              , d = r * (1 - s)
              , f = r - d
              , b = n + u
              , m = a + u
              , x = o - u * 2
              , v = l - u * 2
              , S = n + o
              , w = a + l;
            return (e >= n - d && e <= n + f || e >= S - f && e <= S + d) && t >= m && t <= m + v || (t >= a - d && t <= a + f || t >= w - f && t <= w + d) && e >= b && e <= b + x ? !0 : e < b && t < m && Ys(e, t, b, m, u, f, d) || e > S - u && t < m && Ys(e, t, S - u, m, u, f, d) || e > S - u && t > w - u && Ys(e, t, S - u, w - u, u, f, d) || e < b && t > w - u && Ys(e, t, b, w - u, u, f, d)
        }
    }
    , Py = 8, $s = 11920929e-14, Ry = 1, Jo = .01, or = 0, Li = 0;
    function Nb(i, e, t, r, s, n, a, o, l, u) {
        let d = Math.min(.99, Math.max(0, u ?? Fh.defaultOptions.bezierSmoothness))
          , f = (Ry - d) / 1;
        return f *= f,
        My(e, t, r, s, n, a, o, l, i, f),
        i
    }
    function My(i, e, t, r, s, n, a, o, l, u) {
        gl(i, e, t, r, s, n, a, o, l, u, 0),
        l.push(a, o)
    }
    function gl(i, e, t, r, s, n, a, o, l, u, d) {
        if (d > Py)
            return;
        let f = Math.PI
          , b = (i + t) / 2
          , m = (e + r) / 2
          , x = (t + s) / 2
          , v = (r + n) / 2
          , S = (s + a) / 2
          , w = (n + o) / 2
          , E = (b + x) / 2
          , P = (m + v) / 2
          , C = (x + S) / 2
          , L = (v + w) / 2
          , F = (E + C) / 2
          , X = (P + L) / 2;
        if (d > 0) {
            let ie = a - i, te = o - e, V = Math.abs((t - a) * te - (r - o) * ie), K = Math.abs((s - a) * te - (n - o) * ie), W, J;
            if (V > $s && K > $s) {
                if ((V + K) * (V + K) <= u * (ie * ie + te * te)) {
                    if (or < Jo) {
                        l.push(F, X);
                        return
                    }
                    let he = Math.atan2(n - r, s - t);
                    if (W = Math.abs(he - Math.atan2(r - e, t - i)),
                    J = Math.abs(Math.atan2(o - n, a - s) - he),
                    W >= f && (W = 2 * f - W),
                    J >= f && (J = 2 * f - J),
                    W + J < or) {
                        l.push(F, X);
                        return
                    }
                    if (Li !== 0) {
                        if (W > Li) {
                            l.push(t, r);
                            return
                        }
                        if (J > Li) {
                            l.push(s, n);
                            return
                        }
                    }
                }
            } else if (V > $s) {
                if (V * V <= u * (ie * ie + te * te)) {
                    if (or < Jo) {
                        l.push(F, X);
                        return
                    }
                    if (W = Math.abs(Math.atan2(n - r, s - t) - Math.atan2(r - e, t - i)),
                    W >= f && (W = 2 * f - W),
                    W < or) {
                        l.push(t, r),
                        l.push(s, n);
                        return
                    }
                    if (Li !== 0 && W > Li) {
                        l.push(t, r);
                        return
                    }
                }
            } else if (K > $s) {
                if (K * K <= u * (ie * ie + te * te)) {
                    if (or < Jo) {
                        l.push(F, X);
                        return
                    }
                    if (W = Math.abs(Math.atan2(o - n, a - s) - Math.atan2(n - r, s - t)),
                    W >= f && (W = 2 * f - W),
                    W < or) {
                        l.push(t, r),
                        l.push(s, n);
                        return
                    }
                    if (Li !== 0 && W > Li) {
                        l.push(s, n);
                        return
                    }
                }
            } else if (ie = F - (i + a) / 2,
            te = X - (e + o) / 2,
            ie * ie + te * te <= u) {
                l.push(F, X);
                return
            }
        }
        gl(i, e, b, m, E, P, F, X, l, u, d + 1),
        gl(F, X, C, L, S, w, a, o, l, u, d + 1)
    }
    var Cy = 8
      , Oy = 11920929e-14
      , Iy = 1
      , Gy = .01
      , jd = 0;
    function By(i, e, t, r, s, n, a, o) {
        let l = Math.min(.99, Math.max(0, o ?? Fh.defaultOptions.bezierSmoothness))
          , u = (Iy - l) / 1;
        return u *= u,
        Fy(e, t, r, s, n, a, i, u),
        i
    }
    function Fy(i, e, t, r, s, n, a, o) {
        _l(a, i, e, t, r, s, n, o, 0),
        a.push(s, n)
    }
    function _l(i, e, t, r, s, n, a, o, l) {
        if (l > Cy)
            return;
        let u = Math.PI
          , d = (e + r) / 2
          , f = (t + s) / 2
          , b = (r + n) / 2
          , m = (s + a) / 2
          , x = (d + b) / 2
          , v = (f + m) / 2
          , S = n - e
          , w = a - t
          , E = Math.abs((r - n) * w - (s - a) * S);
        if (E > Oy) {
            if (E * E <= o * (S * S + w * w)) {
                if (jd < Gy) {
                    i.push(x, v);
                    return
                }
                let P = Math.abs(Math.atan2(a - s, n - r) - Math.atan2(s - t, r - e));
                if (P >= u && (P = 2 * u - P),
                P < jd) {
                    i.push(x, v);
                    return
                }
            }
        } else if (S = x - (e + n) / 2,
        w = v - (t + a) / 2,
        S * S + w * w <= o) {
            i.push(x, v);
            return
        }
        _l(i, e, t, d, f, x, v, o, l + 1),
        _l(i, x, v, b, m, n, a, o, l + 1)
    }
    function Xb(i, e, t, r, s, n, a, o) {
        let l = Math.abs(s - n);
        (!a && s > n || a && n > s) && (l = 2 * Math.PI - l),
        o || (o = Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (l / Math.PI)))),
        o = Math.max(o, 3);
        let u = l / o
          , d = s;
        u *= a ? -1 : 1;
        for (let f = 0; f < o + 1; f++) {
            let b = Math.cos(d)
              , m = Math.sin(d)
              , x = e + b * r
              , v = t + m * r;
            i.push(x, v),
            d += u
        }
    }
    function Dy(i, e, t, r, s, n) {
        let a = i[i.length - 2]
          , o = i[i.length - 1] - t
          , l = a - e
          , u = s - t
          , d = r - e
          , f = Math.abs(o * d - l * u);
        if (f < 1e-8 || n === 0) {
            (i[i.length - 2] !== e || i[i.length - 1] !== t) && i.push(e, t);
            return
        }
        let b = o * o + l * l
          , m = u * u + d * d
          , x = o * u + l * d
          , v = n * Math.sqrt(b) / f
          , S = n * Math.sqrt(m) / f
          , w = v * x / b
          , E = S * x / m
          , P = v * d + S * l
          , C = v * u + S * o
          , L = l * (S + w)
          , F = o * (S + w)
          , X = d * (v + E)
          , ie = u * (v + E)
          , te = Math.atan2(F - C, L - P)
          , V = Math.atan2(ie - C, X - P);
        Xb(i, P + e, C + t, n, te, V, l * u > d * o)
    }
    var os = Math.PI * 2
      , ec = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
    }
      , tc = ({x: i, y: e}, t, r, s, n, a, o, l) => {
        i *= t,
        e *= r;
        let u = s * i - n * e
          , d = n * i + s * e;
        return l.x = u + a,
        l.y = d + o,
        l
    }
    ;
    function ky(i, e) {
        let t = e === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(e / 4)
          , r = e === 1.5707963267948966 ? .551915024494 : t
          , s = Math.cos(i)
          , n = Math.sin(i)
          , a = Math.cos(i + e)
          , o = Math.sin(i + e);
        return [{
            x: s - n * r,
            y: n + s * r
        }, {
            x: a + o * r,
            y: o - a * r
        }, {
            x: a,
            y: o
        }]
    }
    var Hd = (i, e, t, r) => {
        let s = i * r - e * t < 0 ? -1 : 1
          , n = i * t + e * r;
        return n > 1 && (n = 1),
        n < -1 && (n = -1),
        s * Math.acos(n)
    }
      , Uy = (i, e, t, r, s, n, a, o, l, u, d, f, b) => {
        let m = Math.pow(s, 2)
          , x = Math.pow(n, 2)
          , v = Math.pow(d, 2)
          , S = Math.pow(f, 2)
          , w = m * x - m * S - x * v;
        w < 0 && (w = 0),
        w /= m * S + x * v,
        w = Math.sqrt(w) * (a === o ? -1 : 1);
        let E = w * s / n * f
          , P = w * -n / s * d
          , C = u * E - l * P + (i + t) / 2
          , L = l * E + u * P + (e + r) / 2
          , F = (d - E) / s
          , X = (f - P) / n
          , ie = (-d - E) / s
          , te = (-f - P) / n
          , V = Hd(1, 0, F, X)
          , K = Hd(F, X, ie, te);
        o === 0 && K > 0 && (K -= os),
        o === 1 && K < 0 && (K += os),
        b.centerX = C,
        b.centerY = L,
        b.ang1 = V,
        b.ang2 = K
    }
    ;
    function Ly(i, e, t, r, s, n, a, o=0, l=0, u=0) {
        if (n === 0 || a === 0)
            return;
        let d = Math.sin(o * os / 360)
          , f = Math.cos(o * os / 360)
          , b = f * (e - r) / 2 + d * (t - s) / 2
          , m = -d * (e - r) / 2 + f * (t - s) / 2;
        if (b === 0 && m === 0)
            return;
        n = Math.abs(n),
        a = Math.abs(a);
        let x = Math.pow(b, 2) / Math.pow(n, 2) + Math.pow(m, 2) / Math.pow(a, 2);
        x > 1 && (n *= Math.sqrt(x),
        a *= Math.sqrt(x)),
        Uy(e, t, r, s, n, a, l, u, d, f, b, m, ec);
        let {ang1: v, ang2: S} = ec
          , {centerX: w, centerY: E} = ec
          , P = Math.abs(S) / (os / 4);
        Math.abs(1 - P) < 1e-7 && (P = 1);
        let C = Math.max(Math.ceil(P), 1);
        S /= C;
        let L = i[i.length - 2]
          , F = i[i.length - 1]
          , X = {
            x: 0,
            y: 0
        };
        for (let ie = 0; ie < C; ie++) {
            let te = ky(v, S)
              , {x: V, y: K} = tc(te[0], n, a, f, d, w, E, X)
              , {x: W, y: J} = tc(te[1], n, a, f, d, w, E, X)
              , {x: he, y: je} = tc(te[2], n, a, f, d, w, E, X);
            Nb(i, L, F, V, K, W, J, he, je),
            L = he,
            F = je,
            v += S
        }
    }
    function Ny(i, e, t) {
        var r;
        let s = (o, l) => {
            let u = l.x - o.x
              , d = l.y - o.y
              , f = Math.sqrt(u * u + d * d)
              , b = u / f
              , m = d / f;
            return {
                len: f,
                nx: b,
                ny: m
            }
        }
          , n = (o, l) => {
            o === 0 ? i.moveTo(l.x, l.y) : i.lineTo(l.x, l.y)
        }
          , a = e[e.length - 1];
        for (let o = 0; o < e.length; o++) {
            let l = e[o % e.length]
              , u = (r = l.radius) != null ? r : t;
            if (u <= 0) {
                n(o, l),
                a = l;
                continue
            }
            let d = e[(o + 1) % e.length]
              , f = s(l, a)
              , b = s(l, d);
            if (f.len < 1e-4 || b.len < 1e-4) {
                n(o, l),
                a = l;
                continue
            }
            let m = Math.asin(f.nx * b.ny - f.ny * b.nx)
              , x = 1
              , v = !1;
            f.nx * b.nx - f.ny * -b.ny < 0 ? m < 0 ? m = Math.PI + m : (m = Math.PI - m,
            x = -1,
            v = !0) : m > 0 && (x = -1,
            v = !0);
            let S = m / 2, w, E = Math.abs(Math.cos(S) * u / Math.sin(S));
            E > Math.min(f.len / 2, b.len / 2) ? (E = Math.min(f.len / 2, b.len / 2),
            w = Math.abs(E * Math.sin(S) / Math.cos(S))) : w = u;
            let P = l.x + b.nx * E + -b.ny * w * x
              , C = l.y + b.ny * E + b.nx * w * x
              , L = Math.atan2(f.ny, f.nx) + Math.PI / 2 * x
              , F = Math.atan2(b.ny, b.nx) - Math.PI / 2 * x;
            o === 0 && i.moveTo(P + Math.cos(L) * w, C + Math.sin(L) * w),
            i.arc(P, C, w, L, F, v),
            a = l
        }
    }
    function Xy(i, e, t, r) {
        var s;
        let n = (l, u) => Math.sqrt((l.x - u.x) ** 2 + (l.y - u.y) ** 2)
          , a = (l, u, d) => ({
            x: l.x + (u.x - l.x) * d,
            y: l.y + (u.y - l.y) * d
        })
          , o = e.length;
        for (let l = 0; l < o; l++) {
            let u = e[(l + 1) % o]
              , d = (s = u.radius) != null ? s : t;
            if (d <= 0) {
                l === 0 ? i.moveTo(u.x, u.y) : i.lineTo(u.x, u.y);
                continue
            }
            let f = e[l], b = e[(l + 2) % o], m = n(f, u), x;
            if (m < 1e-4)
                x = u;
            else {
                let w = Math.min(m / 2, d);
                x = a(u, f, w / m)
            }
            let v = n(b, u), S;
            if (v < 1e-4)
                S = u;
            else {
                let w = Math.min(v / 2, d);
                S = a(u, b, w / v)
            }
            l === 0 ? i.moveTo(x.x, x.y) : i.lineTo(x.x, x.y),
            i.quadraticCurveTo(u.x, u.y, S.x, S.y, r)
        }
    }
    var jy = new Oe
      , xl = class {
        constructor(e) {
            this.shapePrimitives = [],
            this._currentPoly = null,
            this._bounds = new at,
            this._graphicsPath2D = e,
            this.signed = e.checkForHoles
        }
        moveTo(e, t) {
            return this.startPoly(e, t),
            this
        }
        lineTo(e, t) {
            this._ensurePoly();
            let r = this._currentPoly.points
              , s = r[r.length - 2]
              , n = r[r.length - 1];
            return (s !== e || n !== t) && r.push(e, t),
            this
        }
        arc(e, t, r, s, n, a) {
            this._ensurePoly(!1);
            let o = this._currentPoly.points;
            return Xb(o, e, t, r, s, n, a),
            this
        }
        arcTo(e, t, r, s, n) {
            this._ensurePoly();
            let a = this._currentPoly.points;
            return Dy(a, e, t, r, s, n),
            this
        }
        arcToSvg(e, t, r, s, n, a, o) {
            let l = this._currentPoly.points;
            return Ly(l, this._currentPoly.lastX, this._currentPoly.lastY, a, o, e, t, r, s, n),
            this
        }
        bezierCurveTo(e, t, r, s, n, a, o) {
            this._ensurePoly();
            let l = this._currentPoly;
            return Nb(this._currentPoly.points, l.lastX, l.lastY, e, t, r, s, n, a, o),
            this
        }
        quadraticCurveTo(e, t, r, s, n) {
            this._ensurePoly();
            let a = this._currentPoly;
            return By(this._currentPoly.points, a.lastX, a.lastY, e, t, r, s, n),
            this
        }
        closePath() {
            return this.endPoly(!0),
            this
        }
        addPath(e, t) {
            this.endPoly(),
            t && !t.isIdentity() && (e = e.clone(!0),
            e.transform(t));
            let r = this.shapePrimitives
              , s = r.length;
            for (let n = 0; n < e.instructions.length; n++) {
                let a = e.instructions[n];
                this[a.action](...a.data)
            }
            if (e.checkForHoles && r.length - s > 1) {
                let n = null;
                for (let a = s; a < r.length; a++) {
                    let o = r[a];
                    if (o.shape.type === "polygon") {
                        let l = o.shape
                          , u = n?.shape;
                        u && u.containsPolygon(l) ? (n.holes || (n.holes = []),
                        n.holes.push(o),
                        r.copyWithin(a, a + 1),
                        r.length--,
                        a--) : n = o
                    }
                }
            }
            return this
        }
        finish(e=!1) {
            this.endPoly(e)
        }
        rect(e, t, r, s, n) {
            return this.drawShape(new Oe(e,t,r,s), n),
            this
        }
        circle(e, t, r, s) {
            return this.drawShape(new pl(e,t,r), s),
            this
        }
        poly(e, t, r) {
            let s = new as(e);
            return s.closePath = t,
            this.drawShape(s, r),
            this
        }
        regularPoly(e, t, r, s, n=0, a) {
            s = Math.max(s | 0, 3);
            let o = -1 * Math.PI / 2 + n
              , l = Math.PI * 2 / s
              , u = [];
            for (let d = 0; d < s; d++) {
                let f = o - d * l;
                u.push(e + r * Math.cos(f), t + r * Math.sin(f))
            }
            return this.poly(u, !0, a),
            this
        }
        roundPoly(e, t, r, s, n, a=0, o) {
            if (s = Math.max(s | 0, 3),
            n <= 0)
                return this.regularPoly(e, t, r, s, a);
            let l = r * Math.sin(Math.PI / s) - .001;
            n = Math.min(n, l);
            let u = -1 * Math.PI / 2 + a
              , d = Math.PI * 2 / s
              , f = (s - 2) * Math.PI / s / 2;
            for (let b = 0; b < s; b++) {
                let m = b * d + u
                  , x = e + r * Math.cos(m)
                  , v = t + r * Math.sin(m)
                  , S = m + Math.PI + f
                  , w = m - Math.PI - f
                  , E = x + n * Math.cos(S)
                  , P = v + n * Math.sin(S)
                  , C = x + n * Math.cos(w)
                  , L = v + n * Math.sin(w);
                b === 0 ? this.moveTo(E, P) : this.lineTo(E, P),
                this.quadraticCurveTo(x, v, C, L, o)
            }
            return this.closePath()
        }
        roundShape(e, t, r=!1, s) {
            return e.length < 3 ? this : (r ? Xy(this, e, t, s) : Ny(this, e, t),
            this.closePath())
        }
        filletRect(e, t, r, s, n) {
            if (n === 0)
                return this.rect(e, t, r, s);
            let a = Math.min(r, s) / 2
              , o = Math.min(a, Math.max(-a, n))
              , l = e + r
              , u = t + s
              , d = o < 0 ? -o : 0
              , f = Math.abs(o);
            return this.moveTo(e, t + f).arcTo(e + d, t + d, e + f, t, f).lineTo(l - f, t).arcTo(l - d, t + d, l, t + f, f).lineTo(l, u - f).arcTo(l - d, u - d, e + r - f, u, f).lineTo(e + f, u).arcTo(e + d, u - d, e, u - f, f).closePath()
        }
        chamferRect(e, t, r, s, n, a) {
            if (n <= 0)
                return this.rect(e, t, r, s);
            let o = Math.min(n, Math.min(r, s) / 2)
              , l = e + r
              , u = t + s
              , d = [e + o, t, l - o, t, l, t + o, l, u - o, l - o, u, e + o, u, e, u - o, e, t + o];
            for (let f = d.length - 1; f >= 2; f -= 2)
                d[f] === d[f - 2] && d[f - 1] === d[f - 3] && d.splice(f - 1, 2);
            return this.poly(d, !0, a)
        }
        ellipse(e, t, r, s, n) {
            return this.drawShape(new bl(e,t,r,s), n),
            this
        }
        roundRect(e, t, r, s, n, a) {
            return this.drawShape(new ml(e,t,r,s,n), a),
            this
        }
        drawShape(e, t) {
            return this.endPoly(),
            this.shapePrimitives.push({
                shape: e,
                transform: t
            }),
            this
        }
        startPoly(e, t) {
            let r = this._currentPoly;
            return r && this.endPoly(),
            r = new as,
            r.points.push(e, t),
            this._currentPoly = r,
            this
        }
        endPoly(e=!1) {
            let t = this._currentPoly;
            return t && t.points.length > 2 && (t.closePath = e,
            this.shapePrimitives.push({
                shape: t
            })),
            this._currentPoly = null,
            this
        }
        _ensurePoly(e=!0) {
            if (!this._currentPoly && (this._currentPoly = new as,
            e)) {
                let t = this.shapePrimitives[this.shapePrimitives.length - 1];
                if (t) {
                    let r = t.shape.x
                      , s = t.shape.y;
                    if (t.transform && !t.transform.isIdentity()) {
                        let n = t.transform
                          , a = r;
                        r = n.a * r + n.c * s + n.tx,
                        s = n.b * a + n.d * s + n.ty
                    }
                    this._currentPoly.points.push(r, s)
                } else
                    this._currentPoly.points.push(0, 0)
            }
        }
        buildPath() {
            let e = this._graphicsPath2D;
            this.shapePrimitives.length = 0,
            this._currentPoly = null;
            for (let t = 0; t < e.instructions.length; t++) {
                let r = e.instructions[t];
                this[r.action](...r.data)
            }
            this.finish()
        }
        get bounds() {
            let e = this._bounds;
            e.clear();
            let t = this.shapePrimitives;
            for (let r = 0; r < t.length; r++) {
                let s = t[r]
                  , n = s.shape.getBounds(jy);
                s.transform ? e.addRect(n, s.transform) : e.addRect(n)
            }
            return e
        }
    }
      , di = class i {
        constructor(e, t=!1) {
            this.instructions = [],
            this.uid = Le("graphicsPath"),
            this._dirty = !0;
            var r;
            this.checkForHoles = t,
            typeof e == "string" ? Sy(e, this) : this.instructions = (r = e?.slice()) != null ? r : []
        }
        get shapePath() {
            return this._shapePath || (this._shapePath = new xl(this)),
            this._dirty && (this._dirty = !1,
            this._shapePath.buildPath()),
            this._shapePath
        }
        addPath(e, t) {
            return e = e.clone(),
            this.instructions.push({
                action: "addPath",
                data: [e, t]
            }),
            this._dirty = !0,
            this
        }
        arc(...e) {
            return this.instructions.push({
                action: "arc",
                data: e
            }),
            this._dirty = !0,
            this
        }
        arcTo(...e) {
            return this.instructions.push({
                action: "arcTo",
                data: e
            }),
            this._dirty = !0,
            this
        }
        arcToSvg(...e) {
            return this.instructions.push({
                action: "arcToSvg",
                data: e
            }),
            this._dirty = !0,
            this
        }
        bezierCurveTo(...e) {
            return this.instructions.push({
                action: "bezierCurveTo",
                data: e
            }),
            this._dirty = !0,
            this
        }
        bezierCurveToShort(e, t, r, s, n) {
            let a = this.instructions[this.instructions.length - 1]
              , o = this.getLastPoint(Ue.shared)
              , l = 0
              , u = 0;
            if (!a || a.action !== "bezierCurveTo")
                l = o.x,
                u = o.y;
            else {
                l = a.data[2],
                u = a.data[3];
                let d = o.x
                  , f = o.y;
                l = d + (d - l),
                u = f + (f - u)
            }
            return this.instructions.push({
                action: "bezierCurveTo",
                data: [l, u, e, t, r, s, n]
            }),
            this._dirty = !0,
            this
        }
        closePath() {
            return this.instructions.push({
                action: "closePath",
                data: []
            }),
            this._dirty = !0,
            this
        }
        ellipse(...e) {
            return this.instructions.push({
                action: "ellipse",
                data: e
            }),
            this._dirty = !0,
            this
        }
        lineTo(...e) {
            return this.instructions.push({
                action: "lineTo",
                data: e
            }),
            this._dirty = !0,
            this
        }
        moveTo(...e) {
            return this.instructions.push({
                action: "moveTo",
                data: e
            }),
            this
        }
        quadraticCurveTo(...e) {
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: e
            }),
            this._dirty = !0,
            this
        }
        quadraticCurveToShort(e, t, r) {
            let s = this.instructions[this.instructions.length - 1]
              , n = this.getLastPoint(Ue.shared)
              , a = 0
              , o = 0;
            if (!s || s.action !== "quadraticCurveTo")
                a = n.x,
                o = n.y;
            else {
                a = s.data[0],
                o = s.data[1];
                let l = n.x
                  , u = n.y;
                a = l + (l - a),
                o = u + (u - o)
            }
            return this.instructions.push({
                action: "quadraticCurveTo",
                data: [a, o, e, t, r]
            }),
            this._dirty = !0,
            this
        }
        rect(e, t, r, s, n) {
            return this.instructions.push({
                action: "rect",
                data: [e, t, r, s, n]
            }),
            this._dirty = !0,
            this
        }
        circle(e, t, r, s) {
            return this.instructions.push({
                action: "circle",
                data: [e, t, r, s]
            }),
            this._dirty = !0,
            this
        }
        roundRect(...e) {
            return this.instructions.push({
                action: "roundRect",
                data: e
            }),
            this._dirty = !0,
            this
        }
        poly(...e) {
            return this.instructions.push({
                action: "poly",
                data: e
            }),
            this._dirty = !0,
            this
        }
        regularPoly(...e) {
            return this.instructions.push({
                action: "regularPoly",
                data: e
            }),
            this._dirty = !0,
            this
        }
        roundPoly(...e) {
            return this.instructions.push({
                action: "roundPoly",
                data: e
            }),
            this._dirty = !0,
            this
        }
        roundShape(...e) {
            return this.instructions.push({
                action: "roundShape",
                data: e
            }),
            this._dirty = !0,
            this
        }
        filletRect(...e) {
            return this.instructions.push({
                action: "filletRect",
                data: e
            }),
            this._dirty = !0,
            this
        }
        chamferRect(...e) {
            return this.instructions.push({
                action: "chamferRect",
                data: e
            }),
            this._dirty = !0,
            this
        }
        star(e, t, r, s, n, a, o) {
            n || (n = s / 2);
            let l = -1 * Math.PI / 2 + a
              , u = r * 2
              , d = Math.PI * 2 / u
              , f = [];
            for (let b = 0; b < u; b++) {
                let m = b % 2 ? n : s
                  , x = b * d + l;
                f.push(e + m * Math.cos(x), t + m * Math.sin(x))
            }
            return this.poly(f, !0, o),
            this
        }
        clone(e=!1) {
            let t = new i;
            if (t.checkForHoles = this.checkForHoles,
            !e)
                t.instructions = this.instructions.slice();
            else
                for (let r = 0; r < this.instructions.length; r++) {
                    let s = this.instructions[r];
                    t.instructions.push({
                        action: s.action,
                        data: s.data.slice()
                    })
                }
            return t
        }
        clear() {
            return this.instructions.length = 0,
            this._dirty = !0,
            this
        }
        transform(e) {
            if (e.isIdentity())
                return this;
            let t = e.a
              , r = e.b
              , s = e.c
              , n = e.d
              , a = e.tx
              , o = e.ty
              , l = 0
              , u = 0
              , d = 0
              , f = 0
              , b = 0
              , m = 0
              , x = 0
              , v = 0;
            for (let S = 0; S < this.instructions.length; S++) {
                let w = this.instructions[S]
                  , E = w.data;
                switch (w.action) {
                case "moveTo":
                case "lineTo":
                    l = E[0],
                    u = E[1],
                    E[0] = t * l + s * u + a,
                    E[1] = r * l + n * u + o;
                    break;
                case "bezierCurveTo":
                    d = E[0],
                    f = E[1],
                    b = E[2],
                    m = E[3],
                    l = E[4],
                    u = E[5],
                    E[0] = t * d + s * f + a,
                    E[1] = r * d + n * f + o,
                    E[2] = t * b + s * m + a,
                    E[3] = r * b + n * m + o,
                    E[4] = t * l + s * u + a,
                    E[5] = r * l + n * u + o;
                    break;
                case "quadraticCurveTo":
                    d = E[0],
                    f = E[1],
                    l = E[2],
                    u = E[3],
                    E[0] = t * d + s * f + a,
                    E[1] = r * d + n * f + o,
                    E[2] = t * l + s * u + a,
                    E[3] = r * l + n * u + o;
                    break;
                case "arcToSvg":
                    l = E[5],
                    u = E[6],
                    x = E[0],
                    v = E[1],
                    E[0] = t * x + s * v,
                    E[1] = r * x + n * v,
                    E[5] = t * l + s * u + a,
                    E[6] = r * l + n * u + o;
                    break;
                case "circle":
                    E[4] = Xr(E[3], e);
                    break;
                case "rect":
                    E[4] = Xr(E[4], e);
                    break;
                case "ellipse":
                    E[8] = Xr(E[8], e);
                    break;
                case "roundRect":
                    E[5] = Xr(E[5], e);
                    break;
                case "addPath":
                    E[0].transform(e);
                    break;
                case "poly":
                    E[2] = Xr(E[2], e);
                    break;
                default:
                    break
                }
            }
            return this._dirty = !0,
            this
        }
        get bounds() {
            return this.shapePath.bounds
        }
        getLastPoint(e) {
            let t = this.instructions.length - 1
              , r = this.instructions[t];
            if (!r)
                return e.x = 0,
                e.y = 0,
                e;
            for (; r.action === "closePath"; ) {
                if (t--,
                t < 0)
                    return e.x = 0,
                    e.y = 0,
                    e;
                r = this.instructions[t]
            }
            switch (r.action) {
            case "moveTo":
            case "lineTo":
                e.x = r.data[0],
                e.y = r.data[1];
                break;
            case "quadraticCurveTo":
                e.x = r.data[2],
                e.y = r.data[3];
                break;
            case "bezierCurveTo":
                e.x = r.data[4],
                e.y = r.data[5];
                break;
            case "arc":
            case "arcToSvg":
                e.x = r.data[5],
                e.y = r.data[6];
                break;
            case "addPath":
                r.data[0].getLastPoint(e);
                break
            }
            return e
        }
    }
    ;
    function Xr(i, e) {
        return i ? i.prepend(e) : e.clone()
    }
    var ic = 0
      , zd = 500;
    function _i(...i) {
        ic !== zd && ic++
    }
    function We(i, e, t) {
        let r = i.getAttribute(e);
        return r ? Number(r) : t
    }
    function Hy(i, e) {
        let t = i.querySelectorAll("defs");
        for (let r = 0; r < t.length; r++) {
            let s = t[r];
            for (let n = 0; n < s.children.length; n++) {
                let a = s.children[n];
                switch (a.nodeName.toLowerCase()) {
                case "lineargradient":
                    e.defs[a.id] = zy(a);
                    break;
                case "radialgradient":
                    e.defs[a.id] = Vy(a);
                    break;
                default:
                    break
                }
            }
        }
    }
    function zy(i) {
        let e = We(i, "x1", 0)
          , t = We(i, "y1", 0)
          , r = We(i, "x2", 1)
          , s = We(i, "y2", 0)
          , n = i.getAttribute("gradientUnits") || "objectBoundingBox"
          , a = new gi(e,t,r,s,n === "objectBoundingBox" ? "local" : "global");
        for (let o = 0; o < i.children.length; o++) {
            let l = i.children[o]
              , u = We(l, "offset", 0)
              , d = Be.shared.setValue(l.getAttribute("stop-color")).toNumber();
            a.addColorStop(u, d)
        }
        return a
    }
    function Vy(i) {
        return new gi(0,0,1,0)
    }
    function Vd(i) {
        let e = i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
        return e ? e[1] : ""
    }
    var Wd = {
        fill: {
            type: "paint",
            default: 0
        },
        "fill-opacity": {
            type: "number",
            default: 1
        },
        stroke: {
            type: "paint",
            default: 0
        },
        "stroke-width": {
            type: "number",
            default: 1
        },
        "stroke-opacity": {
            type: "number",
            default: 1
        },
        "stroke-linecap": {
            type: "string",
            default: "butt"
        },
        "stroke-linejoin": {
            type: "string",
            default: "miter"
        },
        "stroke-miterlimit": {
            type: "number",
            default: 10
        },
        "stroke-dasharray": {
            type: "string",
            default: "none"
        },
        "stroke-dashoffset": {
            type: "number",
            default: 0
        },
        opacity: {
            type: "number",
            default: 1
        }
    };
    function jb(i, e) {
        let t = i.getAttribute("style")
          , r = {}
          , s = {}
          , n = {
            strokeStyle: r,
            fillStyle: s,
            useFill: !1,
            useStroke: !1
        };
        for (let a in Wd) {
            let o = i.getAttribute(a);
            o && Yd(e, n, a, o.trim())
        }
        if (t) {
            let a = t.split(";");
            for (let o = 0; o < a.length; o++) {
                let l = a[o].trim()
                  , [u,d] = l.split(":");
                Wd[u] && Yd(e, n, u, d.trim())
            }
        }
        return {
            strokeStyle: n.useStroke ? r : null,
            fillStyle: n.useFill ? s : null,
            useFill: n.useFill,
            useStroke: n.useStroke
        }
    }
    function Yd(i, e, t, r) {
        switch (t) {
        case "stroke":
            if (r !== "none") {
                if (r.startsWith("url(")) {
                    let s = Vd(r);
                    e.strokeStyle.fill = i.defs[s]
                } else
                    e.strokeStyle.color = Be.shared.setValue(r).toNumber();
                e.useStroke = !0
            }
            break;
        case "stroke-width":
            e.strokeStyle.width = Number(r);
            break;
        case "fill":
            if (r !== "none") {
                if (r.startsWith("url(")) {
                    let s = Vd(r);
                    e.fillStyle.fill = i.defs[s]
                } else
                    e.fillStyle.color = Be.shared.setValue(r).toNumber();
                e.useFill = !0
            }
            break;
        case "fill-opacity":
            e.fillStyle.alpha = Number(r);
            break;
        case "stroke-opacity":
            e.strokeStyle.alpha = Number(r);
            break;
        case "opacity":
            e.fillStyle.alpha = Number(r),
            e.strokeStyle.alpha = Number(r);
            break
        }
    }
    function Wy(i) {
        if (i.length <= 2)
            return !0;
        let e = i.map(o => o.area).sort( (o, l) => l - o)
          , [t,r] = e
          , s = e[e.length - 1]
          , n = t / r
          , a = r / s;
        return !(n > 3 && a < 2)
    }
    function Yy(i) {
        return i.split(/(?=[Mm])/).filter(e => e.trim().length > 0)
    }
    function $y(i) {
        let e = i.match(/[-+]?[0-9]*\.?[0-9]+/g);
        if (!e || e.length < 4)
            return 0;
        let t = e.map(Number)
          , r = []
          , s = [];
        for (let u = 0; u < t.length; u += 2)
            u + 1 < t.length && (r.push(t[u]),
            s.push(t[u + 1]));
        if (r.length === 0 || s.length === 0)
            return 0;
        let n = Math.min(...r)
          , a = Math.max(...r)
          , o = Math.min(...s)
          , l = Math.max(...s);
        return (a - n) * (l - o)
    }
    function $d(i, e) {
        let t = new di(i,!1);
        for (let r of t.instructions)
            e.instructions.push(r)
    }
    var Ky = Object.defineProperty
      , Kd = Object.getOwnPropertySymbols
      , qy = Object.prototype.hasOwnProperty
      , Zy = Object.prototype.propertyIsEnumerable
      , qd = (i, e, t) => e in i ? Ky(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Ks = (i, e) => {
        for (var t in e || (e = {}))
            qy.call(e, t) && qd(i, t, e[t]);
        if (Kd)
            for (var t of Kd(e))
                Zy.call(e, t) && qd(i, t, e[t]);
        return i
    }
    ;
    function Qy(i, e) {
        if (typeof i == "string") {
            let a = document.createElement("div");
            a.innerHTML = i.trim(),
            i = a.querySelector("svg")
        }
        let t = {
            context: e,
            defs: {},
            path: new di
        };
        Hy(i, t);
        let r = i.children
          , {fillStyle: s, strokeStyle: n} = jb(i, t);
        for (let a = 0; a < r.length; a++) {
            let o = r[a];
            o.nodeName.toLowerCase() !== "defs" && Hb(o, t, s, n)
        }
        return e
    }
    function Hb(i, e, t, r) {
        let s = i.children
          , {fillStyle: n, strokeStyle: a} = jb(i, e);
        n && t ? t = Ks(Ks({}, t), n) : n && (t = n),
        a && r ? r = Ks(Ks({}, r), a) : a && (r = a);
        let o = !t && !r;
        o && (t = {
            color: 0
        });
        let l, u, d, f, b, m, x, v, S, w, E, P, C, L, F, X, ie;
        switch (i.nodeName.toLowerCase()) {
        case "path":
            {
                L = i.getAttribute("d");
                let te = i.getAttribute("fill-rule")
                  , V = Yy(L)
                  , K = te === "evenodd"
                  , W = V.length > 1;
                if (K && W) {
                    let J = V.map(he => ({
                        path: he,
                        area: $y(he)
                    }));
                    if (J.sort( (he, je) => je.area - he.area),
                    V.length > 3 || !Wy(J))
                        for (let he = 0; he < J.length; he++) {
                            let je = J[he]
                              , re = he === 0;
                            e.context.beginPath();
                            let ne = new di(void 0,!0);
                            $d(je.path, ne),
                            e.context.path(ne),
                            re ? (t && e.context.fill(t),
                            r && e.context.stroke(r)) : e.context.cut()
                        }
                    else
                        for (let he = 0; he < J.length; he++) {
                            let je = J[he]
                              , re = he % 2 === 1;
                            e.context.beginPath();
                            let ne = new di(void 0,!0);
                            $d(je.path, ne),
                            e.context.path(ne),
                            re ? e.context.cut() : (t && e.context.fill(t),
                            r && e.context.stroke(r))
                        }
                } else {
                    let J = te ? te === "evenodd" : !0;
                    F = new di(L,J),
                    e.context.path(F),
                    t && e.context.fill(t),
                    r && e.context.stroke(r)
                }
                break
            }
        case "circle":
            x = We(i, "cx", 0),
            v = We(i, "cy", 0),
            S = We(i, "r", 0),
            e.context.ellipse(x, v, S, S),
            t && e.context.fill(t),
            r && e.context.stroke(r);
            break;
        case "rect":
            l = We(i, "x", 0),
            u = We(i, "y", 0),
            X = We(i, "width", 0),
            ie = We(i, "height", 0),
            w = We(i, "rx", 0),
            E = We(i, "ry", 0),
            w || E ? e.context.roundRect(l, u, X, ie, w || E) : e.context.rect(l, u, X, ie),
            t && e.context.fill(t),
            r && e.context.stroke(r);
            break;
        case "ellipse":
            x = We(i, "cx", 0),
            v = We(i, "cy", 0),
            w = We(i, "rx", 0),
            E = We(i, "ry", 0),
            e.context.beginPath(),
            e.context.ellipse(x, v, w, E),
            t && e.context.fill(t),
            r && e.context.stroke(r);
            break;
        case "line":
            d = We(i, "x1", 0),
            f = We(i, "y1", 0),
            b = We(i, "x2", 0),
            m = We(i, "y2", 0),
            e.context.beginPath(),
            e.context.moveTo(d, f),
            e.context.lineTo(b, m),
            r && e.context.stroke(r);
            break;
        case "polygon":
            C = i.getAttribute("points"),
            P = C.match(/\d+/g).map(te => parseInt(te, 10)),
            e.context.poly(P, !0),
            t && e.context.fill(t),
            r && e.context.stroke(r);
            break;
        case "polyline":
            C = i.getAttribute("points"),
            P = C.match(/\d+/g).map(te => parseInt(te, 10)),
            e.context.poly(P, !1),
            r && e.context.stroke(r);
            break;
        case "g":
        case "svg":
            break;
        default:
            {
                _i(`[SVG parser] <${i.nodeName}> elements unsupported`);
                break
            }
        }
        o && (t = null);
        for (let te = 0; te < s.length; te++)
            Hb(s[te], e, t, r)
    }
    var Jy = Object.defineProperty
      , Nn = Object.getOwnPropertySymbols
      , zb = Object.prototype.hasOwnProperty
      , Vb = Object.prototype.propertyIsEnumerable
      , Zd = (i, e, t) => e in i ? Jy(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , $t = (i, e) => {
        for (var t in e || (e = {}))
            zb.call(e, t) && Zd(i, t, e[t]);
        if (Nn)
            for (var t of Nn(e))
                Vb.call(e, t) && Zd(i, t, e[t]);
        return i
    }
      , ev = (i, e) => {
        var t = {};
        for (var r in i)
            zb.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && Nn)
            for (var r of Nn(i))
                e.indexOf(r) < 0 && Vb.call(i, r) && (t[r] = i[r]);
        return t
    }
    ;
    function tv(i) {
        return Be.isColorLike(i)
    }
    function Qd(i) {
        return i instanceof Ar
    }
    function Jd(i) {
        return i instanceof gi
    }
    function iv(i) {
        return i instanceof Z
    }
    function rv(i, e, t) {
        let r = Be.shared.setValue(e ?? 0);
        return i.color = r.toNumber(),
        i.alpha = r.alpha === 1 ? t.alpha : r.alpha,
        i.texture = Z.WHITE,
        $t($t({}, t), i)
    }
    function sv(i, e, t) {
        return i.texture = e,
        $t($t({}, t), i)
    }
    function ef(i, e, t) {
        return i.fill = e,
        i.color = 16777215,
        i.texture = e.texture,
        i.matrix = e.transform,
        $t($t({}, t), i)
    }
    function tf(i, e, t) {
        return e.buildGradient(),
        i.fill = e,
        i.color = 16777215,
        i.texture = e.texture,
        i.matrix = e.transform,
        i.textureSpace = e.textureSpace,
        $t($t({}, t), i)
    }
    function nv(i, e) {
        let t = $t($t({}, e), i)
          , r = Be.shared.setValue(t.color);
        return t.alpha *= r.alpha,
        t.color = r.toNumber(),
        t
    }
    function $i(i, e) {
        if (i == null)
            return null;
        let t = {}
          , r = i;
        return tv(i) ? rv(t, i, e) : iv(i) ? sv(t, i, e) : Qd(i) ? ef(t, i, e) : Jd(i) ? tf(t, i, e) : r.fill && Qd(r.fill) ? ef(r, r.fill, e) : r.fill && Jd(r.fill) ? tf(r, r.fill, e) : nv(r, e)
    }
    function Xn(i, e) {
        let t = e
          , {width: r, alignment: s, miterLimit: n, cap: a, join: o, pixelLine: l} = t
          , u = ev(t, ["width", "alignment", "miterLimit", "cap", "join", "pixelLine"])
          , d = $i(i, u);
        return d ? $t({
            width: r,
            alignment: s,
            miterLimit: n,
            cap: a,
            join: o,
            pixelLine: l
        }, d) : null
    }
    var av = Object.defineProperty
      , rf = Object.getOwnPropertySymbols
      , ov = Object.prototype.hasOwnProperty
      , cv = Object.prototype.propertyIsEnumerable
      , sf = (i, e, t) => e in i ? av(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , cr = (i, e) => {
        for (var t in e || (e = {}))
            ov.call(e, t) && sf(i, t, e[t]);
        if (rf)
            for (var t of rf(e))
                cv.call(e, t) && sf(i, t, e[t]);
        return i
    }
      , lv = new Ue
      , nf = new ce
      , yl = class ri extends Ot {
        constructor() {
            super(...arguments),
            this.uid = Le("graphicsContext"),
            this.dirty = !0,
            this.batchMode = "auto",
            this.instructions = [],
            this._activePath = new di,
            this._transform = new ce,
            this._fillStyle = cr({}, ri.defaultFillStyle),
            this._strokeStyle = cr({}, ri.defaultStrokeStyle),
            this._stateStack = [],
            this._tick = 0,
            this._bounds = new at,
            this._boundsDirty = !0
        }
        clone() {
            let e = new ri;
            return e.batchMode = this.batchMode,
            e.instructions = this.instructions.slice(),
            e._activePath = this._activePath.clone(),
            e._transform = this._transform.clone(),
            e._fillStyle = cr({}, this._fillStyle),
            e._strokeStyle = cr({}, this._strokeStyle),
            e._stateStack = this._stateStack.slice(),
            e._bounds = this._bounds.clone(),
            e._boundsDirty = !0,
            e
        }
        get fillStyle() {
            return this._fillStyle
        }
        set fillStyle(e) {
            this._fillStyle = $i(e, ri.defaultFillStyle)
        }
        get strokeStyle() {
            return this._strokeStyle
        }
        set strokeStyle(e) {
            this._strokeStyle = Xn(e, ri.defaultStrokeStyle)
        }
        setFillStyle(e) {
            return this._fillStyle = $i(e, ri.defaultFillStyle),
            this
        }
        setStrokeStyle(e) {
            return this._strokeStyle = $i(e, ri.defaultStrokeStyle),
            this
        }
        texture(e, t, r, s, n, a) {
            return this.instructions.push({
                action: "texture",
                data: {
                    image: e,
                    dx: r || 0,
                    dy: s || 0,
                    dw: n || e.frame.width,
                    dh: a || e.frame.height,
                    transform: this._transform.clone(),
                    alpha: this._fillStyle.alpha,
                    style: t ? Be.shared.setValue(t).toNumber() : 16777215
                }
            }),
            this.onUpdate(),
            this
        }
        beginPath() {
            return this._activePath = new di,
            this
        }
        fill(e, t) {
            let r, s = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && s && s.action === "stroke" ? r = s.data.path : r = this._activePath.clone(),
            r ? (e != null && (t !== void 0 && typeof e == "number" && (e = {
                color: e,
                alpha: t
            }),
            this._fillStyle = $i(e, ri.defaultFillStyle)),
            this.instructions.push({
                action: "fill",
                data: {
                    style: this.fillStyle,
                    path: r
                }
            }),
            this.onUpdate(),
            this._initNextPathLocation(),
            this._tick = 0,
            this) : this
        }
        _initNextPathLocation() {
            let {x: e, y: t} = this._activePath.getLastPoint(Ue.shared);
            this._activePath.clear(),
            this._activePath.moveTo(e, t)
        }
        stroke(e) {
            let t, r = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && r && r.action === "fill" ? t = r.data.path : t = this._activePath.clone(),
            t ? (e != null && (this._strokeStyle = Xn(e, ri.defaultStrokeStyle)),
            this.instructions.push({
                action: "stroke",
                data: {
                    style: this.strokeStyle,
                    path: t
                }
            }),
            this.onUpdate(),
            this._initNextPathLocation(),
            this._tick = 0,
            this) : this
        }
        cut() {
            for (let e = 0; e < 2; e++) {
                let t = this.instructions[this.instructions.length - 1 - e]
                  , r = this._activePath.clone();
                if (t && (t.action === "stroke" || t.action === "fill"))
                    if (t.data.hole)
                        t.data.hole.addPath(r);
                    else {
                        t.data.hole = r;
                        break
                    }
            }
            return this._initNextPathLocation(),
            this
        }
        arc(e, t, r, s, n, a) {
            this._tick++;
            let o = this._transform;
            return this._activePath.arc(o.a * e + o.c * t + o.tx, o.b * e + o.d * t + o.ty, r, s, n, a),
            this
        }
        arcTo(e, t, r, s, n) {
            this._tick++;
            let a = this._transform;
            return this._activePath.arcTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * r + a.c * s + a.tx, a.b * r + a.d * s + a.ty, n),
            this
        }
        arcToSvg(e, t, r, s, n, a, o) {
            this._tick++;
            let l = this._transform;
            return this._activePath.arcToSvg(e, t, r, s, n, l.a * a + l.c * o + l.tx, l.b * a + l.d * o + l.ty),
            this
        }
        bezierCurveTo(e, t, r, s, n, a, o) {
            this._tick++;
            let l = this._transform;
            return this._activePath.bezierCurveTo(l.a * e + l.c * t + l.tx, l.b * e + l.d * t + l.ty, l.a * r + l.c * s + l.tx, l.b * r + l.d * s + l.ty, l.a * n + l.c * a + l.tx, l.b * n + l.d * a + l.ty, o),
            this
        }
        closePath() {
            var e;
            return this._tick++,
            (e = this._activePath) == null || e.closePath(),
            this
        }
        ellipse(e, t, r, s) {
            return this._tick++,
            this._activePath.ellipse(e, t, r, s, this._transform.clone()),
            this
        }
        circle(e, t, r) {
            return this._tick++,
            this._activePath.circle(e, t, r, this._transform.clone()),
            this
        }
        path(e) {
            return this._tick++,
            this._activePath.addPath(e, this._transform.clone()),
            this
        }
        lineTo(e, t) {
            this._tick++;
            let r = this._transform;
            return this._activePath.lineTo(r.a * e + r.c * t + r.tx, r.b * e + r.d * t + r.ty),
            this
        }
        moveTo(e, t) {
            this._tick++;
            let r = this._transform
              , s = this._activePath.instructions
              , n = r.a * e + r.c * t + r.tx
              , a = r.b * e + r.d * t + r.ty;
            return s.length === 1 && s[0].action === "moveTo" ? (s[0].data[0] = n,
            s[0].data[1] = a,
            this) : (this._activePath.moveTo(n, a),
            this)
        }
        quadraticCurveTo(e, t, r, s, n) {
            this._tick++;
            let a = this._transform;
            return this._activePath.quadraticCurveTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * r + a.c * s + a.tx, a.b * r + a.d * s + a.ty, n),
            this
        }
        rect(e, t, r, s) {
            return this._tick++,
            this._activePath.rect(e, t, r, s, this._transform.clone()),
            this
        }
        roundRect(e, t, r, s, n) {
            return this._tick++,
            this._activePath.roundRect(e, t, r, s, n, this._transform.clone()),
            this
        }
        poly(e, t) {
            return this._tick++,
            this._activePath.poly(e, t, this._transform.clone()),
            this
        }
        regularPoly(e, t, r, s, n=0, a) {
            return this._tick++,
            this._activePath.regularPoly(e, t, r, s, n, a),
            this
        }
        roundPoly(e, t, r, s, n, a) {
            return this._tick++,
            this._activePath.roundPoly(e, t, r, s, n, a),
            this
        }
        roundShape(e, t, r, s) {
            return this._tick++,
            this._activePath.roundShape(e, t, r, s),
            this
        }
        filletRect(e, t, r, s, n) {
            return this._tick++,
            this._activePath.filletRect(e, t, r, s, n),
            this
        }
        chamferRect(e, t, r, s, n, a) {
            return this._tick++,
            this._activePath.chamferRect(e, t, r, s, n, a),
            this
        }
        star(e, t, r, s, n=0, a=0) {
            return this._tick++,
            this._activePath.star(e, t, r, s, n, a, this._transform.clone()),
            this
        }
        svg(e) {
            return this._tick++,
            Qy(e, this),
            this
        }
        restore() {
            let e = this._stateStack.pop();
            return e && (this._transform = e.transform,
            this._fillStyle = e.fillStyle,
            this._strokeStyle = e.strokeStyle),
            this
        }
        save() {
            return this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: cr({}, this._fillStyle),
                strokeStyle: cr({}, this._strokeStyle)
            }),
            this
        }
        getTransform() {
            return this._transform
        }
        resetTransform() {
            return this._transform.identity(),
            this
        }
        rotate(e) {
            return this._transform.rotate(e),
            this
        }
        scale(e, t=e) {
            return this._transform.scale(e, t),
            this
        }
        setTransform(e, t, r, s, n, a) {
            return e instanceof ce ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty),
            this) : (this._transform.set(e, t, r, s, n, a),
            this)
        }
        transform(e, t, r, s, n, a) {
            return e instanceof ce ? (this._transform.append(e),
            this) : (nf.set(e, t, r, s, n, a),
            this._transform.append(nf),
            this)
        }
        translate(e, t=e) {
            return this._transform.translate(e, t),
            this
        }
        clear() {
            return this._activePath.clear(),
            this.instructions.length = 0,
            this.resetTransform(),
            this.onUpdate(),
            this
        }
        onUpdate() {
            this.dirty || (this.emit("update", this, 16),
            this.dirty = !0,
            this._boundsDirty = !0)
        }
        get bounds() {
            if (!this._boundsDirty)
                return this._bounds;
            this._boundsDirty = !1;
            let e = this._bounds;
            e.clear();
            for (let t = 0; t < this.instructions.length; t++) {
                let r = this.instructions[t]
                  , s = r.action;
                if (s === "fill") {
                    let n = r.data;
                    e.addBounds(n.path.bounds)
                } else if (s === "texture") {
                    let n = r.data;
                    e.addFrame(n.dx, n.dy, n.dx + n.dw, n.dy + n.dh, n.transform)
                }
                if (s === "stroke") {
                    let n = r.data
                      , a = n.style.alignment
                      , o = n.style.width * (1 - a)
                      , l = n.path.bounds;
                    e.addFrame(l.minX - o, l.minY - o, l.maxX + o, l.maxY + o)
                }
            }
            return e
        }
        containsPoint(e) {
            var t;
            if (!this.bounds.containsPoint(e.x, e.y))
                return !1;
            let r = this.instructions
              , s = !1;
            for (let n = 0; n < r.length; n++) {
                let a = r[n]
                  , o = a.data
                  , l = o.path;
                if (!a.action || !l)
                    continue;
                let u = o.style
                  , d = l.shapePath.shapePrimitives;
                for (let f = 0; f < d.length; f++) {
                    let b = d[f].shape;
                    if (!u || !b)
                        continue;
                    let m = d[f].transform
                      , x = m ? m.applyInverse(e, lv) : e;
                    if (a.action === "fill")
                        s = b.contains(x.x, x.y);
                    else {
                        let S = u;
                        s = b.strokeContains(x.x, x.y, S.width, S.alignment)
                    }
                    let v = o.hole;
                    if (v) {
                        let S = (t = v.shapePath) == null ? void 0 : t.shapePrimitives;
                        if (S)
                            for (let w = 0; w < S.length; w++)
                                S[w].shape.contains(x.x, x.y) && (s = !1)
                    }
                    if (s)
                        return !0
                }
            }
            return s
        }
        destroy(e=!1) {
            if (this._stateStack.length = 0,
            this._transform = null,
            this.emit("destroy", this),
            this.removeAllListeners(),
            typeof e == "boolean" ? e : e?.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._fillStyle.texture && (this._fillStyle.fill && "uid"in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(t)),
                this._strokeStyle.texture && (this._strokeStyle.fill && "uid"in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(t))
            }
            this._fillStyle = null,
            this._strokeStyle = null,
            this.instructions = null,
            this._activePath = null,
            this._bounds = null,
            this._stateStack = null,
            this.customShader = null,
            this._transform = null
        }
    }
    ;
    yl.defaultFillStyle = {
        color: 16777215,
        alpha: 1,
        texture: Z.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local"
    },
    yl.defaultStrokeStyle = {
        width: 1,
        color: 16777215,
        alpha: 1,
        alignment: .5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: Z.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
        pixelLine: !1
    };
    var yt = yl
      , hv = Object.defineProperty
      , uv = Object.defineProperties
      , dv = Object.getOwnPropertyDescriptors
      , af = Object.getOwnPropertySymbols
      , fv = Object.prototype.hasOwnProperty
      , pv = Object.prototype.propertyIsEnumerable
      , of = (i, e, t) => e in i ? hv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , wt = (i, e) => {
        for (var t in e || (e = {}))
            fv.call(e, t) && of(i, t, e[t]);
        if (af)
            for (var t of af(e))
                pv.call(e, t) && of(i, t, e[t]);
        return i
    }
      , bv = (i, e) => uv(i, dv(e))
      , vl = class dr extends Ot {
        constructor(e={}) {
            super(),
            this.uid = Le("textStyle"),
            this._tick = 0,
            mv(e);
            let t = wt(wt({}, dr.defaultTextStyle), e);
            for (let r in t) {
                let s = r;
                this[s] = t[r]
            }
            this.update(),
            this._tick = 0
        }
        get align() {
            return this._align
        }
        set align(e) {
            this._align = e,
            this.update()
        }
        get breakWords() {
            return this._breakWords
        }
        set breakWords(e) {
            this._breakWords = e,
            this.update()
        }
        get dropShadow() {
            return this._dropShadow
        }
        set dropShadow(e) {
            e !== null && typeof e == "object" ? this._dropShadow = this._createProxy(wt(wt({}, dr.defaultDropShadow), e)) : this._dropShadow = e ? this._createProxy(wt({}, dr.defaultDropShadow)) : null,
            this.update()
        }
        get fontFamily() {
            return this._fontFamily
        }
        set fontFamily(e) {
            this._fontFamily = e,
            this.update()
        }
        get fontSize() {
            return this._fontSize
        }
        set fontSize(e) {
            typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e,
            this.update()
        }
        get fontStyle() {
            return this._fontStyle
        }
        set fontStyle(e) {
            this._fontStyle = e.toLowerCase(),
            this.update()
        }
        get fontVariant() {
            return this._fontVariant
        }
        set fontVariant(e) {
            this._fontVariant = e,
            this.update()
        }
        get fontWeight() {
            return this._fontWeight
        }
        set fontWeight(e) {
            this._fontWeight = e,
            this.update()
        }
        get leading() {
            return this._leading
        }
        set leading(e) {
            this._leading = e,
            this.update()
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(e) {
            this._letterSpacing = e,
            this.update()
        }
        get lineHeight() {
            return this._lineHeight
        }
        set lineHeight(e) {
            this._lineHeight = e,
            this.update()
        }
        get padding() {
            return this._padding
        }
        set padding(e) {
            this._padding = e,
            this.update()
        }
        get filters() {
            return this._filters
        }
        set filters(e) {
            this._filters = Object.freeze(e),
            this.update()
        }
        get trim() {
            return this._trim
        }
        set trim(e) {
            this._trim = e,
            this.update()
        }
        get textBaseline() {
            return this._textBaseline
        }
        set textBaseline(e) {
            this._textBaseline = e,
            this.update()
        }
        get whiteSpace() {
            return this._whiteSpace
        }
        set whiteSpace(e) {
            this._whiteSpace = e,
            this.update()
        }
        get wordWrap() {
            return this._wordWrap
        }
        set wordWrap(e) {
            this._wordWrap = e,
            this.update()
        }
        get wordWrapWidth() {
            return this._wordWrapWidth
        }
        set wordWrapWidth(e) {
            this._wordWrapWidth = e,
            this.update()
        }
        get fill() {
            return this._originalFill
        }
        set fill(e) {
            e !== this._originalFill && (this._originalFill = e,
            this._isFillStyle(e) && (this._originalFill = this._createProxy(wt(wt({}, yt.defaultFillStyle), e), () => {
                this._fill = $i(wt({}, this._originalFill), yt.defaultFillStyle)
            }
            )),
            this._fill = $i(e === 0 ? "black" : e, yt.defaultFillStyle),
            this.update())
        }
        get stroke() {
            return this._originalStroke
        }
        set stroke(e) {
            e !== this._originalStroke && (this._originalStroke = e,
            this._isFillStyle(e) && (this._originalStroke = this._createProxy(wt(wt({}, yt.defaultStrokeStyle), e), () => {
                this._stroke = Xn(wt({}, this._originalStroke), yt.defaultStrokeStyle)
            }
            )),
            this._stroke = Xn(e, yt.defaultStrokeStyle),
            this.update())
        }
        update() {
            this._tick++,
            this.emit("update", this)
        }
        reset() {
            let e = dr.defaultTextStyle;
            for (let t in e)
                this[t] = e[t]
        }
        get styleKey() {
            return `${this.uid}-${this._tick}`
        }
        clone() {
            return new dr({
                align: this.align,
                breakWords: this.breakWords,
                dropShadow: this._dropShadow ? wt({}, this._dropShadow) : null,
                fill: this._fill,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontStyle: this.fontStyle,
                fontVariant: this.fontVariant,
                fontWeight: this.fontWeight,
                leading: this.leading,
                letterSpacing: this.letterSpacing,
                lineHeight: this.lineHeight,
                padding: this.padding,
                stroke: this._stroke,
                textBaseline: this.textBaseline,
                whiteSpace: this.whiteSpace,
                wordWrap: this.wordWrap,
                wordWrapWidth: this.wordWrapWidth,
                filters: this._filters ? [...this._filters] : void 0
            })
        }
        _getFinalPadding() {
            let e = 0;
            if (this._filters)
                for (let t = 0; t < this._filters.length; t++)
                    e += this._filters[t].padding;
            return Math.max(this._padding, e)
        }
        destroy(e=!1) {
            var t, r, s, n;
            if (this.removeAllListeners(),
            typeof e == "boolean" ? e : e?.texture) {
                let a = typeof e == "boolean" ? e : e?.textureSource;
                (t = this._fill) != null && t.texture && this._fill.texture.destroy(a),
                (r = this._originalFill) != null && r.texture && this._originalFill.texture.destroy(a),
                (s = this._stroke) != null && s.texture && this._stroke.texture.destroy(a),
                (n = this._originalStroke) != null && n.texture && this._originalStroke.texture.destroy(a)
            }
            this._fill = null,
            this._stroke = null,
            this.dropShadow = null,
            this._originalStroke = null,
            this._originalFill = null
        }
        _createProxy(e, t) {
            return new Proxy(e,{
                set: (r, s, n) => (r[s] = n,
                t?.(s, n),
                this.update(),
                !0)
            })
        }
        _isFillStyle(e) {
            return (e ?? null) !== null && !(Be.isColorLike(e) || e instanceof gi || e instanceof Ar)
        }
    }
    ;
    vl.defaultDropShadow = {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
    },
    vl.defaultTextStyle = {
        align: "left",
        breakWords: !1,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: !1,
        whiteSpace: "pre",
        wordWrap: !1,
        wordWrapWidth: 100
    };
    var Lt = vl;
    function mv(i) {
        var e, t, r, s, n;
        let a = i;
        if (typeof a.dropShadow == "boolean" && a.dropShadow) {
            let o = Lt.defaultDropShadow;
            i.dropShadow = {
                alpha: (e = a.dropShadowAlpha) != null ? e : o.alpha,
                angle: (t = a.dropShadowAngle) != null ? t : o.angle,
                blur: (r = a.dropShadowBlur) != null ? r : o.blur,
                color: (s = a.dropShadowColor) != null ? s : o.color,
                distance: (n = a.dropShadowDistance) != null ? n : o.distance
            }
        }
        if (a.strokeThickness !== void 0) {
            let o = a.stroke
              , l = {};
            if (Be.isColorLike(o))
                l.color = o;
            else if (o instanceof gi || o instanceof Ar)
                l.fill = o;
            else if (Object.hasOwnProperty.call(o, "color") || Object.hasOwnProperty.call(o, "fill"))
                l = o;
            else
                throw new Error("Invalid stroke value.");
            i.stroke = bv(wt({}, l), {
                width: a.strokeThickness
            })
        }
        if (Array.isArray(a.fillGradientStops)) {
            if (!Array.isArray(a.fill) || a.fill.length === 0)
                throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
            a.fill.length,
            a.fillGradientStops.length;
            let o = new gi({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 1
                },
                textureSpace: "local"
            })
              , l = a.fillGradientStops.slice()
              , u = a.fill.map(d => Be.shared.setValue(d).toNumber());
            l.forEach( (d, f) => {
                o.addColorStop(d, u[f])
            }
            ),
            i.fill = {
                fill: o
            }
        }
    }
    var gv = new at;
    function Wb(i, e, t, r) {
        let s = gv;
        s.minX = 0,
        s.minY = 0,
        s.maxX = i.width / r | 0,
        s.maxY = i.height / r | 0;
        let n = Ke.getOptimalTexture(s.width, s.height, r, !1);
        return n.source.uploadMethodId = "image",
        n.source.resource = i,
        n.source.alphaMode = "premultiply-alpha-on-upload",
        n.frame.width = e / r,
        n.frame.height = t / r,
        n.source.emit("update", n.source),
        n.updateUvs(),
        n
    }
    var Tl = class {
        constructor(e) {
            this._canvasPool = Object.create(null),
            this.canvasOptions = e || {},
            this.enableFullScreen = !1
        }
        _createCanvasAndContext(e, t) {
            let r = ye.get().createCanvas();
            r.width = e,
            r.height = t;
            let s = r.getContext("2d");
            return {
                canvas: r,
                context: s
            }
        }
        getOptimalCanvasAndContext(e, t, r=1) {
            e = Math.ceil(e * r - 1e-6),
            t = Math.ceil(t * r - 1e-6),
            e = yr(e),
            t = yr(t);
            let s = (e << 17) + (t << 1);
            this._canvasPool[s] || (this._canvasPool[s] = []);
            let n = this._canvasPool[s].pop();
            return n || (n = this._createCanvasAndContext(e, t)),
            n
        }
        returnCanvasAndContext(e) {
            let t = e.canvas
              , {width: r, height: s} = t
              , n = (r << 17) + (s << 1);
            e.context.resetTransform(),
            e.context.clearRect(0, 0, r, s),
            this._canvasPool[n].push(e)
        }
        clear() {
            this._canvasPool = {}
        }
    }
      , xi = new Tl;
    Pr.register(xi);
    var Ni = null
      , hi = null;
    function _v(i, e) {
        Ni || (Ni = ye.get().createCanvas(256, 128),
        hi = Ni.getContext("2d", {
            willReadFrequently: !0
        }),
        hi.globalCompositeOperation = "copy",
        hi.globalAlpha = 1),
        (Ni.width < i || Ni.height < e) && (Ni.width = yr(i),
        Ni.height = yr(e))
    }
    function cf(i, e, t) {
        for (let r = 0, s = 4 * t * e; r < e; ++r,
        s += 4)
            if (i[s + 3] !== 0)
                return !1;
        return !0
    }
    function lf(i, e, t, r, s) {
        let n = 4 * e;
        for (let a = r, o = r * n + 4 * t; a <= s; ++a,
        o += n)
            if (i[o + 3] !== 0)
                return !1;
        return !0
    }
    function xv(...i) {
        var e, t, r;
        let s = i[0];
        s.canvas || (s = {
            canvas: i[0],
            resolution: i[1]
        });
        let {canvas: n} = s
          , a = Math.min((e = s.resolution) != null ? e : 1, 1)
          , o = (t = s.width) != null ? t : n.width
          , l = (r = s.height) != null ? r : n.height
          , u = s.output;
        if (_v(o, l),
        !hi)
            throw new TypeError("Failed to get canvas 2D context");
        hi.drawImage(n, 0, 0, o, l, 0, 0, o * a, l * a);
        let d = hi.getImageData(0, 0, o, l).data
          , f = 0
          , b = 0
          , m = o - 1
          , x = l - 1;
        for (; b < l && cf(d, o, b); )
            ++b;
        if (b === l)
            return Oe.EMPTY;
        for (; cf(d, o, x); )
            --x;
        for (; lf(d, o, f, b, x); )
            ++f;
        for (; lf(d, o, m, b, x); )
            --m;
        return ++m,
        ++x,
        hi.globalCompositeOperation = "source-over",
        hi.strokeRect(f, b, m - f, x - b),
        hi.globalCompositeOperation = "copy",
        u != null || (u = new Oe),
        u.set(f / a, b / a, (m - f) / a, (x - b) / a),
        u
    }
    var Sl = class {
        constructor(e=0, t=0, r=!1) {
            this.first = null,
            this.items = Object.create(null),
            this.last = null,
            this.max = e,
            this.resetTtl = r,
            this.size = 0,
            this.ttl = t
        }
        clear() {
            return this.first = null,
            this.items = Object.create(null),
            this.last = null,
            this.size = 0,
            this
        }
        delete(e) {
            if (this.has(e)) {
                let t = this.items[e];
                delete this.items[e],
                this.size--,
                t.prev !== null && (t.prev.next = t.next),
                t.next !== null && (t.next.prev = t.prev),
                this.first === t && (this.first = t.next),
                this.last === t && (this.last = t.prev)
            }
            return this
        }
        entries(e=this.keys()) {
            return e.map(t => [t, this.get(t)])
        }
        evict(e=!1) {
            if (e || this.size > 0) {
                let t = this.first;
                delete this.items[t.key],
                --this.size === 0 ? (this.first = null,
                this.last = null) : (this.first = t.next,
                this.first.prev = null)
            }
            return this
        }
        expiresAt(e) {
            let t;
            return this.has(e) && (t = this.items[e].expiry),
            t
        }
        get(e) {
            let t = this.items[e];
            if (t !== void 0) {
                if (this.ttl > 0 && t.expiry <= Date.now()) {
                    this.delete(e);
                    return
                }
                return this.moveToEnd(t),
                t.value
            }
        }
        has(e) {
            return e in this.items
        }
        moveToEnd(e) {
            this.last !== e && (e.prev !== null && (e.prev.next = e.next),
            e.next !== null && (e.next.prev = e.prev),
            this.first === e && (this.first = e.next),
            e.prev = this.last,
            e.next = null,
            this.last !== null && (this.last.next = e),
            this.last = e,
            this.first === null && (this.first = e))
        }
        keys() {
            let e = []
              , t = this.first;
            for (; t !== null; )
                e.push(t.key),
                t = t.next;
            return e
        }
        setWithEvicted(e, t, r=this.resetTtl) {
            let s = null;
            if (this.has(e))
                this.set(e, t, !0, r);
            else {
                this.max > 0 && this.size === this.max && (s = o1({}, this.first),
                this.evict(!0));
                let n = this.items[e] = {
                    expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
                    key: e,
                    prev: this.last,
                    next: null,
                    value: t
                };
                ++this.size === 1 ? this.first = n : this.last.next = n,
                this.last = n
            }
            return s
        }
        set(e, t, r=!1, s=this.resetTtl) {
            let n = this.items[e];
            return r || n !== void 0 ? (n.value = t,
            r === !1 && s && (n.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl),
            this.moveToEnd(n)) : (this.max > 0 && this.size === this.max && this.evict(!0),
            n = this.items[e] = {
                expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
                key: e,
                prev: this.last,
                next: null,
                value: t
            },
            ++this.size === 1 ? this.first = n : this.last.next = n,
            this.last = n),
            this
        }
        values(e=this.keys()) {
            return e.map(t => this.get(t))
        }
    }
    ;
    function Yb(i=1e3, e=0, t=!1) {
        if (isNaN(i) || i < 0)
            throw new TypeError("Invalid max value");
        if (isNaN(e) || e < 0)
            throw new TypeError("Invalid ttl value");
        if (typeof t != "boolean")
            throw new TypeError("Invalid resetTtl value");
        return new Sl(i,e,t)
    }
    var yv = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
    function jn(i) {
        let e = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize
          , t = i.fontFamily;
        Array.isArray(i.fontFamily) || (t = i.fontFamily.split(","));
        for (let r = t.length - 1; r >= 0; r--) {
            let s = t[r].trim();
            !/([\"\'])[^\'\"]+\1/.test(s) && !yv.includes(s) && (s = `"${s}"`),
            t[r] = s
        }
        return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${e} ${t.join(",")}`
    }
    var rc = {
        willReadFrequently: !0
    }
      , zt = class le {
        static get experimentalLetterSpacingSupported() {
            let e = le._experimentalLetterSpacingSupported;
            if (e === void 0) {
                let t = ye.get().getCanvasRenderingContext2D().prototype;
                e = le._experimentalLetterSpacingSupported = "letterSpacing"in t || "textLetterSpacing"in t
            }
            return e
        }
        constructor(e, t, r, s, n, a, o, l, u) {
            this.text = e,
            this.style = t,
            this.width = r,
            this.height = s,
            this.lines = n,
            this.lineWidths = a,
            this.lineHeight = o,
            this.maxLineWidth = l,
            this.fontProperties = u
        }
        static measureText(e=" ", t, r=le._canvas, s=t.wordWrap) {
            var n;
            let a = `${e}-${t.styleKey}-wordWrap-${s}`;
            if (le._measurementCache.has(a))
                return le._measurementCache.get(a);
            let o = jn(t)
              , l = le.measureFont(o);
            l.fontSize === 0 && (l.fontSize = t.fontSize,
            l.ascent = t.fontSize);
            let u = le.__context;
            u.font = o;
            let d = (s ? le._wordWrap(e, t, r) : e).split(/(?:\r\n|\r|\n)/)
              , f = new Array(d.length)
              , b = 0;
            for (let E = 0; E < d.length; E++) {
                let P = le._measureText(d[E], t.letterSpacing, u);
                f[E] = P,
                b = Math.max(b, P)
            }
            let m = ((n = t._stroke) == null ? void 0 : n.width) || 0
              , x = b + m;
            t.dropShadow && (x += t.dropShadow.distance);
            let v = t.lineHeight || l.fontSize
              , S = Math.max(v, l.fontSize + m) + (d.length - 1) * (v + t.leading);
            t.dropShadow && (S += t.dropShadow.distance);
            let w = new le(e,t,x,S,d,f,v + t.leading,b,l);
            return le._measurementCache.set(a, w),
            w
        }
        static _measureText(e, t, r) {
            let s = !1;
            le.experimentalLetterSpacingSupported && (le.experimentalLetterSpacing ? (r.letterSpacing = `${t}px`,
            r.textLetterSpacing = `${t}px`,
            s = !0) : (r.letterSpacing = "0px",
            r.textLetterSpacing = "0px"));
            let n = r.measureText(e)
              , a = n.width
              , o = -n.actualBoundingBoxLeft
              , l = n.actualBoundingBoxRight - o;
            if (a > 0)
                if (s)
                    a -= t,
                    l -= t;
                else {
                    let u = (le.graphemeSegmenter(e).length - 1) * t;
                    a += u,
                    l += u
                }
            return Math.max(a, l)
        }
        static _wordWrap(e, t, r=le._canvas) {
            let s = r.getContext("2d", rc)
              , n = 0
              , a = ""
              , o = ""
              , l = Object.create(null)
              , {letterSpacing: u, whiteSpace: d} = t
              , f = le._collapseSpaces(d)
              , b = le._collapseNewlines(d)
              , m = !f
              , x = t.wordWrapWidth + u
              , v = le._tokenize(e);
            for (let S = 0; S < v.length; S++) {
                let w = v[S];
                if (le._isNewline(w)) {
                    if (!b) {
                        o += le._addLine(a),
                        m = !f,
                        a = "",
                        n = 0;
                        continue
                    }
                    w = " "
                }
                if (f) {
                    let P = le.isBreakingSpace(w)
                      , C = le.isBreakingSpace(a[a.length - 1]);
                    if (P && C)
                        continue
                }
                let E = le._getFromCache(w, u, l, s);
                if (E > x)
                    if (a !== "" && (o += le._addLine(a),
                    a = "",
                    n = 0),
                    le.canBreakWords(w, t.breakWords)) {
                        let P = le.wordWrapSplit(w);
                        for (let C = 0; C < P.length; C++) {
                            let L = P[C]
                              , F = L
                              , X = 1;
                            for (; P[C + X]; ) {
                                let te = P[C + X];
                                if (!le.canBreakChars(F, te, w, C, t.breakWords))
                                    L += te;
                                else
                                    break;
                                F = te,
                                X++
                            }
                            C += X - 1;
                            let ie = le._getFromCache(L, u, l, s);
                            ie + n > x && (o += le._addLine(a),
                            m = !1,
                            a = "",
                            n = 0),
                            a += L,
                            n += ie
                        }
                    } else {
                        a.length > 0 && (o += le._addLine(a),
                        a = "",
                        n = 0);
                        let P = S === v.length - 1;
                        o += le._addLine(w, !P),
                        m = !1,
                        a = "",
                        n = 0
                    }
                else
                    E + n > x && (m = !1,
                    o += le._addLine(a),
                    a = "",
                    n = 0),
                    (a.length > 0 || !le.isBreakingSpace(w) || m) && (a += w,
                    n += E)
            }
            return o += le._addLine(a, !1),
            o
        }
        static _addLine(e, t=!0) {
            return e = le._trimRight(e),
            e = t ? `${e}
` : e,
            e
        }
        static _getFromCache(e, t, r, s) {
            let n = r[e];
            return typeof n != "number" && (n = le._measureText(e, t, s) + t,
            r[e] = n),
            n
        }
        static _collapseSpaces(e) {
            return e === "normal" || e === "pre-line"
        }
        static _collapseNewlines(e) {
            return e === "normal"
        }
        static _trimRight(e) {
            if (typeof e != "string")
                return "";
            for (let t = e.length - 1; t >= 0; t--) {
                let r = e[t];
                if (!le.isBreakingSpace(r))
                    break;
                e = e.slice(0, -1)
            }
            return e
        }
        static _isNewline(e) {
            return typeof e != "string" ? !1 : le._newlines.includes(e.charCodeAt(0))
        }
        static isBreakingSpace(e, t) {
            return typeof e != "string" ? !1 : le._breakingSpaces.includes(e.charCodeAt(0))
        }
        static _tokenize(e) {
            let t = []
              , r = "";
            if (typeof e != "string")
                return t;
            for (let s = 0; s < e.length; s++) {
                let n = e[s]
                  , a = e[s + 1];
                if (le.isBreakingSpace(n, a) || le._isNewline(n)) {
                    r !== "" && (t.push(r),
                    r = ""),
                    n === "\r" && a === `
` ? (t.push(`\r
`),
                    s++) : t.push(n);
                    continue
                }
                r += n
            }
            return r !== "" && t.push(r),
            t
        }
        static canBreakWords(e, t) {
            return t
        }
        static canBreakChars(e, t, r, s, n) {
            return !0
        }
        static wordWrapSplit(e) {
            return le.graphemeSegmenter(e)
        }
        static measureFont(e) {
            if (le._fonts[e])
                return le._fonts[e];
            let t = le._context;
            t.font = e;
            let r = t.measureText(le.METRICS_STRING + le.BASELINE_SYMBOL)
              , s = {
                ascent: r.actualBoundingBoxAscent,
                descent: r.actualBoundingBoxDescent,
                fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
            };
            return le._fonts[e] = s,
            s
        }
        static clearMetrics(e="") {
            e ? delete le._fonts[e] : le._fonts = {}
        }
        static get _canvas() {
            if (!le.__canvas) {
                let e;
                try {
                    let t = new OffscreenCanvas(0,0)
                      , r = t.getContext("2d", rc);
                    if (r != null && r.measureText)
                        return le.__canvas = t,
                        t;
                    e = ye.get().createCanvas()
                } catch {
                    e = ye.get().createCanvas()
                }
                e.width = e.height = 10,
                le.__canvas = e
            }
            return le.__canvas
        }
        static get _context() {
            return le.__context || (le.__context = le._canvas.getContext("2d", rc)),
            le.__context
        }
    }
    ;
    zt.METRICS_STRING = "|\xC9q\xC5",
    zt.BASELINE_SYMBOL = "M",
    zt.BASELINE_MULTIPLIER = 1.4,
    zt.HEIGHT_MULTIPLIER = 2,
    zt.graphemeSegmenter = ( () => {
        if (typeof Intl?.Segmenter == "function") {
            let i = new Intl.Segmenter;
            return e => {
                let t = i.segment(e)
                  , r = []
                  , s = 0;
                for (let n of t)
                    r[s++] = n.segment;
                return r
            }
        }
        return i => [...i]
    }
    )(),
    zt.experimentalLetterSpacing = !1,
    zt._fonts = {},
    zt._newlines = [10, 13],
    zt._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288],
    zt._measurementCache = Yb(1e3);
    var ft = zt
      , hf = 1e5;
    function Hn(i, e, t, r=0) {
        var s;
        if (i.texture === Z.WHITE && !i.fill)
            return Be.shared.setValue(i.color).setAlpha((s = i.alpha) != null ? s : 1).toHexa();
        if (i.fill) {
            if (i.fill instanceof Ar) {
                let n = i.fill
                  , a = e.createPattern(n.texture.source.resource, "repeat")
                  , o = n.transform.copyTo(ce.shared);
                return o.scale(n.texture.frame.width, n.texture.frame.height),
                a.setTransform(o),
                a
            } else if (i.fill instanceof gi) {
                let n = i.fill
                  , a = n.type === "linear"
                  , o = n.textureSpace === "local"
                  , l = 1
                  , u = 1;
                o && t && (l = t.width + r,
                u = t.height + r);
                let d, f = !1;
                if (a) {
                    let {start: b, end: m} = n;
                    d = e.createLinearGradient(b.x * l, b.y * u, m.x * l, m.y * u),
                    f = Math.abs(m.x - b.x) < Math.abs((m.y - b.y) * .1)
                } else {
                    let {center: b, innerRadius: m, outerCenter: x, outerRadius: v} = n;
                    d = e.createRadialGradient(b.x * l, b.y * u, m * l, x.x * l, x.y * u, v * l)
                }
                if (f && o && t) {
                    let b = t.lineHeight / u;
                    for (let m = 0; m < t.lines.length; m++) {
                        let x = (m * t.lineHeight + r / 2) / u;
                        n.colorStops.forEach(v => {
                            let S = x + v.offset * b;
                            d.addColorStop(Math.floor(S * hf) / hf, Be.shared.setValue(v.color).toHex())
                        }
                        )
                    }
                } else
                    n.colorStops.forEach(b => {
                        d.addColorStop(b.offset, Be.shared.setValue(b.color).toHex())
                    }
                    );
                return d
            }
        } else {
            let n = e.createPattern(i.texture.source.resource, "repeat")
              , a = i.matrix.copyTo(ce.shared);
            return a.scale(i.texture.frame.width, i.texture.frame.height),
            n.setTransform(a),
            n
        }
        return "red"
    }
    var uf = new Oe
      , vv = class {
        getCanvasAndContext(i) {
            let {text: e, style: t, resolution: r=1} = i
              , s = t._getFinalPadding()
              , n = ft.measureText(e || " ", t)
              , a = Math.ceil(Math.ceil(Math.max(1, n.width) + s * 2) * r)
              , o = Math.ceil(Math.ceil(Math.max(1, n.height) + s * 2) * r)
              , l = xi.getOptimalCanvasAndContext(a, o);
            this._renderTextToCanvas(e, t, s, r, l);
            let u = t.trim ? xv({
                canvas: l.canvas,
                width: a,
                height: o,
                resolution: 1,
                output: uf
            }) : uf.set(0, 0, a, o);
            return {
                canvasAndContext: l,
                frame: u
            }
        }
        returnCanvasAndContext(i) {
            xi.returnCanvasAndContext(i)
        }
        _renderTextToCanvas(i, e, t, r, s) {
            var n, a, o, l, u;
            let {canvas: d, context: f} = s
              , b = jn(e)
              , m = ft.measureText(i || " ", e)
              , x = m.lines
              , v = m.lineHeight
              , S = m.lineWidths
              , w = m.maxLineWidth
              , E = m.fontProperties
              , P = d.height;
            if (f.resetTransform(),
            f.scale(r, r),
            f.textBaseline = e.textBaseline,
            (n = e._stroke) != null && n.width) {
                let X = e._stroke;
                f.lineWidth = X.width,
                f.miterLimit = X.miterLimit,
                f.lineJoin = X.join,
                f.lineCap = X.cap
            }
            f.font = b;
            let C, L, F = e.dropShadow ? 2 : 1;
            for (let X = 0; X < F; ++X) {
                let ie = e.dropShadow && X === 0
                  , te = ie ? Math.ceil(Math.max(1, P) + t * 2) : 0
                  , V = te * r;
                if (ie) {
                    f.fillStyle = "black",
                    f.strokeStyle = "black";
                    let J = e.dropShadow
                      , he = J.color
                      , je = J.alpha;
                    f.shadowColor = Be.shared.setValue(he).setAlpha(je).toRgbaString();
                    let re = J.blur * r
                      , ne = J.distance * r;
                    f.shadowBlur = re,
                    f.shadowOffsetX = Math.cos(J.angle) * ne,
                    f.shadowOffsetY = Math.sin(J.angle) * ne + V
                } else {
                    if (f.fillStyle = e._fill ? Hn(e._fill, f, m, t * 2) : null,
                    (a = e._stroke) != null && a.width) {
                        let J = e._stroke.width * .5 + t * 2;
                        f.strokeStyle = Hn(e._stroke, f, m, J)
                    }
                    f.shadowColor = "black"
                }
                let K = (v - E.fontSize) / 2;
                v - E.fontSize < 0 && (K = 0);
                let W = (l = (o = e._stroke) == null ? void 0 : o.width) != null ? l : 0;
                for (let J = 0; J < x.length; J++)
                    C = W / 2,
                    L = W / 2 + J * v + E.ascent + K,
                    e.align === "right" ? C += w - S[J] : e.align === "center" && (C += (w - S[J]) / 2),
                    (u = e._stroke) != null && u.width && this._drawLetterSpacing(x[J], e, s, C + t, L + t - te, !0),
                    e._fill !== void 0 && this._drawLetterSpacing(x[J], e, s, C + t, L + t - te)
            }
        }
        _drawLetterSpacing(i, e, t, r, s, n=!1) {
            let {context: a} = t
              , o = e.letterSpacing
              , l = !1;
            if (ft.experimentalLetterSpacingSupported && (ft.experimentalLetterSpacing ? (a.letterSpacing = `${o}px`,
            a.textLetterSpacing = `${o}px`,
            l = !0) : (a.letterSpacing = "0px",
            a.textLetterSpacing = "0px")),
            o === 0 || l) {
                n ? a.strokeText(i, r, s) : a.fillText(i, r, s);
                return
            }
            let u = r
              , d = ft.graphemeSegmenter(i)
              , f = a.measureText(i).width
              , b = 0;
            for (let m = 0; m < d.length; ++m) {
                let x = d[m];
                n ? a.strokeText(x, u, s) : a.fillText(x, u, s);
                let v = "";
                for (let S = m + 1; S < d.length; ++S)
                    v += d[S];
                b = a.measureText(v).width,
                u += f - b + o,
                f = b
            }
        }
    }
      , cs = new vv
      , zn = class {
        constructor(e) {
            this._activeTextures = {},
            this._renderer = e
        }
        getTexture(e, t, r, s) {
            var n;
            typeof e == "string" && (e = {
                text: e,
                style: r,
                resolution: t
            }),
            e.style instanceof Lt || (e.style = new Lt(e.style)),
            e.textureStyle instanceof kt || (e.textureStyle = new kt(e.textureStyle)),
            typeof e.text != "string" && (e.text = e.text.toString());
            let {text: a, style: o, textureStyle: l} = e
              , u = (n = e.resolution) != null ? n : this._renderer.resolution
              , {frame: d, canvasAndContext: f} = cs.getCanvasAndContext({
                text: a,
                style: o,
                resolution: u
            })
              , b = Wb(f.canvas, d.width, d.height, u);
            if (l && (b.source.style = l),
            o.trim && (d.pad(o.padding),
            b.frame.copyFrom(d),
            b.frame.scale(1 / u),
            b.updateUvs()),
            o.filters) {
                let m = this._applyFilters(b, o.filters);
                return this.returnTexture(b),
                cs.returnCanvasAndContext(f),
                m
            }
            return this._renderer.texture.initSource(b._source),
            cs.returnCanvasAndContext(f),
            b
        }
        returnTexture(e) {
            let t = e.source;
            t.resource = null,
            t.uploadMethodId = "unknown",
            t.alphaMode = "no-premultiply-alpha",
            Ke.returnTexture(e, !0)
        }
        renderTextToCanvas() {}
        getManagedTexture(e) {
            e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution;
            let t = e.styleKey;
            if (this._activeTextures[t])
                return this._increaseReferenceCount(t),
                this._activeTextures[t].texture;
            let r = this.getTexture({
                text: e.text,
                style: e.style,
                resolution: e._resolution,
                textureStyle: e.textureStyle
            });
            return this._activeTextures[t] = {
                texture: r,
                usageCount: 1
            },
            r
        }
        decreaseReferenceCount(e) {
            let t = this._activeTextures[e];
            t.usageCount--,
            t.usageCount === 0 && (this.returnTexture(t.texture),
            this._activeTextures[e] = null)
        }
        getReferenceCount(e) {
            var t, r;
            return (r = (t = this._activeTextures[e]) == null ? void 0 : t.usageCount) != null ? r : null
        }
        _increaseReferenceCount(e) {
            this._activeTextures[e].usageCount++
        }
        _applyFilters(e, t) {
            let r = this._renderer.renderTarget.renderTarget
              , s = this._renderer.filter.generateFilteredTexture({
                texture: e,
                filters: t
            });
            return this._renderer.renderTarget.bind(r, !1),
            s
        }
        destroy() {
            this._renderer = null;
            for (let e in this._activeTextures)
                this._activeTextures[e] && this.returnTexture(this._activeTextures[e].texture);
            this._activeTextures = null
        }
    }
    ;
    zn.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "canvasText"
    },
    be.add(zn),
    be.add(Ln);
    var Tv = Object.defineProperty, Vn = Object.getOwnPropertySymbols, $b = Object.prototype.hasOwnProperty, Kb = Object.prototype.propertyIsEnumerable, df = (i, e, t) => e in i ? Tv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, Sv = (i, e) => {
        for (var t in e || (e = {}))
            $b.call(e, t) && df(i, t, e[t]);
        if (Vn)
            for (var t of Vn(e))
                Kb.call(e, t) && df(i, t, e[t]);
        return i
    }
    , wv = (i, e) => {
        var t = {};
        for (var r in i)
            $b.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && Vn)
            for (var r of Vn(i))
                e.indexOf(r) < 0 && Kb.call(i, r) && (t[r] = i[r]);
        return t
    }
    , Ze = class i extends pi {
        constructor(e) {
            e instanceof yt && (e = {
                context: e
            });
            let t = e || {}
              , {context: r, roundPixels: s} = t
              , n = wv(t, ["context", "roundPixels"]);
            super(Sv({
                label: "Graphics"
            }, n)),
            this.renderPipeId = "graphics",
            r ? this._context = r : this._context = this._ownedContext = new yt,
            this._context.on("update", this.onViewUpdate, this),
            this.didViewUpdate = !0,
            this.allowChildren = !1,
            this.roundPixels = s ?? !1
        }
        set context(e) {
            e !== this._context && (this._context.off("update", this.onViewUpdate, this),
            this._context = e,
            this._context.on("update", this.onViewUpdate, this),
            this.onViewUpdate())
        }
        get context() {
            return this._context
        }
        get bounds() {
            return this._context.bounds
        }
        updateBounds() {}
        containsPoint(e) {
            return this._context.containsPoint(e)
        }
        destroy(e) {
            this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || e?.context === !0) && this._context.destroy(e),
            this._ownedContext = null,
            this._context = null,
            super.destroy(e)
        }
        _callContextMethod(e, t) {
            return this.context[e](...t),
            this
        }
        setFillStyle(...e) {
            return this._callContextMethod("setFillStyle", e)
        }
        setStrokeStyle(...e) {
            return this._callContextMethod("setStrokeStyle", e)
        }
        fill(...e) {
            return this._callContextMethod("fill", e)
        }
        stroke(...e) {
            return this._callContextMethod("stroke", e)
        }
        texture(...e) {
            return this._callContextMethod("texture", e)
        }
        beginPath() {
            return this._callContextMethod("beginPath", [])
        }
        cut() {
            return this._callContextMethod("cut", [])
        }
        arc(...e) {
            return this._callContextMethod("arc", e)
        }
        arcTo(...e) {
            return this._callContextMethod("arcTo", e)
        }
        arcToSvg(...e) {
            return this._callContextMethod("arcToSvg", e)
        }
        bezierCurveTo(...e) {
            return this._callContextMethod("bezierCurveTo", e)
        }
        closePath() {
            return this._callContextMethod("closePath", [])
        }
        ellipse(...e) {
            return this._callContextMethod("ellipse", e)
        }
        circle(...e) {
            return this._callContextMethod("circle", e)
        }
        path(...e) {
            return this._callContextMethod("path", e)
        }
        lineTo(...e) {
            return this._callContextMethod("lineTo", e)
        }
        moveTo(...e) {
            return this._callContextMethod("moveTo", e)
        }
        quadraticCurveTo(...e) {
            return this._callContextMethod("quadraticCurveTo", e)
        }
        rect(...e) {
            return this._callContextMethod("rect", e)
        }
        roundRect(...e) {
            return this._callContextMethod("roundRect", e)
        }
        poly(...e) {
            return this._callContextMethod("poly", e)
        }
        regularPoly(...e) {
            return this._callContextMethod("regularPoly", e)
        }
        roundPoly(...e) {
            return this._callContextMethod("roundPoly", e)
        }
        roundShape(...e) {
            return this._callContextMethod("roundShape", e)
        }
        filletRect(...e) {
            return this._callContextMethod("filletRect", e)
        }
        chamferRect(...e) {
            return this._callContextMethod("chamferRect", e)
        }
        star(...e) {
            return this._callContextMethod("star", e)
        }
        svg(...e) {
            return this._callContextMethod("svg", e)
        }
        restore(...e) {
            return this._callContextMethod("restore", e)
        }
        save() {
            return this._callContextMethod("save", [])
        }
        getTransform() {
            return this.context.getTransform()
        }
        resetTransform() {
            return this._callContextMethod("resetTransform", [])
        }
        rotateTransform(...e) {
            return this._callContextMethod("rotate", e)
        }
        scaleTransform(...e) {
            return this._callContextMethod("scale", e)
        }
        setTransform(...e) {
            return this._callContextMethod("setTransform", e)
        }
        transform(...e) {
            return this._callContextMethod("transform", e)
        }
        translateTransform(...e) {
            return this._callContextMethod("translate", e)
        }
        clear() {
            return this._callContextMethod("clear", [])
        }
        get fillStyle() {
            return this._context.fillStyle
        }
        set fillStyle(e) {
            this._context.fillStyle = e
        }
        get strokeStyle() {
            return this._context.strokeStyle
        }
        set strokeStyle(e) {
            this._context.strokeStyle = e
        }
        clone(e=!1) {
            return e ? new i(this._context.clone()) : (this._ownedContext = null,
            new i(this._context))
        }
        lineStyle(e, t, r) {
            let s = {};
            return e && (s.width = e),
            t && (s.color = t),
            r && (s.alpha = r),
            this.context.strokeStyle = s,
            this
        }
        beginFill(e, t) {
            let r = {};
            return e !== void 0 && (r.color = e),
            t !== void 0 && (r.alpha = t),
            this.context.fillStyle = r,
            this
        }
        endFill() {
            this.context.fill();
            let e = this.context.strokeStyle;
            return (e.width !== yt.defaultStrokeStyle.width || e.color !== yt.defaultStrokeStyle.color || e.alpha !== yt.defaultStrokeStyle.alpha) && this.context.stroke(),
            this
        }
        drawCircle(...e) {
            return this._callContextMethod("circle", e)
        }
        drawEllipse(...e) {
            return this._callContextMethod("ellipse", e)
        }
        drawPolygon(...e) {
            return this._callContextMethod("poly", e)
        }
        drawRect(...e) {
            return this._callContextMethod("rect", e)
        }
        drawRoundedRect(...e) {
            return this._callContextMethod("roundRect", e)
        }
        drawStar(...e) {
            return this._callContextMethod("star", e)
        }
    }
    , Av = {
        name: "local-uniform-msdf-bit",
        vertex: {
            header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        },
        fragment: {
            header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
            main: `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
        }
    }, Ev = {
        name: "local-uniform-msdf-bit",
        vertex: {
            header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        },
        fragment: {
            header: `
            uniform float uDistance;
         `,
            main: `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
        }
    }, Pv = {
        name: "msdf-bit",
        fragment: {
            header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
        }
    }, Rv = {
        name: "msdf-bit",
        fragment: {
            header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
        }
    }, sc, nc, wl = class extends vt {
        constructor(e) {
            let t = new ot({
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uDistance: {
                    value: 4,
                    type: "f32"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            });
            sc != null || (sc = Ps({
                name: "sdf-shader",
                bits: [Mh, Oh(e), Av, Pv, Ms]
            })),
            nc != null || (nc = Rs({
                name: "sdf-shader",
                bits: [Ch, Ih(e), Ev, Rv, Cs]
            })),
            super({
                glProgram: nc,
                gpuProgram: sc,
                resources: {
                    localUniforms: t,
                    batchSamplers: Gh(e)
                }
            })
        }
    }
    , Wn = class extends Ot {
        constructor() {
            super(...arguments),
            this.chars = Object.create(null),
            this.lineHeight = 0,
            this.fontFamily = "",
            this.fontMetrics = {
                fontSize: 0,
                ascent: 0,
                descent: 0
            },
            this.baseLineOffset = 0,
            this.distanceField = {
                type: "none",
                range: 0
            },
            this.pages = [],
            this.applyFillAsTint = !0,
            this.baseMeasurementFontSize = 100,
            this.baseRenderedFontSize = 100
        }
        get font() {
            return this.fontFamily
        }
        get pageTextures() {
            return this.pages
        }
        get size() {
            return this.fontMetrics.fontSize
        }
        get distanceFieldRange() {
            return this.distanceField.range
        }
        get distanceFieldType() {
            return this.distanceField.type
        }
        destroy(e=!1) {
            var t;
            this.emit("destroy", this),
            this.removeAllListeners();
            for (let r in this.chars)
                (t = this.chars[r].texture) == null || t.destroy();
            this.chars = null,
            e && (this.pages.forEach(r => r.texture.destroy(!0)),
            this.pages = null)
        }
    }
    , Mv = Object.defineProperty, ff = Object.getOwnPropertySymbols, Cv = Object.prototype.hasOwnProperty, Ov = Object.prototype.propertyIsEnumerable, pf = (i, e, t) => e in i ? Mv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, bf = (i, e) => {
        for (var t in e || (e = {}))
            Cv.call(e, t) && pf(i, t, e[t]);
        if (ff)
            for (var t of ff(e))
                Ov.call(e, t) && pf(i, t, e[t]);
        return i
    }
    , qb = class Zb extends Wn {
        constructor(e) {
            var t, r, s;
            super(),
            this.resolution = 1,
            this.pages = [],
            this._padding = 0,
            this._measureCache = Object.create(null),
            this._currentChars = [],
            this._currentX = 0,
            this._currentY = 0,
            this._currentMaxCharHeight = 0,
            this._currentPageIndex = -1,
            this._skipKerning = !1;
            let n = bf(bf({}, Zb.defaultOptions), e);
            this._textureSize = n.textureSize,
            this._mipmap = n.mipmap;
            let a = n.style.clone();
            n.overrideFill && (a._fill.color = 16777215,
            a._fill.alpha = 1,
            a._fill.texture = Z.WHITE,
            a._fill.fill = null),
            this.applyFillAsTint = n.overrideFill;
            let o = a.fontSize;
            a.fontSize = this.baseMeasurementFontSize;
            let l = jn(a);
            n.overrideSize ? a._stroke && (a._stroke.width *= this.baseRenderedFontSize / o) : a.fontSize = this.baseRenderedFontSize = o,
            this._style = a,
            this._skipKerning = (t = n.skipKerning) != null ? t : !1,
            this.resolution = (r = n.resolution) != null ? r : 1,
            this._padding = (s = n.padding) != null ? s : 4,
            n.textureStyle && (this._textureStyle = n.textureStyle instanceof kt ? n.textureStyle : new kt(n.textureStyle)),
            this.fontMetrics = ft.measureFont(l),
            this.lineHeight = a.lineHeight || this.fontMetrics.fontSize || a.fontSize
        }
        ensureCharacters(e) {
            var t, r, s, n;
            let a = ft.graphemeSegmenter(e).filter(C => !this._currentChars.includes(C)).filter( (C, L, F) => F.indexOf(C) === L);
            if (!a.length)
                return;
            this._currentChars = [...this._currentChars, ...a];
            let o;
            this._currentPageIndex === -1 ? o = this._nextPage() : o = this.pages[this._currentPageIndex];
            let {canvas: l, context: u} = o.canvasAndContext
              , d = o.texture.source
              , f = this._style
              , b = this._currentX
              , m = this._currentY
              , x = this._currentMaxCharHeight
              , v = this.baseRenderedFontSize / this.baseMeasurementFontSize
              , S = this._padding * v
              , w = !1
              , E = l.width / this.resolution
              , P = l.height / this.resolution;
            for (let C = 0; C < a.length; C++) {
                let L = a[C]
                  , F = ft.measureText(L, f, l, !1);
                F.lineHeight = F.height;
                let X = F.width * v
                  , ie = Math.ceil((f.fontStyle === "italic" ? 2 : 1) * X)
                  , te = F.height * v
                  , V = ie + S * 2
                  , K = te + S * 2;
                if (w = !1,
                L !== `
` && L !== "\r" && L !== "	" && L !== " " && (w = !0,
                x = Math.ceil(Math.max(K, x))),
                b + V > E && (m += x,
                x = K,
                b = 0,
                m + x > P)) {
                    d.update();
                    let J = this._nextPage();
                    l = J.canvasAndContext.canvas,
                    u = J.canvasAndContext.context,
                    d = J.texture.source,
                    b = 0,
                    m = 0,
                    x = 0
                }
                let W = X / v - ((r = (t = f.dropShadow) == null ? void 0 : t.distance) != null ? r : 0) - ((n = (s = f._stroke) == null ? void 0 : s.width) != null ? n : 0);
                if (this.chars[L] = {
                    id: L.codePointAt(0),
                    xOffset: -this._padding,
                    yOffset: -this._padding,
                    xAdvance: W,
                    kerning: {}
                },
                w) {
                    this._drawGlyph(u, F, b + S, m + S, v, f);
                    let J = d.width * v
                      , he = d.height * v
                      , je = new Oe(b / J * d.width,m / he * d.height,V / J * d.width,K / he * d.height);
                    this.chars[L].texture = new Z({
                        source: d,
                        frame: je
                    }),
                    b += Math.ceil(V)
                }
            }
            d.update(),
            this._currentX = b,
            this._currentY = m,
            this._currentMaxCharHeight = x,
            this._skipKerning && this._applyKerning(a, u)
        }
        get pageTextures() {
            return this.pages
        }
        _applyKerning(e, t) {
            let r = this._measureCache;
            for (let s = 0; s < e.length; s++) {
                let n = e[s];
                for (let a = 0; a < this._currentChars.length; a++) {
                    let o = this._currentChars[a]
                      , l = r[n];
                    l || (l = r[n] = t.measureText(n).width);
                    let u = r[o];
                    u || (u = r[o] = t.measureText(o).width);
                    let d = t.measureText(n + o).width
                      , f = d - (l + u);
                    f && (this.chars[n].kerning[o] = f),
                    d = t.measureText(n + o).width,
                    f = d - (l + u),
                    f && (this.chars[o].kerning[n] = f)
                }
            }
        }
        _nextPage() {
            this._currentPageIndex++;
            let e = this.resolution
              , t = xi.getOptimalCanvasAndContext(this._textureSize, this._textureSize, e);
            this._setupContext(t.context, this._style, e);
            let r = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize)
              , s = new Z({
                source: new mi({
                    resource: t.canvas,
                    resolution: r,
                    alphaMode: "premultiply-alpha-on-upload",
                    autoGenerateMipmaps: this._mipmap
                })
            });
            this._textureStyle && (s.source.style = this._textureStyle);
            let n = {
                canvasAndContext: t,
                texture: s
            };
            return this.pages[this._currentPageIndex] = n,
            n
        }
        _setupContext(e, t, r) {
            var s;
            t.fontSize = this.baseRenderedFontSize,
            e.scale(r, r),
            e.font = jn(t),
            t.fontSize = this.baseMeasurementFontSize,
            e.textBaseline = t.textBaseline;
            let n = t._stroke
              , a = (s = n?.width) != null ? s : 0;
            if (n && (e.lineWidth = a,
            e.lineJoin = n.join,
            e.miterLimit = n.miterLimit,
            e.strokeStyle = Hn(n, e)),
            t._fill && (e.fillStyle = Hn(t._fill, e)),
            t.dropShadow) {
                let o = t.dropShadow
                  , l = Be.shared.setValue(o.color).toArray()
                  , u = o.blur * r
                  , d = o.distance * r;
                e.shadowColor = `rgba(${l[0] * 255},${l[1] * 255},${l[2] * 255},${o.alpha})`,
                e.shadowBlur = u,
                e.shadowOffsetX = Math.cos(o.angle) * d,
                e.shadowOffsetY = Math.sin(o.angle) * d
            } else
                e.shadowColor = "black",
                e.shadowBlur = 0,
                e.shadowOffsetX = 0,
                e.shadowOffsetY = 0
        }
        _drawGlyph(e, t, r, s, n, a) {
            var o;
            let l = t.text
              , u = t.fontProperties
              , d = a._stroke
              , f = ((o = d?.width) != null ? o : 0) * n
              , b = r + f / 2
              , m = s - f / 2
              , x = u.descent * n
              , v = t.lineHeight * n
              , S = !1;
            a.stroke && f && (S = !0,
            e.strokeText(l, b, m + v - x));
            let {shadowBlur: w, shadowOffsetX: E, shadowOffsetY: P} = e;
            a._fill && (S && (e.shadowBlur = 0,
            e.shadowOffsetX = 0,
            e.shadowOffsetY = 0),
            e.fillText(l, b, m + v - x)),
            S && (e.shadowBlur = w,
            e.shadowOffsetX = E,
            e.shadowOffsetY = P)
        }
        destroy() {
            super.destroy();
            for (let e = 0; e < this.pages.length; e++) {
                let {canvasAndContext: t, texture: r} = this.pages[e];
                xi.returnCanvasAndContext(t),
                r.destroy(!0)
            }
            this.pages = null
        }
    }
    ;
    qb.defaultOptions = {
        textureSize: 512,
        style: new Lt,
        mipmap: !0
    };
    var mf = qb;
    function Dh(i, e, t, r) {
        let s = {
            width: 0,
            height: 0,
            offsetY: 0,
            scale: e.fontSize / t.baseMeasurementFontSize,
            lines: [{
                width: 0,
                charPositions: [],
                spaceWidth: 0,
                spacesIndex: [],
                chars: []
            }]
        };
        s.offsetY = t.baseLineOffset;
        let n = s.lines[0]
          , a = null
          , o = !0
          , l = {
            spaceWord: !1,
            width: 0,
            start: 0,
            index: 0,
            positions: [],
            chars: []
        }
          , u = t.baseMeasurementFontSize / e.fontSize
          , d = e.letterSpacing * u
          , f = e.wordWrapWidth * u
          , b = e.lineHeight ? e.lineHeight * u : t.lineHeight
          , m = e.wordWrap && e.breakWords
          , x = w => {
            let E = n.width;
            for (let P = 0; P < l.index; P++) {
                let C = w.positions[P];
                n.chars.push(w.chars[P]),
                n.charPositions.push(C + E)
            }
            n.width += w.width,
            o = !1,
            l.width = 0,
            l.index = 0,
            l.chars.length = 0
        }
          , v = () => {
            let w = n.chars.length - 1;
            if (r) {
                let E = n.chars[w];
                for (; E === " "; )
                    n.width -= t.chars[E].xAdvance,
                    E = n.chars[--w]
            }
            s.width = Math.max(s.width, n.width),
            n = {
                width: 0,
                charPositions: [],
                chars: [],
                spaceWidth: 0,
                spacesIndex: []
            },
            o = !0,
            s.lines.push(n),
            s.height += b
        }
          , S = w => w - d > f;
        for (let w = 0; w < i.length + 1; w++) {
            let E, P = w === i.length;
            P || (E = i[w]);
            let C = t.chars[E] || t.chars[" "];
            if (/(?:\s)/.test(E) || E === "\r" || E === `
` || P) {
                if (!o && e.wordWrap && S(n.width + l.width) ? (v(),
                x(l),
                P || n.charPositions.push(0)) : (l.start = n.width,
                x(l),
                P || n.charPositions.push(0)),
                E === "\r" || E === `
`)
                    v();
                else if (!P) {
                    let L = C.xAdvance + (C.kerning[a] || 0) + d;
                    n.width += L,
                    n.spaceWidth = L,
                    n.spacesIndex.push(n.charPositions.length),
                    n.chars.push(E)
                }
            } else {
                let L = C.kerning[a] || 0
                  , F = C.xAdvance + L + d;
                m && S(n.width + l.width + F) && (x(l),
                v()),
                l.positions[l.index++] = l.width + L,
                l.chars.push(E),
                l.width += F
            }
            a = E
        }
        return v(),
        e.align === "center" ? Iv(s) : e.align === "right" ? Gv(s) : e.align === "justify" && Bv(s),
        s
    }
    function Iv(i) {
        for (let e = 0; e < i.lines.length; e++) {
            let t = i.lines[e]
              , r = i.width / 2 - t.width / 2;
            for (let s = 0; s < t.charPositions.length; s++)
                t.charPositions[s] += r
        }
    }
    function Gv(i) {
        for (let e = 0; e < i.lines.length; e++) {
            let t = i.lines[e]
              , r = i.width - t.width;
            for (let s = 0; s < t.charPositions.length; s++)
                t.charPositions[s] += r
        }
    }
    function Bv(i) {
        let e = i.width;
        for (let t = 0; t < i.lines.length; t++) {
            let r = i.lines[t]
              , s = 0
              , n = r.spacesIndex[s++]
              , a = 0
              , o = r.spacesIndex.length
              , l = (e - r.width) / o;
            for (let u = 0; u < r.charPositions.length; u++)
                u === n && (n = r.spacesIndex[s++],
                a += l),
                r.charPositions[u] += a
        }
    }
    function Fv(i) {
        if (i === "")
            return [];
        typeof i == "string" && (i = [i]);
        let e = [];
        for (let t = 0, r = i.length; t < r; t++) {
            let s = i[t];
            if (Array.isArray(s)) {
                if (s.length !== 2)
                    throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);
                if (s[0].length === 0 || s[1].length === 0)
                    throw new Error("[BitmapFont]: Invalid character delimiter.");
                let n = s[0].charCodeAt(0)
                  , a = s[1].charCodeAt(0);
                if (a < n)
                    throw new Error("[BitmapFont]: Invalid character range.");
                for (let o = n, l = a; o <= l; o++)
                    e.push(String.fromCharCode(o))
            } else
                e.push(...Array.from(s))
        }
        if (e.length === 0)
            throw new Error("[BitmapFont]: Empty set when resolving characters.");
        return e
    }
    var Dv = Object.defineProperty
      , gf = Object.getOwnPropertySymbols
      , kv = Object.prototype.hasOwnProperty
      , Uv = Object.prototype.propertyIsEnumerable
      , _f = (i, e, t) => e in i ? Dv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , ac = (i, e) => {
        for (var t in e || (e = {}))
            kv.call(e, t) && _f(i, t, e[t]);
        if (gf)
            for (var t of gf(e))
                Uv.call(e, t) && _f(i, t, e[t]);
        return i
    }
      , qs = 0
      , Lv = class {
        constructor() {
            this.ALPHA = [["a", "z"], ["A", "Z"], " "],
            this.NUMERIC = [["0", "9"]],
            this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "],
            this.ASCII = [[" ", "~"]],
            this.defaultOptions = {
                chars: this.ALPHANUMERIC,
                resolution: 1,
                padding: 4,
                skipKerning: !1,
                textureStyle: null
            },
            this.measureCache = Yb(1e3)
        }
        getFont(i, e) {
            var t;
            let r = `${e.fontFamily}-bitmap`
              , s = !0;
            if (e._fill.fill && !e._stroke ? (r += e._fill.fill.styleKey,
            s = !1) : (e._stroke || e.dropShadow) && (r = `${e.styleKey}-bitmap`,
            s = !1),
            !Ge.has(r)) {
                let a = Object.create(e);
                a.lineHeight = 0;
                let o = new mf(ac({
                    style: a,
                    overrideFill: s,
                    overrideSize: !0
                }, this.defaultOptions));
                qs++,
                qs > 50 && _i("BitmapText", `You have dynamically created ${qs} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),
                o.once("destroy", () => {
                    qs--,
                    Ge.remove(r)
                }
                ),
                Ge.set(r, o)
            }
            let n = Ge.get(r);
            return (t = n.ensureCharacters) == null || t.call(n, i),
            n
        }
        getLayout(i, e, t=!0) {
            let r = this.getFont(i, e)
              , s = `${i}-${e.styleKey}-${t}`;
            if (this.measureCache.has(s))
                return this.measureCache.get(s);
            let n = ft.graphemeSegmenter(i)
              , a = Dh(n, e, r, t);
            return this.measureCache.set(s, a),
            a
        }
        measureText(i, e, t=!0) {
            return this.getLayout(i, e, t)
        }
        install(...i) {
            var e, t, r, s, n;
            let a = i[0];
            typeof a == "string" && (a = {
                name: a,
                style: i[1],
                chars: (e = i[2]) == null ? void 0 : e.chars,
                resolution: (t = i[2]) == null ? void 0 : t.resolution,
                padding: (r = i[2]) == null ? void 0 : r.padding,
                skipKerning: (s = i[2]) == null ? void 0 : s.skipKerning
            });
            let o = a?.name;
            if (!o)
                throw new Error("[BitmapFontManager] Property `name` is required.");
            a = ac(ac({}, this.defaultOptions), a);
            let l = a.style
              , u = l instanceof Lt ? l : new Lt(l)
              , d = (n = a.dynamicFill) != null ? n : this._canUseTintForStyle(u)
              , f = new mf({
                style: u,
                overrideFill: d,
                skipKerning: a.skipKerning,
                padding: a.padding,
                resolution: a.resolution,
                overrideSize: !1,
                textureStyle: a.textureStyle
            })
              , b = Fv(a.chars);
            return f.ensureCharacters(b.join("")),
            Ge.set(`${o}-bitmap`, f),
            f.once("destroy", () => Ge.remove(`${o}-bitmap`)),
            f
        }
        uninstall(i) {
            let e = `${i}-bitmap`
              , t = Ge.get(e);
            t && t.destroy()
        }
        _canUseTintForStyle(i) {
            return !i._stroke && (!i.dropShadow || i.dropShadow.color === 0) && !i._fill.fill && i._fill.color === 16777215
        }
    }
      , Ts = new Lv
      , Al = class extends Ze {
        destroy() {
            this.context.customShader && this.context.customShader.destroy(),
            super.destroy()
        }
    }
      , Yn = class {
        constructor(e) {
            this._renderer = e
        }
        validateRenderable(e) {
            let t = this._getGpuBitmapText(e);
            return this._renderer.renderPipes.graphics.validateRenderable(t)
        }
        addRenderable(e, t) {
            let r = this._getGpuBitmapText(e);
            xf(e, r),
            e._didTextUpdate && (e._didTextUpdate = !1,
            this._updateContext(e, r)),
            this._renderer.renderPipes.graphics.addRenderable(r, t),
            r.context.customShader && this._updateDistanceField(e)
        }
        updateRenderable(e) {
            let t = this._getGpuBitmapText(e);
            xf(e, t),
            this._renderer.renderPipes.graphics.updateRenderable(t),
            t.context.customShader && this._updateDistanceField(e)
        }
        _updateContext(e, t) {
            let {context: r} = t
              , s = Ts.getFont(e.text, e._style);
            r.clear(),
            s.distanceField.type !== "none" && (r.customShader || (r.customShader = new wl(this._renderer.limits.maxBatchableTextures)));
            let n = ft.graphemeSegmenter(e.text)
              , a = e._style
              , o = s.baseLineOffset
              , l = Dh(n, a, s, !0)
              , u = a.padding
              , d = l.scale
              , f = l.width
              , b = l.height + l.offsetY;
            a._stroke && (f += a._stroke.width / d,
            b += a._stroke.width / d),
            r.translate(-e._anchor._x * f - u, -e._anchor._y * b - u).scale(d, d);
            let m = s.applyFillAsTint ? a._fill.color : 16777215
              , x = s.fontMetrics.fontSize
              , v = s.lineHeight;
            a.lineHeight && (x = a.fontSize / d,
            v = a.lineHeight / d);
            let S = (v - x) / 2;
            S - s.baseLineOffset < 0 && (S = 0);
            for (let w = 0; w < l.lines.length; w++) {
                let E = l.lines[w];
                for (let P = 0; P < E.charPositions.length; P++) {
                    let C = E.chars[P]
                      , L = s.chars[C];
                    if (L != null && L.texture) {
                        let F = L.texture;
                        r.texture(F, m || "black", Math.round(E.charPositions[P] + L.xOffset), Math.round(o + L.yOffset + S), F.orig.width, F.orig.height)
                    }
                }
                o += v
            }
        }
        _getGpuBitmapText(e) {
            return e._gpuData[this._renderer.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
            let t = new Al;
            return e._gpuData[this._renderer.uid] = t,
            this._updateContext(e, t),
            t
        }
        _updateDistanceField(e) {
            let t = this._getGpuBitmapText(e).context
              , r = e._style.fontFamily
              , s = Ge.get(`${r}-bitmap`)
              , {a: n, b: a, c: o, d: l} = e.groupTransform
              , u = Math.sqrt(n * n + a * a)
              , d = Math.sqrt(o * o + l * l)
              , f = (Math.abs(u) + Math.abs(d)) / 2
              , b = s.baseRenderedFontSize / e._style.fontSize
              , m = f * s.distanceField.range * (1 / b);
            t.customShader.resources.localUniforms.uniforms.uDistance = m
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Yn.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "bitmapText"
    };
    function xf(i, e) {
        e.groupTransform = i.groupTransform,
        e.groupColorAlpha = i.groupColorAlpha,
        e.groupColor = i.groupColor,
        e.groupBlendMode = i.groupBlendMode,
        e.globalDisplayStatus = i.globalDisplayStatus,
        e.groupTransform = i.groupTransform,
        e.localDisplayStatus = i.localDisplayStatus,
        e.groupAlpha = i.groupAlpha,
        e._roundPixels = i._roundPixels
    }
    be.add(Yn);
    var El = class extends wr {
        constructor(e) {
            super(),
            this.generatingTexture = !1,
            this.currentKey = "--",
            this._renderer = e,
            e.runners.resolutionChange.add(this)
        }
        resolutionChange() {
            let e = this.renderable;
            e._autoResolution && e.onViewUpdate()
        }
        destroy() {
            let {htmlText: e} = this._renderer;
            e.getReferenceCount(this.currentKey) === null ? e.returnTexturePromise(this.texturePromise) : e.decreaseReferenceCount(this.currentKey),
            this._renderer.runners.resolutionChange.remove(this),
            this.texturePromise = null,
            this._renderer = null
        }
    }
      , $n = class {
        constructor(e) {
            this._renderer = e
        }
        validateRenderable(e) {
            let t = this._getGpuText(e)
              , r = e.styleKey;
            return t.currentKey !== r
        }
        addRenderable(e, t) {
            let r = this._getGpuText(e);
            if (e._didTextUpdate) {
                let s = e._autoResolution ? this._renderer.resolution : e.resolution;
                (r.currentKey !== e.styleKey || e.resolution !== s) && this._updateGpuText(e).catch(n => {}
                ),
                e._didTextUpdate = !1,
                dl(r, e)
            }
            this._renderer.renderPipes.batch.addToBatch(r, t)
        }
        updateRenderable(e) {
            let t = this._getGpuText(e);
            t._batcher.updateElement(t)
        }
        async _updateGpuText(e) {
            e._didTextUpdate = !1;
            let t = this._getGpuText(e);
            if (t.generatingTexture)
                return;
            let r = t.texturePromise;
            t.texturePromise = null,
            t.generatingTexture = !0,
            e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution;
            let s = this._renderer.htmlText.getTexturePromise(e);
            r && (s = s.finally( () => {
                this._renderer.htmlText.decreaseReferenceCount(t.currentKey),
                this._renderer.htmlText.returnTexturePromise(r)
            }
            )),
            t.texturePromise = s,
            t.currentKey = e.styleKey,
            t.texture = await s;
            let n = e.renderGroup || e.parentRenderGroup;
            n && (n.structureDidChange = !0),
            t.generatingTexture = !1,
            dl(t, e)
        }
        _getGpuText(e) {
            return e._gpuData[this._renderer.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
            let t = new El(this._renderer);
            return t.renderable = e,
            t.transform = e.groupTransform,
            t.texture = Z.EMPTY,
            t.bounds = {
                minX: 0,
                maxX: 1,
                minY: 0,
                maxY: 0
            },
            t.roundPixels = this._renderer._roundPixels | e._roundPixels,
            e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution,
            e._gpuData[this._renderer.uid] = t,
            t
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    $n.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "htmlText"
    };
    function Nv() {
        let {userAgent: i} = ye.get().getNavigator();
        return /^((?!chrome|android).)*safari/i.test(i)
    }
    var yf = "http://www.w3.org/2000/svg"
      , vf = "http://www.w3.org/1999/xhtml"
      , Kn = class {
        constructor() {
            this.svgRoot = document.createElementNS(yf, "svg"),
            this.foreignObject = document.createElementNS(yf, "foreignObject"),
            this.domElement = document.createElementNS(vf, "div"),
            this.styleElement = document.createElementNS(vf, "style");
            let {foreignObject: e, svgRoot: t, styleElement: r, domElement: s} = this;
            e.setAttribute("width", "10000"),
            e.setAttribute("height", "10000"),
            e.style.overflow = "hidden",
            t.appendChild(e),
            e.appendChild(r),
            e.appendChild(s),
            this.image = ye.get().createImage()
        }
        destroy() {
            this.svgRoot.remove(),
            this.foreignObject.remove(),
            this.styleElement.remove(),
            this.domElement.remove(),
            this.image.src = "",
            this.image.remove(),
            this.svgRoot = null,
            this.foreignObject = null,
            this.styleElement = null,
            this.domElement = null,
            this.image = null,
            this.canvasAndContext = null
        }
    }
    ;
    function Xv(i, e) {
        let t = e.fontFamily
          , r = []
          , s = {}
          , n = /font-family:([^;"\s]+)/g
          , a = i.match(n);
        function o(l) {
            s[l] || (r.push(l),
            s[l] = !0)
        }
        if (Array.isArray(t))
            for (let l = 0; l < t.length; l++)
                o(t[l]);
        else
            o(t);
        a && a.forEach(l => {
            let u = l.split(":")[1].trim();
            o(u)
        }
        );
        for (let l in e.tagStyles) {
            let u = e.tagStyles[l].fontFamily;
            o(u)
        }
        return r
    }
    async function jv(i) {
        let e = await (await ye.get().fetch(i)).blob()
          , t = new FileReader;
        return await new Promise( (r, s) => {
            t.onloadend = () => r(t.result),
            t.onerror = s,
            t.readAsDataURL(e)
        }
        )
    }
    async function Hv(i, e) {
        let t = await jv(e);
        return `@font-face {
        font-family: "${i.fontFamily}";
        font-weight: ${i.fontWeight};
        font-style: ${i.fontStyle};
        src: url('${t}');
    }`
    }
    var oc = new Map;
    async function zv(i) {
        let e = i.filter(t => Ge.has(`${t}-and-url`)).map(t => {
            if (!oc.has(t)) {
                let {entries: r} = Ge.get(`${t}-and-url`)
                  , s = [];
                r.forEach(n => {
                    let a = n.url
                      , o = n.faces.map(l => ({
                        weight: l.weight,
                        style: l.style
                    }));
                    s.push(...o.map(l => Hv({
                        fontWeight: l.weight,
                        fontStyle: l.style,
                        fontFamily: t
                    }, a)))
                }
                ),
                oc.set(t, Promise.all(s).then(n => n.join(`
`)))
            }
            return oc.get(t)
        }
        );
        return (await Promise.all(e)).join(`
`)
    }
    function Vv(i, e, t, r, s) {
        let {domElement: n, styleElement: a, svgRoot: o} = s;
        n.innerHTML = `<style>${e.cssStyle}</style><div style='padding:0;'>${i}</div>`,
        n.setAttribute("style", `transform: scale(${t});transform-origin: top left; display: inline-block`),
        a.textContent = r;
        let {width: l, height: u} = s.image;
        return o.setAttribute("width", l.toString()),
        o.setAttribute("height", u.toString()),
        new XMLSerializer().serializeToString(o)
    }
    function Wv(i, e) {
        let t = xi.getOptimalCanvasAndContext(i.width, i.height, e)
          , {context: r} = t;
        return r.clearRect(0, 0, i.width, i.height),
        r.drawImage(i, 0, 0),
        t
    }
    function Yv(i, e, t) {
        return new Promise(async r => {
            t && await new Promise(s => setTimeout(s, 100)),
            i.onload = () => {
                r()
            }
            ,
            i.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`,
            i.crossOrigin = "anonymous"
        }
        )
    }
    var Tf;
    function Qb(i, e, t, r) {
        r || (r = Tf || (Tf = new Kn));
        let {domElement: s, styleElement: n, svgRoot: a} = r;
        s.innerHTML = `<style>${e.cssStyle};</style><div style='padding:0'>${i}</div>`,
        s.setAttribute("style", "transform-origin: top left; display: inline-block"),
        t && (n.textContent = t),
        document.body.appendChild(a);
        let o = s.getBoundingClientRect();
        a.remove();
        let l = e.padding * 2;
        return {
            width: o.width - l,
            height: o.height - l
        }
    }
    var qn = class {
        constructor(e) {
            this._activeTextures = {},
            this._renderer = e,
            this._createCanvas = e.type === Ct.WEBGPU
        }
        getTexture(e) {
            return this.getTexturePromise(e)
        }
        getManagedTexture(e) {
            let t = e.styleKey;
            if (this._activeTextures[t])
                return this._increaseReferenceCount(t),
                this._activeTextures[t].promise;
            let r = this._buildTexturePromise(e).then(s => (this._activeTextures[t].texture = s,
            s));
            return this._activeTextures[t] = {
                texture: null,
                promise: r,
                usageCount: 1
            },
            r
        }
        getReferenceCount(e) {
            var t, r;
            return (r = (t = this._activeTextures[e]) == null ? void 0 : t.usageCount) != null ? r : null
        }
        _increaseReferenceCount(e) {
            this._activeTextures[e].usageCount++
        }
        decreaseReferenceCount(e) {
            let t = this._activeTextures[e];
            t && (t.usageCount--,
            t.usageCount === 0 && (t.texture ? this._cleanUp(t.texture) : t.promise.then(r => {
                t.texture = r,
                this._cleanUp(t.texture)
            }
            ).catch( () => {}
            ),
            this._activeTextures[e] = null))
        }
        getTexturePromise(e) {
            return this._buildTexturePromise(e)
        }
        async _buildTexturePromise(e) {
            let {text: t, style: r, resolution: s, textureStyle: n} = e
              , a = Je.get(Kn)
              , o = Xv(t, r)
              , l = await zv(o)
              , u = Qb(t, r, l, a)
              , d = Math.ceil(Math.ceil(Math.max(1, u.width) + r.padding * 2) * s)
              , f = Math.ceil(Math.ceil(Math.max(1, u.height) + r.padding * 2) * s)
              , b = a.image
              , m = 2;
            b.width = (d | 0) + m,
            b.height = (f | 0) + m;
            let x = Vv(t, r, s, l, a);
            await Yv(b, x, Nv() && o.length > 0);
            let v = b, S;
            this._createCanvas && (S = Wv(b, s));
            let w = Wb(S ? S.canvas : v, b.width - m, b.height - m, s);
            return n && (w.source.style = n),
            this._createCanvas && (this._renderer.texture.initSource(w.source),
            xi.returnCanvasAndContext(S)),
            Je.return(a),
            w
        }
        returnTexturePromise(e) {
            e.then(t => {
                this._cleanUp(t)
            }
            ).catch( () => {}
            )
        }
        _cleanUp(e) {
            Ke.returnTexture(e, !0),
            e.source.resource = null,
            e.source.uploadMethodId = "unknown"
        }
        destroy() {
            this._renderer = null;
            for (let e in this._activeTextures)
                this._activeTextures[e] && this.returnTexturePromise(this._activeTextures[e].promise);
            this._activeTextures = null
        }
    }
    ;
    qn.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "htmlText"
    },
    be.add(qn),
    be.add($n);
    var $v = Object.defineProperty
      , Sf = Object.getOwnPropertySymbols
      , Kv = Object.prototype.hasOwnProperty
      , qv = Object.prototype.propertyIsEnumerable
      , wf = (i, e, t) => e in i ? $v(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Af = (i, e) => {
        for (var t in e || (e = {}))
            Kv.call(e, t) && wf(i, t, e[t]);
        if (Sf)
            for (var t of Sf(e))
                qv.call(e, t) && wf(i, t, e[t]);
        return i
    }
      , Jb = class em extends si {
        constructor(...e) {
            var t;
            let r = (t = e[0]) != null ? t : {};
            r instanceof Float32Array && (r = {
                positions: r,
                uvs: e[1],
                indices: e[2]
            }),
            r = Af(Af({}, em.defaultOptions), r);
            let s = r.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
              , n = r.uvs;
            n || (r.positions ? n = new Float32Array(s.length) : n = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]));
            let a = r.indices || new Uint32Array([0, 1, 2, 0, 2, 3])
              , o = r.shrinkBuffersToFit
              , l = new bt({
                data: s,
                label: "attribute-mesh-positions",
                shrinkToFit: o,
                usage: Pe.VERTEX | Pe.COPY_DST
            })
              , u = new bt({
                data: n,
                label: "attribute-mesh-uvs",
                shrinkToFit: o,
                usage: Pe.VERTEX | Pe.COPY_DST
            })
              , d = new bt({
                data: a,
                label: "index-mesh-buffer",
                shrinkToFit: o,
                usage: Pe.INDEX | Pe.COPY_DST
            });
            super({
                attributes: {
                    aPosition: {
                        buffer: l,
                        format: "float32x2",
                        stride: 8,
                        offset: 0
                    },
                    aUV: {
                        buffer: u,
                        format: "float32x2",
                        stride: 8,
                        offset: 0
                    }
                },
                indexBuffer: d,
                topology: r.topology
            }),
            this.batchMode = "auto"
        }
        get positions() {
            return this.attributes.aPosition.buffer.data
        }
        set positions(e) {
            this.attributes.aPosition.buffer.data = e
        }
        get uvs() {
            return this.attributes.aUV.buffer.data
        }
        set uvs(e) {
            this.attributes.aUV.buffer.data = e
        }
        get indices() {
            return this.indexBuffer.data
        }
        set indices(e) {
            this.indexBuffer.data = e
        }
    }
    ;
    Jb.defaultOptions = {
        topology: "triangle-list",
        shrinkBuffersToFit: !1
    };
    var Is = Jb, Zv = Object.defineProperty, Qv = Object.defineProperties, Jv = Object.getOwnPropertyDescriptors, Ef = Object.getOwnPropertySymbols, e3 = Object.prototype.hasOwnProperty, t3 = Object.prototype.propertyIsEnumerable, Pf = (i, e, t) => e in i ? Zv(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, Rf = (i, e) => {
        for (var t in e || (e = {}))
            e3.call(e, t) && Pf(i, t, e[t]);
        if (Ef)
            for (var t of Ef(e))
                t3.call(e, t) && Pf(i, t, e[t]);
        return i
    }
    , Mf = (i, e) => Qv(i, Jv(e)), ls = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
    }, i3 = Mf(Rf({}, ls), {
        vertex: Mf(Rf({}, ls.vertex), {
            header: ls.vertex.header.replace("group(1)", "group(2)")
        })
    }), kh = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
    }, r3 = {
        name: "tiling-bit",
        vertex: {
            header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
            main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        },
        fragment: {
            header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
            main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        }
    }, s3 = {
        name: "tiling-bit",
        vertex: {
            header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
            main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        },
        fragment: {
            header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
            main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
        }
    }, cc, lc, Pl = class extends vt {
        constructor() {
            cc != null || (cc = Ps({
                name: "tiling-sprite-shader",
                bits: [ls, r3, Ms]
            })),
            lc != null || (lc = Rs({
                name: "tiling-sprite-shader",
                bits: [kh, s3, Cs]
            }));
            let e = new ot({
                uMapCoord: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uClampFrame: {
                    value: new Float32Array([0, 0, 1, 1]),
                    type: "vec4<f32>"
                },
                uClampOffset: {
                    value: new Float32Array([0, 0]),
                    type: "vec2<f32>"
                },
                uTextureTransform: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uSizeAnchor: {
                    value: new Float32Array([100, 100, .5, .5]),
                    type: "vec4<f32>"
                }
            });
            super({
                glProgram: lc,
                gpuProgram: cc,
                resources: {
                    localUniforms: new ot({
                        uTransformMatrix: {
                            value: new ce,
                            type: "mat3x3<f32>"
                        },
                        uColor: {
                            value: new Float32Array([1, 1, 1, 1]),
                            type: "vec4<f32>"
                        },
                        uRound: {
                            value: 0,
                            type: "f32"
                        }
                    }),
                    tilingUniforms: e,
                    uTexture: Z.EMPTY.source,
                    uSampler: Z.EMPTY.source.style
                }
            })
        }
        updateUniforms(e, t, r, s, n, a) {
            let o = this.resources.tilingUniforms
              , l = a.width
              , u = a.height
              , d = a.textureMatrix
              , f = o.uniforms.uTextureTransform;
            f.set(r.a * l / e, r.b * l / t, r.c * u / e, r.d * u / t, r.tx / e, r.ty / t),
            f.invert(),
            o.uniforms.uMapCoord = d.mapCoord,
            o.uniforms.uClampFrame = d.uClampFrame,
            o.uniforms.uClampOffset = d.uClampOffset,
            o.uniforms.uTextureTransform = f,
            o.uniforms.uSizeAnchor[0] = e,
            o.uniforms.uSizeAnchor[1] = t,
            o.uniforms.uSizeAnchor[2] = s,
            o.uniforms.uSizeAnchor[3] = n,
            a && (this.resources.uTexture = a.source,
            this.resources.uSampler = a.source.style)
        }
    }
    , Rl = class extends Is {
        constructor() {
            super({
                positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                indices: new Uint32Array([0, 1, 2, 0, 2, 3])
            })
        }
    }
    ;
    function n3(i, e) {
        let t = i.anchor.x
          , r = i.anchor.y;
        e[0] = -t * i.width,
        e[1] = -r * i.height,
        e[2] = (1 - t) * i.width,
        e[3] = -r * i.height,
        e[4] = (1 - t) * i.width,
        e[5] = (1 - r) * i.height,
        e[6] = -t * i.width,
        e[7] = (1 - r) * i.height
    }
    function a3(i, e, t, r) {
        let s = 0
          , n = i.length / (e || 2)
          , a = r.a
          , o = r.b
          , l = r.c
          , u = r.d
          , d = r.tx
          , f = r.ty;
        for (t *= e; s < n; ) {
            let b = i[t]
              , m = i[t + 1];
            i[t] = a * b + l * m + d,
            i[t + 1] = o * b + u * m + f,
            t += e,
            s++
        }
    }
    function o3(i, e) {
        let t = i.texture
          , r = t.frame.width
          , s = t.frame.height
          , n = 0
          , a = 0;
        i.applyAnchorToTexture && (n = i.anchor.x,
        a = i.anchor.y),
        e[0] = e[6] = -n,
        e[2] = e[4] = 1 - n,
        e[1] = e[3] = -a,
        e[5] = e[7] = 1 - a;
        let o = ce.shared;
        o.copyFrom(i._tileTransform.matrix),
        o.tx /= i.width,
        o.ty /= i.height,
        o.invert(),
        o.scale(i.width / r, i.height / s),
        a3(e, 2, 0, o)
    }
    var ln = new Rl
      , Ml = class {
        constructor() {
            this.canBatch = !0,
            this.geometry = new Is({
                indices: ln.indices.slice(),
                positions: ln.positions.slice(),
                uvs: ln.uvs.slice()
            })
        }
        destroy() {
            var e;
            this.geometry.destroy(),
            (e = this.shader) == null || e.destroy()
        }
    }
      , Zn = class {
        constructor(e) {
            this._state = Ut.default2d,
            this._renderer = e
        }
        validateRenderable(e) {
            let t = this._getTilingSpriteData(e)
              , r = t.canBatch;
            this._updateCanBatch(e);
            let s = t.canBatch;
            if (s && s === r) {
                let {batchableMesh: n} = t;
                return !n._batcher.checkAndUpdateTexture(n, e.texture)
            }
            return r !== s
        }
        addRenderable(e, t) {
            let r = this._renderer.renderPipes.batch;
            this._updateCanBatch(e);
            let s = this._getTilingSpriteData(e)
              , {geometry: n, canBatch: a} = s;
            if (a) {
                s.batchableMesh || (s.batchableMesh = new vs);
                let o = s.batchableMesh;
                e.didViewUpdate && (this._updateBatchableMesh(e),
                o.geometry = n,
                o.renderable = e,
                o.transform = e.groupTransform,
                o.setTexture(e._texture)),
                o.roundPixels = this._renderer._roundPixels | e._roundPixels,
                r.addToBatch(o, t)
            } else
                r.break(t),
                s.shader || (s.shader = new Pl),
                this.updateRenderable(e),
                t.add(e)
        }
        execute(e) {
            let {shader: t} = this._getTilingSpriteData(e);
            t.groups[0] = this._renderer.globalUniforms.bindGroup;
            let r = t.resources.localUniforms.uniforms;
            r.uTransformMatrix = e.groupTransform,
            r.uRound = this._renderer._roundPixels | e._roundPixels,
            Os(e.groupColorAlpha, r.uColor, 0),
            this._state.blendMode = ps(e.groupBlendMode, e.texture._source),
            this._renderer.encoder.draw({
                geometry: ln,
                shader: t,
                state: this._state
            })
        }
        updateRenderable(e) {
            let t = this._getTilingSpriteData(e)
              , {canBatch: r} = t;
            if (r) {
                let {batchableMesh: s} = t;
                e.didViewUpdate && this._updateBatchableMesh(e),
                s._batcher.updateElement(s)
            } else if (e.didViewUpdate) {
                let {shader: s} = t;
                s.updateUniforms(e.width, e.height, e._tileTransform.matrix, e.anchor.x, e.anchor.y, e.texture)
            }
        }
        _getTilingSpriteData(e) {
            return e._gpuData[this._renderer.uid] || this._initTilingSpriteData(e)
        }
        _initTilingSpriteData(e) {
            let t = new Ml;
            return t.renderable = e,
            e._gpuData[this._renderer.uid] = t,
            t
        }
        _updateBatchableMesh(e) {
            let t = this._getTilingSpriteData(e)
              , {geometry: r} = t
              , s = e.texture.source.style;
            s.addressMode !== "repeat" && (s.addressMode = "repeat",
            s.update()),
            o3(e, r.uvs),
            n3(e, r.positions)
        }
        destroy() {
            this._renderer = null
        }
        _updateCanBatch(e) {
            let t = this._getTilingSpriteData(e)
              , r = e.texture
              , s = !0;
            return this._renderer.type === Ct.WEBGL && (s = this._renderer.context.supports.nonPowOf2wrapping),
            t.canBatch = r.textureMatrix.isSimple && (s || r.source.isPowerOfTwo),
            t.canBatch
        }
    }
    ;
    Zn.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "tilingSprite"
    },
    be.add(Zn);
    var c3 = Object.defineProperty
      , Cf = Object.getOwnPropertySymbols
      , l3 = Object.prototype.hasOwnProperty
      , h3 = Object.prototype.propertyIsEnumerable
      , Of = (i, e, t) => e in i ? c3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , If = (i, e) => {
        for (var t in e || (e = {}))
            l3.call(e, t) && Of(i, t, e[t]);
        if (Cf)
            for (var t of Cf(e))
                h3.call(e, t) && Of(i, t, e[t]);
        return i
    }
      , tm = class im extends Is {
        constructor(...e) {
            var t;
            super({});
            let r = (t = e[0]) != null ? t : {};
            typeof r == "number" && (r = {
                width: r,
                height: e[1],
                verticesX: e[2],
                verticesY: e[3]
            }),
            this.build(r)
        }
        build(e) {
            var t, r, s, n;
            e = If(If({}, im.defaultOptions), e),
            this.verticesX = (t = this.verticesX) != null ? t : e.verticesX,
            this.verticesY = (r = this.verticesY) != null ? r : e.verticesY,
            this.width = (s = this.width) != null ? s : e.width,
            this.height = (n = this.height) != null ? n : e.height;
            let a = this.verticesX * this.verticesY
              , o = []
              , l = []
              , u = []
              , d = this.verticesX - 1
              , f = this.verticesY - 1
              , b = this.width / d
              , m = this.height / f;
            for (let v = 0; v < a; v++) {
                let S = v % this.verticesX
                  , w = v / this.verticesX | 0;
                o.push(S * b, w * m),
                l.push(S / d, w / f)
            }
            let x = d * f;
            for (let v = 0; v < x; v++) {
                let S = v % d
                  , w = v / d | 0
                  , E = w * this.verticesX + S
                  , P = w * this.verticesX + S + 1
                  , C = (w + 1) * this.verticesX + S
                  , L = (w + 1) * this.verticesX + S + 1;
                u.push(E, P, C, P, L, C)
            }
            this.buffers[0].data = new Float32Array(o),
            this.buffers[1].data = new Float32Array(l),
            this.indexBuffer.data = new Uint32Array(u),
            this.buffers[0].update(),
            this.buffers[1].update(),
            this.indexBuffer.update()
        }
    }
    ;
    tm.defaultOptions = {
        width: 100,
        height: 100,
        verticesX: 10,
        verticesY: 10
    };
    var rm = tm
      , u3 = Object.defineProperty
      , Gf = Object.getOwnPropertySymbols
      , d3 = Object.prototype.hasOwnProperty
      , f3 = Object.prototype.propertyIsEnumerable
      , Bf = (i, e, t) => e in i ? u3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Ff = (i, e) => {
        for (var t in e || (e = {}))
            d3.call(e, t) && Bf(i, t, e[t]);
        if (Gf)
            for (var t of Gf(e))
                f3.call(e, t) && Bf(i, t, e[t]);
        return i
    }
      , sm = class nm extends rm {
        constructor(e={}) {
            e = Ff(Ff({}, nm.defaultOptions), e),
            super({
                width: e.width,
                height: e.height,
                verticesX: 4,
                verticesY: 4
            }),
            this.update(e)
        }
        update(e) {
            var t, r, s, n, a, o, l, u, d, f;
            this.width = (t = e.width) != null ? t : this.width,
            this.height = (r = e.height) != null ? r : this.height,
            this._originalWidth = (s = e.originalWidth) != null ? s : this._originalWidth,
            this._originalHeight = (n = e.originalHeight) != null ? n : this._originalHeight,
            this._leftWidth = (a = e.leftWidth) != null ? a : this._leftWidth,
            this._rightWidth = (o = e.rightWidth) != null ? o : this._rightWidth,
            this._topHeight = (l = e.topHeight) != null ? l : this._topHeight,
            this._bottomHeight = (u = e.bottomHeight) != null ? u : this._bottomHeight,
            this._anchorX = (d = e.anchor) == null ? void 0 : d.x,
            this._anchorY = (f = e.anchor) == null ? void 0 : f.y,
            this.updateUvs(),
            this.updatePositions()
        }
        updatePositions() {
            let e = this.positions
              , {width: t, height: r, _leftWidth: s, _rightWidth: n, _topHeight: a, _bottomHeight: o, _anchorX: l, _anchorY: u} = this
              , d = s + n
              , f = t > d ? 1 : t / d
              , b = a + o
              , m = r > b ? 1 : r / b
              , x = Math.min(f, m)
              , v = l * t
              , S = u * r;
            e[0] = e[8] = e[16] = e[24] = -v,
            e[2] = e[10] = e[18] = e[26] = s * x - v,
            e[4] = e[12] = e[20] = e[28] = t - n * x - v,
            e[6] = e[14] = e[22] = e[30] = t - v,
            e[1] = e[3] = e[5] = e[7] = -S,
            e[9] = e[11] = e[13] = e[15] = a * x - S,
            e[17] = e[19] = e[21] = e[23] = r - o * x - S,
            e[25] = e[27] = e[29] = e[31] = r - S,
            this.getBuffer("aPosition").update()
        }
        updateUvs() {
            let e = this.uvs;
            e[0] = e[8] = e[16] = e[24] = 0,
            e[1] = e[3] = e[5] = e[7] = 0,
            e[6] = e[14] = e[22] = e[30] = 1,
            e[25] = e[27] = e[29] = e[31] = 1;
            let t = 1 / this._originalWidth
              , r = 1 / this._originalHeight;
            e[2] = e[10] = e[18] = e[26] = t * this._leftWidth,
            e[9] = e[11] = e[13] = e[15] = r * this._topHeight,
            e[4] = e[12] = e[20] = e[28] = 1 - t * this._rightWidth,
            e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight,
            this.getBuffer("aUV").update()
        }
    }
    ;
    sm.defaultOptions = {
        width: 100,
        height: 100,
        leftWidth: 10,
        topHeight: 10,
        rightWidth: 10,
        bottomHeight: 10,
        originalWidth: 100,
        originalHeight: 100
    };
    var Wi = sm
      , Cl = class extends vs {
        constructor() {
            super(),
            this.geometry = new Wi
        }
        destroy() {
            this.geometry.destroy()
        }
    }
      , Qn = class {
        constructor(e) {
            this._renderer = e
        }
        addRenderable(e, t) {
            let r = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, r),
            this._renderer.renderPipes.batch.addToBatch(r, t)
        }
        updateRenderable(e) {
            let t = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, t),
            t._batcher.updateElement(t)
        }
        validateRenderable(e) {
            let t = this._getGpuSprite(e);
            return !t._batcher.checkAndUpdateTexture(t, e._texture)
        }
        _updateBatchableSprite(e, t) {
            t.geometry.update(e),
            t.setTexture(e._texture)
        }
        _getGpuSprite(e) {
            return e._gpuData[this._renderer.uid] || this._initGPUSprite(e)
        }
        _initGPUSprite(e) {
            let t = e._gpuData[this._renderer.uid] = new Cl
              , r = t;
            return r.renderable = e,
            r.transform = e.groupTransform,
            r.texture = e._texture,
            r.roundPixels = this._renderer._roundPixels | e._roundPixels,
            e.didViewUpdate || this._updateBatchableSprite(e, r),
            t
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Qn.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "nineSliceSprite"
    },
    be.add(Qn);
    var Jn = class {
        constructor(e) {
            this._renderer = e
        }
        push(e, t, r) {
            this._renderer.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "filter",
                canBundle: !1,
                action: "pushFilter",
                container: t,
                filterEffect: e
            })
        }
        pop(e, t, r) {
            this._renderer.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "filter",
                action: "popFilter",
                canBundle: !1
            })
        }
        execute(e) {
            e.action === "pushFilter" ? this._renderer.filter.push(e) : e.action === "popFilter" && this._renderer.filter.pop()
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Jn.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "filter"
    };
    function Df(i, e, t, r, s, n, a, o) {
        let l = a - t
          , u = o - r
          , d = s - t
          , f = n - r
          , b = i - t
          , m = e - r
          , x = l * l + u * u
          , v = l * d + u * f
          , S = l * b + u * m
          , w = d * d + f * f
          , E = d * b + f * m
          , P = 1 / (x * w - v * v)
          , C = (w * S - v * E) * P
          , L = (x * E - v * S) * P;
        return C >= 0 && L >= 0 && C + L < 1
    }
    var kf = new ce;
    function p3(i, e) {
        var t;
        e.clear();
        let r = e.matrix;
        for (let s = 0; s < i.length; s++) {
            let n = i[s];
            if (n.globalDisplayStatus < 7)
                continue;
            let a = (t = n.renderGroup) != null ? t : n.parentRenderGroup;
            a != null && a.isCachedAsTexture ? e.matrix = kf.copyFrom(a.textureOffsetInverseTransform).append(n.worldTransform) : a != null && a._parentCacheAsTextureRenderGroup ? e.matrix = kf.copyFrom(a._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(n.groupTransform) : e.matrix = n.worldTransform,
            e.addBounds(n.bounds)
        }
        return e.matrix = r,
        e
    }
    var b3 = new si({
        attributes: {
            aPosition: {
                buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                format: "float32x2",
                stride: 8,
                offset: 0
            }
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
    })
      , m3 = class {
        constructor() {
            this.skip = !1,
            this.inputTexture = null,
            this.backTexture = null,
            this.filters = null,
            this.bounds = new at,
            this.container = null,
            this.blendRequired = !1,
            this.outputRenderSurface = null,
            this.globalFrame = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        }
    }
      , ea = class {
        constructor(e) {
            this._filterStackIndex = 0,
            this._filterStack = [],
            this._filterGlobalUniforms = new ot({
                uInputSize: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uInputPixel: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uInputClamp: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uOutputFrame: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uGlobalFrame: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uOutputTexture: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                }
            }),
            this._globalFilterBindGroup = new Yt({}),
            this.renderer = e
        }
        get activeBackTexture() {
            var e;
            return (e = this._activeFilterData) == null ? void 0 : e.backTexture
        }
        push(e) {
            let t = this.renderer
              , r = e.filterEffect.filters
              , s = this._pushFilterData();
            s.skip = !1,
            s.filters = r,
            s.container = e.container,
            s.outputRenderSurface = t.renderTarget.renderSurface;
            let n = t.renderTarget.renderTarget.colorTexture.source
              , a = n.resolution
              , o = n.antialias;
            if (r.length === 0) {
                s.skip = !0;
                return
            }
            let l = s.bounds;
            if (this._calculateFilterArea(e, l),
            this._calculateFilterBounds(s, t.renderTarget.rootViewPort, o, a, 1),
            s.skip)
                return;
            let u = this._getPreviousFilterData()
              , d = this._findFilterResolution(a)
              , f = 0
              , b = 0;
            u && (f = u.bounds.minX,
            b = u.bounds.minY),
            this._calculateGlobalFrame(s, f, b, d, n.width, n.height),
            this._setupFilterTextures(s, l, t, u)
        }
        generateFilteredTexture({texture: e, filters: t}) {
            let r = this._pushFilterData();
            this._activeFilterData = r,
            r.skip = !1,
            r.filters = t;
            let s = e.source
              , n = s.resolution
              , a = s.antialias;
            if (t.length === 0)
                return r.skip = !0,
                e;
            let o = r.bounds;
            if (o.addRect(e.frame),
            this._calculateFilterBounds(r, o.rectangle, a, n, 0),
            r.skip)
                return e;
            let l = n;
            this._calculateGlobalFrame(r, 0, 0, l, s.width, s.height),
            r.outputRenderSurface = Ke.getOptimalTexture(o.width, o.height, r.resolution, r.antialias),
            r.backTexture = Z.EMPTY,
            r.inputTexture = e,
            this.renderer.renderTarget.finishRenderPass(),
            this._applyFiltersToTexture(r, !0);
            let f = r.outputRenderSurface;
            return f.source.alphaMode = "premultiplied-alpha",
            f
        }
        pop() {
            let e = this.renderer
              , t = this._popFilterData();
            t.skip || (e.globalUniforms.pop(),
            e.renderTarget.finishRenderPass(),
            this._activeFilterData = t,
            this._applyFiltersToTexture(t, !1),
            t.blendRequired && Ke.returnTexture(t.backTexture),
            Ke.returnTexture(t.inputTexture))
        }
        getBackTexture(e, t, r) {
            let s = e.colorTexture.source._resolution
              , n = Ke.getOptimalTexture(t.width, t.height, s, !1)
              , a = t.minX
              , o = t.minY;
            r && (a -= r.minX,
            o -= r.minY),
            a = Math.floor(a * s),
            o = Math.floor(o * s);
            let l = Math.ceil(t.width * s)
              , u = Math.ceil(t.height * s);
            return this.renderer.renderTarget.copyToTexture(e, n, {
                x: a,
                y: o
            }, {
                width: l,
                height: u
            }, {
                x: 0,
                y: 0
            }),
            n
        }
        applyFilter(e, t, r, s) {
            let n = this.renderer
              , a = this._activeFilterData
              , o = a.outputRenderSurface === r
              , l = n.renderTarget.rootRenderTarget.colorTexture.source._resolution
              , u = this._findFilterResolution(l)
              , d = 0
              , f = 0;
            if (o) {
                let b = this._findPreviousFilterOffset();
                d = b.x,
                f = b.y
            }
            this._updateFilterUniforms(t, r, a, d, f, u, o, s),
            this._setupBindGroupsAndRender(e, t, n)
        }
        calculateSpriteMatrix(e, t) {
            let r = this._activeFilterData
              , s = e.set(r.inputTexture._source.width, 0, 0, r.inputTexture._source.height, r.bounds.minX, r.bounds.minY)
              , n = t.worldTransform.copyTo(ce.shared)
              , a = t.renderGroup || t.parentRenderGroup;
            return a && a.cacheToLocalTransform && n.prepend(a.cacheToLocalTransform),
            n.invert(),
            s.prepend(n),
            s.scale(1 / t.texture.orig.width, 1 / t.texture.orig.height),
            s.translate(t.anchor.x, t.anchor.y),
            s
        }
        destroy() {}
        _setupBindGroupsAndRender(e, t, r) {
            if (r.renderPipes.uniformBatch) {
                let s = r.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
                this._globalFilterBindGroup.setResource(s, 0)
            } else
                this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
            this._globalFilterBindGroup.setResource(t.source, 1),
            this._globalFilterBindGroup.setResource(t.source.style, 2),
            e.groups[0] = this._globalFilterBindGroup,
            r.encoder.draw({
                geometry: b3,
                shader: e,
                state: e._state,
                topology: "triangle-list"
            }),
            r.type === Ct.WEBGL && r.renderTarget.finishRenderPass()
        }
        _setupFilterTextures(e, t, r, s) {
            if (e.backTexture = Z.EMPTY,
            e.inputTexture = Ke.getOptimalTexture(t.width, t.height, e.resolution, e.antialias),
            e.blendRequired) {
                r.renderTarget.finishRenderPass();
                let n = r.renderTarget.getRenderTarget(e.outputRenderSurface);
                e.backTexture = this.getBackTexture(n, t, s?.bounds)
            }
            r.renderTarget.bind(e.inputTexture, !0),
            r.globalUniforms.push({
                offset: t
            })
        }
        _calculateGlobalFrame(e, t, r, s, n, a) {
            let o = e.globalFrame;
            o.x = t * s,
            o.y = r * s,
            o.width = n * s,
            o.height = a * s
        }
        _updateFilterUniforms(e, t, r, s, n, a, o, l) {
            let u = this._filterGlobalUniforms.uniforms
              , d = u.uOutputFrame
              , f = u.uInputSize
              , b = u.uInputPixel
              , m = u.uInputClamp
              , x = u.uGlobalFrame
              , v = u.uOutputTexture;
            o ? (d[0] = r.bounds.minX - s,
            d[1] = r.bounds.minY - n) : (d[0] = 0,
            d[1] = 0),
            d[2] = e.frame.width,
            d[3] = e.frame.height,
            f[0] = e.source.width,
            f[1] = e.source.height,
            f[2] = 1 / f[0],
            f[3] = 1 / f[1],
            b[0] = e.source.pixelWidth,
            b[1] = e.source.pixelHeight,
            b[2] = 1 / b[0],
            b[3] = 1 / b[1],
            m[0] = .5 * b[2],
            m[1] = .5 * b[3],
            m[2] = e.frame.width * f[2] - .5 * b[2],
            m[3] = e.frame.height * f[3] - .5 * b[3];
            let S = this.renderer.renderTarget.rootRenderTarget.colorTexture;
            x[0] = s * a,
            x[1] = n * a,
            x[2] = S.source.width * a,
            x[3] = S.source.height * a,
            t instanceof Z && (t.source.resource = null);
            let w = this.renderer.renderTarget.getRenderTarget(t);
            this.renderer.renderTarget.bind(t, !!l),
            t instanceof Z ? (v[0] = t.frame.width,
            v[1] = t.frame.height) : (v[0] = w.width,
            v[1] = w.height),
            v[2] = w.isRoot ? -1 : 1,
            this._filterGlobalUniforms.update()
        }
        _findFilterResolution(e) {
            let t = this._filterStackIndex - 1;
            for (; t > 0 && this._filterStack[t].skip; )
                --t;
            return t > 0 && this._filterStack[t].inputTexture ? this._filterStack[t].inputTexture.source._resolution : e
        }
        _findPreviousFilterOffset() {
            let e = 0
              , t = 0
              , r = this._filterStackIndex;
            for (; r > 0; ) {
                r--;
                let s = this._filterStack[r];
                if (!s.skip) {
                    e = s.bounds.minX,
                    t = s.bounds.minY;
                    break
                }
            }
            return {
                x: e,
                y: t
            }
        }
        _calculateFilterArea(e, t) {
            if (e.renderables ? p3(e.renderables, t) : e.filterEffect.filterArea ? (t.clear(),
            t.addRect(e.filterEffect.filterArea),
            t.applyMatrix(e.container.worldTransform)) : e.container.getFastGlobalBounds(!0, t),
            e.container) {
                let r = (e.container.renderGroup || e.container.parentRenderGroup).cacheToLocalTransform;
                r && t.applyMatrix(r)
            }
        }
        _applyFiltersToTexture(e, t) {
            let r = e.inputTexture
              , s = e.bounds
              , n = e.filters;
            if (this._globalFilterBindGroup.setResource(r.source.style, 2),
            this._globalFilterBindGroup.setResource(e.backTexture.source, 3),
            n.length === 1)
                n[0].apply(this, r, e.outputRenderSurface, t);
            else {
                let a = e.inputTexture
                  , o = Ke.getOptimalTexture(s.width, s.height, a.source._resolution, !1)
                  , l = o
                  , u = 0;
                for (u = 0; u < n.length - 1; ++u) {
                    n[u].apply(this, a, l, !0);
                    let d = a;
                    a = l,
                    l = d
                }
                n[u].apply(this, a, e.outputRenderSurface, t),
                Ke.returnTexture(o)
            }
        }
        _calculateFilterBounds(e, t, r, s, n) {
            var a, o;
            let l = this.renderer
              , u = e.bounds
              , d = e.filters
              , f = 1 / 0
              , b = 0
              , m = !0
              , x = !1
              , v = !1
              , S = !0;
            for (let w = 0; w < d.length; w++) {
                let E = d[w];
                if (f = Math.min(f, E.resolution === "inherit" ? s : E.resolution),
                b += E.padding,
                E.antialias === "off" ? m = !1 : E.antialias === "inherit" && m && (m = r),
                E.clipToViewport || (S = !1),
                !(E.compatibleRenderers & l.type)) {
                    v = !1;
                    break
                }
                if (E.blendRequired && !((o = (a = l.backBuffer) == null ? void 0 : a.useBackBuffer) == null || o)) {
                    v = !1;
                    break
                }
                v = E.enabled || v,
                x || (x = E.blendRequired)
            }
            if (!v) {
                e.skip = !0;
                return
            }
            if (S && u.fitBounds(0, t.width / s, 0, t.height / s),
            u.scale(f).ceil().scale(1 / f).pad((b | 0) * n),
            !u.isPositive) {
                e.skip = !0;
                return
            }
            e.antialias = m,
            e.resolution = f,
            e.blendRequired = x
        }
        _popFilterData() {
            return this._filterStackIndex--,
            this._filterStack[this._filterStackIndex]
        }
        _getPreviousFilterData() {
            let e, t = this._filterStackIndex - 1;
            for (; t > 0 && (t--,
            e = this._filterStack[t],
            !!e.skip); )
                ;
            return e
        }
        _pushFilterData() {
            let e = this._filterStack[this._filterStackIndex];
            return e || (e = this._filterStack[this._filterStackIndex] = new m3),
            this._filterStackIndex++,
            e
        }
    }
    ;
    ea.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem],
        name: "filter"
    },
    be.add(ea),
    be.add(Jn);
    var g3 = {
        __proto__: null
    }
      , Ol = [];
    be.handleByNamedList(O.Environment, Ol);
    async function _3(i) {
        if (!i)
            for (let e = 0; e < Ol.length; e++) {
                let t = Ol[e];
                if (t.value.test()) {
                    await t.value.load();
                    return
                }
            }
    }
    var jr;
    function am() {
        if (typeof jr == "boolean")
            return jr;
        try {
            jr = new Function("param1","param2","param3","return param1[param2] === param3;")({
                a: "b"
            }, "a", "b") === !0
        } catch {
            jr = !1
        }
        return jr
    }
    var Rt = (i => (i[i.NONE = 0] = "NONE",
    i[i.COLOR = 16384] = "COLOR",
    i[i.STENCIL = 1024] = "STENCIL",
    i[i.DEPTH = 256] = "DEPTH",
    i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH",
    i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL",
    i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL",
    i[i.ALL = 17664] = "ALL",
    i))(Rt || {})
      , ta = class {
        constructor(e) {
            this.items = [],
            this._name = e
        }
        emit(e, t, r, s, n, a, o, l) {
            let {name: u, items: d} = this;
            for (let f = 0, b = d.length; f < b; f++)
                d[f][u](e, t, r, s, n, a, o, l);
            return this
        }
        add(e) {
            return e[this._name] && (this.remove(e),
            this.items.push(e)),
            this
        }
        remove(e) {
            let t = this.items.indexOf(e);
            return t !== -1 && this.items.splice(t, 1),
            this
        }
        contains(e) {
            return this.items.indexOf(e) !== -1
        }
        removeAll() {
            return this.items.length = 0,
            this
        }
        destroy() {
            this.removeAll(),
            this.items = null,
            this._name = null
        }
        get empty() {
            return this.items.length === 0
        }
        get name() {
            return this._name
        }
    }
      , x3 = Object.defineProperty
      , Uf = Object.getOwnPropertySymbols
      , y3 = Object.prototype.hasOwnProperty
      , v3 = Object.prototype.propertyIsEnumerable
      , Lf = (i, e, t) => e in i ? x3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Zs = (i, e) => {
        for (var t in e || (e = {}))
            y3.call(e, t) && Lf(i, t, e[t]);
        if (Uf)
            for (var t of Uf(e))
                v3.call(e, t) && Lf(i, t, e[t]);
        return i
    }
      , T3 = ["init", "destroy", "contextChange", "resolutionChange", "resetState", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"]
      , om = class cm extends Ot {
        constructor(e) {
            var t;
            super(),
            this.uid = Le("renderer"),
            this.runners = Object.create(null),
            this.renderPipes = Object.create(null),
            this._initOptions = {},
            this._systemsHash = Object.create(null),
            this.type = e.type,
            this.name = e.name,
            this.config = e;
            let r = [...T3, ...(t = this.config.runners) != null ? t : []];
            this._addRunners(...r),
            this._unsafeEvalCheck()
        }
        async init(e={}) {
            let t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
            await _3(t),
            this._addSystems(this.config.systems),
            this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
            for (let r in this._systemsHash) {
                let s = this._systemsHash[r].constructor.defaultOptions;
                e = Zs(Zs({}, s), e)
            }
            e = Zs(Zs({}, cm.defaultOptions), e),
            this._roundPixels = e.roundPixels ? 1 : 0;
            for (let r = 0; r < this.runners.init.items.length; r++)
                await this.runners.init.items[r].init(e);
            this._initOptions = e
        }
        render(e, t) {
            var r, s;
            let n = e;
            if (n instanceof Te && (n = {
                container: n
            },
            t && (n.target = t.renderTexture)),
            n.target || (n.target = this.view.renderTarget),
            n.target === this.view.renderTarget && (this._lastObjectRendered = n.container,
            (r = n.clearColor) != null || (n.clearColor = this.background.colorRgba),
            (s = n.clear) != null || (n.clear = this.background.clearBeforeRender)),
            n.clearColor) {
                let a = Array.isArray(n.clearColor) && n.clearColor.length === 4;
                n.clearColor = a ? n.clearColor : Be.shared.setValue(n.clearColor).toArray()
            }
            n.transform || (n.container.updateLocalTransform(),
            n.transform = n.container.localTransform),
            n.container.visible && (n.container.enableRenderGroup(),
            this.runners.prerender.emit(n),
            this.runners.renderStart.emit(n),
            this.runners.render.emit(n),
            this.runners.renderEnd.emit(n),
            this.runners.postrender.emit(n))
        }
        resize(e, t, r) {
            let s = this.view.resolution;
            this.view.resize(e, t, r),
            this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution),
            r !== void 0 && r !== s && this.runners.resolutionChange.emit(r)
        }
        clear(e={}) {
            var t;
            let r = this;
            e.target || (e.target = r.renderTarget.renderTarget),
            e.clearColor || (e.clearColor = this.background.colorRgba),
            (t = e.clear) != null || (e.clear = Rt.ALL);
            let {clear: s, clearColor: n, target: a} = e;
            Be.shared.setValue(n ?? this.background.colorRgba),
            r.renderTarget.clear(a, s, Be.shared.toArray())
        }
        get resolution() {
            return this.view.resolution
        }
        set resolution(e) {
            this.view.resolution = e,
            this.runners.resolutionChange.emit(e)
        }
        get width() {
            return this.view.texture.frame.width
        }
        get height() {
            return this.view.texture.frame.height
        }
        get canvas() {
            return this.view.canvas
        }
        get lastObjectRendered() {
            return this._lastObjectRendered
        }
        get renderingToScreen() {
            return this.renderTarget.renderingToScreen
        }
        get screen() {
            return this.view.screen
        }
        _addRunners(...e) {
            e.forEach(t => {
                this.runners[t] = new ta(t)
            }
            )
        }
        _addSystems(e) {
            let t;
            for (t in e) {
                let r = e[t];
                this._addSystem(r.value, r.name)
            }
        }
        _addSystem(e, t) {
            let r = new e(this);
            if (this[t])
                throw new Error(`Whoops! The name "${t}" is already in use`);
            this[t] = r,
            this._systemsHash[t] = r;
            for (let s in this.runners)
                this.runners[s].add(r);
            return this
        }
        _addPipes(e, t) {
            let r = t.reduce( (s, n) => (s[n.name] = n.value,
            s), {});
            e.forEach(s => {
                let n = s.value
                  , a = s.name
                  , o = r[a];
                this.renderPipes[a] = new n(this,o ? new o : null),
                this.runners.destroy.add(this.renderPipes[a])
            }
            )
        }
        destroy(e=!1) {
            this.runners.destroy.items.reverse(),
            this.runners.destroy.emit(e),
            Object.values(this.runners).forEach(t => {
                t.destroy()
            }
            ),
            (e === !0 || typeof e == "object" && e.releaseGlobalResources) && Pr.release(),
            this._systemsHash = null,
            this.renderPipes = null
        }
        generateTexture(e) {
            return this.textureGenerator.generateTexture(e)
        }
        get roundPixels() {
            return !!this._roundPixels
        }
        _unsafeEvalCheck() {
            if (!am())
                throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")
        }
        resetState() {
            this.runners.resetState.emit()
        }
    }
    ;
    om.defaultOptions = {
        resolution: 1,
        failIfMajorPerformanceCaveat: !1,
        roundPixels: !1
    };
    var bo = om, hc;
    function mo(i) {
        return hc !== void 0 || (hc = ( () => {
            var e;
            let t = {
                stencil: !0,
                failIfMajorPerformanceCaveat: i ?? bo.defaultOptions.failIfMajorPerformanceCaveat
            };
            try {
                if (!ye.get().getWebGLRenderingContext())
                    return !1;
                let r = ye.get().createCanvas().getContext("webgl", t)
                  , s = !!((e = r?.getContextAttributes()) != null && e.stencil);
                if (r) {
                    let n = r.getExtension("WEBGL_lose_context");
                    n && n.loseContext()
                }
                return r = null,
                s
            } catch {
                return !1
            }
        }
        )()),
        hc
    }
    var uc;
    async function go(i={}) {
        return uc !== void 0 || (uc = await (async () => {
            let e = ye.get().getNavigator().gpu;
            if (!e)
                return !1;
            try {
                return await (await e.requestAdapter(i)).requestDevice(),
                !0
            } catch {
                return !1
            }
        }
        )()),
        uc
    }
    var S3 = Object.defineProperty
      , Nf = Object.getOwnPropertySymbols
      , w3 = Object.prototype.hasOwnProperty
      , A3 = Object.prototype.propertyIsEnumerable
      , Xf = (i, e, t) => e in i ? S3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Hr = (i, e) => {
        for (var t in e || (e = {}))
            w3.call(e, t) && Xf(i, t, e[t]);
        if (Nf)
            for (var t of Nf(e))
                A3.call(e, t) && Xf(i, t, e[t]);
        return i
    }
      , jf = ["webgl", "webgpu", "canvas"];
    async function _o(i) {
        var e;
        let t = [];
        i.preference ? (t.push(i.preference),
        jf.forEach(a => {
            a !== i.preference && t.push(a)
        }
        )) : t = jf.slice();
        let r, s = {};
        for (let a = 0; a < t.length; a++) {
            let o = t[a];
            if (o === "webgpu" && await go()) {
                let {WebGPURenderer: l} = await Promise.resolve().then(function() {
                    return nS
                });
                r = l,
                s = Hr(Hr({}, i), i.webgpu);
                break
            } else if (o === "webgl" && mo((e = i.failIfMajorPerformanceCaveat) != null ? e : bo.defaultOptions.failIfMajorPerformanceCaveat)) {
                let {WebGLRenderer: l} = await Promise.resolve().then(function() {
                    return F6
                });
                r = l,
                s = Hr(Hr({}, i), i.webgl);
                break
            } else if (o === "canvas")
                throw s = Hr({}, i),
                new Error("CanvasRenderer is not yet implemented")
        }
        if (delete s.webgpu,
        delete s.webgl,
        !r)
            throw new Error("No available renderer for the current environment");
        let n = new r;
        return await n.init(s),
        n
    }
    var ia = "8.13.1"
      , ra = class {
        static init() {
            var e;
            (e = globalThis.__PIXI_APP_INIT__) == null || e.call(globalThis, this, ia)
        }
        static destroy() {}
    }
    ;
    ra.extension = O.Application;
    var sa = class {
        constructor(e) {
            this._renderer = e
        }
        init() {
            var e;
            (e = globalThis.__PIXI_RENDERER_INIT__) == null || e.call(globalThis, this._renderer, ia)
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    sa.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem],
        name: "initHook",
        priority: -10
    };
    var E3 = Object.defineProperty
      , Hf = Object.getOwnPropertySymbols
      , P3 = Object.prototype.hasOwnProperty
      , R3 = Object.prototype.propertyIsEnumerable
      , zf = (i, e, t) => e in i ? E3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , M3 = (i, e) => {
        for (var t in e || (e = {}))
            P3.call(e, t) && zf(i, t, e[t]);
        if (Hf)
            for (var t of Hf(e))
                R3.call(e, t) && zf(i, t, e[t]);
        return i
    }
      , lm = class Il {
        constructor(...e) {
            this.stage = new Te
        }
        async init(e) {
            e = M3({}, e),
            this.renderer = await _o(e),
            Il._plugins.forEach(t => {
                t.init.call(this, e)
            }
            )
        }
        render() {
            this.renderer.render({
                container: this.stage
            })
        }
        get canvas() {
            return this.renderer.canvas
        }
        get view() {
            return this.renderer.canvas
        }
        get screen() {
            return this.renderer.screen
        }
        destroy(e=!1, t=!1) {
            let r = Il._plugins.slice(0);
            r.reverse(),
            r.forEach(s => {
                s.destroy.call(this)
            }
            ),
            this.stage.destroy(t),
            this.stage = null,
            this.renderer.destroy(e),
            this.renderer = null
        }
    }
    ;
    lm._plugins = [];
    var C3 = lm;
    be.handleByList(O.Application, C3._plugins),
    be.add(ra);
    var na = class extends Wn {
        constructor(e, t) {
            var r;
            super();
            let {textures: s, data: n} = e;
            Object.keys(n.pages).forEach(a => {
                let o = n.pages[parseInt(a, 10)]
                  , l = s[o.id];
                this.pages.push({
                    texture: l
                })
            }
            ),
            Object.keys(n.chars).forEach(a => {
                var o;
                let l = n.chars[a]
                  , {frame: u, source: d, rotate: f} = s[l.page]
                  , b = De.transformRectCoords(l, u, f, new Oe)
                  , m = new Z({
                    frame: b,
                    orig: new Oe(0,0,l.width,l.height),
                    source: d,
                    rotate: f
                });
                this.chars[a] = {
                    id: a.codePointAt(0),
                    xOffset: l.xOffset,
                    yOffset: l.yOffset,
                    xAdvance: l.xAdvance,
                    kerning: (o = l.kerning) != null ? o : {},
                    texture: m
                }
            }
            ),
            this.baseRenderedFontSize = n.fontSize,
            this.baseMeasurementFontSize = n.fontSize,
            this.fontMetrics = {
                ascent: 0,
                descent: 0,
                fontSize: n.fontSize
            },
            this.baseLineOffset = n.baseLineOffset,
            this.lineHeight = n.lineHeight,
            this.fontFamily = n.fontFamily,
            this.distanceField = (r = n.distanceField) != null ? r : {
                type: "none",
                range: 0
            },
            this.url = t
        }
        destroy() {
            super.destroy();
            for (let e = 0; e < this.pages.length; e++) {
                let {texture: t} = this.pages[e];
                t.destroy(!0)
            }
            this.pages = null
        }
        static install(e) {
            Ts.install(e)
        }
        static uninstall(e) {
            Ts.uninstall(e)
        }
    }
      , dc = {
        test(i) {
            return typeof i == "string" && i.startsWith("info face=")
        },
        parse(i) {
            var e, t, r;
            let s = i.match(/^[a-z]+\s+.+$/gm)
              , n = {
                info: [],
                common: [],
                page: [],
                char: [],
                chars: [],
                kerning: [],
                kernings: [],
                distanceField: []
            };
            for (let x in s) {
                let v = s[x].match(/^[a-z]+/gm)[0]
                  , S = s[x].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm)
                  , w = {};
                for (let E in S) {
                    let P = S[E].split("=")
                      , C = P[0]
                      , L = P[1].replace(/"/gm, "")
                      , F = parseFloat(L)
                      , X = isNaN(F) ? L : F;
                    w[C] = X
                }
                n[v].push(w)
            }
            let a = {
                chars: {},
                pages: [],
                lineHeight: 0,
                fontSize: 0,
                fontFamily: "",
                distanceField: null,
                baseLineOffset: 0
            }
              , [o] = n.info
              , [l] = n.common
              , [u] = (e = n.distanceField) != null ? e : [];
            u && (a.distanceField = {
                range: parseInt(u.distanceRange, 10),
                type: u.fieldType
            }),
            a.fontSize = parseInt(o.size, 10),
            a.fontFamily = o.face,
            a.lineHeight = parseInt(l.lineHeight, 10);
            let d = n.page;
            for (let x = 0; x < d.length; x++)
                a.pages.push({
                    id: parseInt(d[x].id, 10) || 0,
                    file: d[x].file
                });
            let f = {};
            a.baseLineOffset = a.lineHeight - parseInt(l.base, 10);
            let b = n.char;
            for (let x = 0; x < b.length; x++) {
                let v = b[x]
                  , S = parseInt(v.id, 10)
                  , w = (r = (t = v.letter) != null ? t : v.char) != null ? r : String.fromCharCode(S);
                w === "space" && (w = " "),
                f[S] = w,
                a.chars[w] = {
                    id: S,
                    page: parseInt(v.page, 10) || 0,
                    x: parseInt(v.x, 10),
                    y: parseInt(v.y, 10),
                    width: parseInt(v.width, 10),
                    height: parseInt(v.height, 10),
                    xOffset: parseInt(v.xoffset, 10),
                    yOffset: parseInt(v.yoffset, 10),
                    xAdvance: parseInt(v.xadvance, 10),
                    kerning: {}
                }
            }
            let m = n.kerning || [];
            for (let x = 0; x < m.length; x++) {
                let v = parseInt(m[x].first, 10)
                  , S = parseInt(m[x].second, 10)
                  , w = parseInt(m[x].amount, 10);
                a.chars[f[S]].kerning[f[v]] = w
            }
            return a
        }
    }
      , Vf = {
        test(i) {
            let e = i;
            return typeof e != "string" && "getElementsByTagName"in e && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null
        },
        parse(i) {
            var e, t;
            let r = {
                chars: {},
                pages: [],
                lineHeight: 0,
                fontSize: 0,
                fontFamily: "",
                distanceField: null,
                baseLineOffset: 0
            }
              , s = i.getElementsByTagName("info")[0]
              , n = i.getElementsByTagName("common")[0]
              , a = i.getElementsByTagName("distanceField")[0];
            a && (r.distanceField = {
                type: a.getAttribute("fieldType"),
                range: parseInt(a.getAttribute("distanceRange"), 10)
            });
            let o = i.getElementsByTagName("page")
              , l = i.getElementsByTagName("char")
              , u = i.getElementsByTagName("kerning");
            r.fontSize = parseInt(s.getAttribute("size"), 10),
            r.fontFamily = s.getAttribute("face"),
            r.lineHeight = parseInt(n.getAttribute("lineHeight"), 10);
            for (let f = 0; f < o.length; f++)
                r.pages.push({
                    id: parseInt(o[f].getAttribute("id"), 10) || 0,
                    file: o[f].getAttribute("file")
                });
            let d = {};
            r.baseLineOffset = r.lineHeight - parseInt(n.getAttribute("base"), 10);
            for (let f = 0; f < l.length; f++) {
                let b = l[f]
                  , m = parseInt(b.getAttribute("id"), 10)
                  , x = (t = (e = b.getAttribute("letter")) != null ? e : b.getAttribute("char")) != null ? t : String.fromCharCode(m);
                x === "space" && (x = " "),
                d[m] = x,
                r.chars[x] = {
                    id: m,
                    page: parseInt(b.getAttribute("page"), 10) || 0,
                    x: parseInt(b.getAttribute("x"), 10),
                    y: parseInt(b.getAttribute("y"), 10),
                    width: parseInt(b.getAttribute("width"), 10),
                    height: parseInt(b.getAttribute("height"), 10),
                    xOffset: parseInt(b.getAttribute("xoffset"), 10),
                    yOffset: parseInt(b.getAttribute("yoffset"), 10),
                    xAdvance: parseInt(b.getAttribute("xadvance"), 10),
                    kerning: {}
                }
            }
            for (let f = 0; f < u.length; f++) {
                let b = parseInt(u[f].getAttribute("first"), 10)
                  , m = parseInt(u[f].getAttribute("second"), 10)
                  , x = parseInt(u[f].getAttribute("amount"), 10);
                r.chars[d[m]].kerning[d[b]] = x
            }
            return r
        }
    }
      , Wf = {
        test(i) {
            return typeof i == "string" && i.includes("<font>") ? Vf.test(ye.get().parseXML(i)) : !1
        },
        parse(i) {
            return Vf.parse(ye.get().parseXML(i))
        }
    }
      , O3 = [".xml", ".fnt"]
      , I3 = {
        extension: {
            type: O.CacheParser,
            name: "cacheBitmapFont"
        },
        test: i => i instanceof na,
        getCacheableAssets(i, e) {
            let t = {};
            return i.forEach(r => {
                t[r] = e,
                t[`${r}-bitmap`] = e
            }
            ),
            t[`${e.fontFamily}-bitmap`] = e,
            t
        }
    }
      , G3 = {
        extension: {
            type: O.LoadParser,
            priority: Xt.Normal
        },
        name: "loadBitmapFont",
        id: "bitmap-font",
        test(i) {
            return O3.includes(Mt.extname(i).toLowerCase())
        },
        async testParse(i) {
            return dc.test(i) || Wf.test(i)
        },
        async parse(i, e, t) {
            let r = dc.test(i) ? dc.parse(i) : Wf.parse(i)
              , {src: s} = e
              , {pages: n} = r
              , a = []
              , o = r.distanceField ? {
                scaleMode: "linear",
                alphaMode: "premultiply-alpha-on-upload",
                autoGenerateMipmaps: !1,
                resolution: 1
            } : {};
            for (let d = 0; d < n.length; ++d) {
                let f = n[d].file
                  , b = Mt.join(Mt.dirname(s), f);
                b = Hc(b, s),
                a.push({
                    src: b,
                    data: o
                })
            }
            let l = await t.load(a)
              , u = a.map(d => l[d.src]);
            return new na({
                data: r,
                textures: u
            },s)
        },
        async load(i, e) {
            return await (await ye.get().fetch(i)).text()
        },
        async unload(i, e, t) {
            await Promise.all(i.pages.map(r => t.unload(r.texture.source._sourceOrigin))),
            i.destroy()
        }
    }
      , Gl = class {
        constructor(e, t=!1) {
            this._loader = e,
            this._assetList = [],
            this._isLoading = !1,
            this._maxConcurrent = 1,
            this.verbose = t
        }
        add(e) {
            e.forEach(t => {
                this._assetList.push(t)
            }
            ),
            this.verbose,
            this._isActive && !this._isLoading && this._next()
        }
        async _next() {
            if (this._assetList.length && this._isActive) {
                this._isLoading = !0;
                let e = []
                  , t = Math.min(this._assetList.length, this._maxConcurrent);
                for (let r = 0; r < t; r++)
                    e.push(this._assetList.pop());
                await this._loader.load(e),
                this._isLoading = !1,
                this._next()
            }
        }
        get active() {
            return this._isActive
        }
        set active(e) {
            this._isActive !== e && (this._isActive = e,
            e && !this._isLoading && this._next())
        }
    }
      , B3 = {
        extension: {
            type: O.CacheParser,
            name: "cacheTextureArray"
        },
        test: i => Array.isArray(i) && i.every(e => e instanceof Z),
        getCacheableAssets: (i, e) => {
            let t = {};
            return i.forEach(r => {
                e.forEach( (s, n) => {
                    t[r + (n === 0 ? "" : n + 1)] = s
                }
                )
            }
            ),
            t
        }
    };
    async function hm(i) {
        if ("Image"in globalThis)
            return new Promise(e => {
                let t = new Image;
                t.onload = () => {
                    e(!0)
                }
                ,
                t.onerror = () => {
                    e(!1)
                }
                ,
                t.src = i
            }
            );
        if ("createImageBitmap"in globalThis && "fetch"in globalThis) {
            try {
                let e = await (await fetch(i)).blob();
                await createImageBitmap(e)
            } catch {
                return !1
            }
            return !0
        }
        return !1
    }
    var F3 = {
        extension: {
            type: O.DetectionParser,
            priority: 1
        },
        test: async () => hm("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
        add: async i => [...i, "avif"],
        remove: async i => i.filter(e => e !== "avif")
    }
      , Yf = ["png", "jpg", "jpeg"]
      , D3 = {
        extension: {
            type: O.DetectionParser,
            priority: -1
        },
        test: () => Promise.resolve(!0),
        add: async i => [...i, ...Yf],
        remove: async i => i.filter(e => !Yf.includes(e))
    }
      , k3 = "WorkerGlobalScope"in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
    function xo(i) {
        return k3 ? !1 : document.createElement("video").canPlayType(i) !== ""
    }
    var U3 = {
        extension: {
            type: O.DetectionParser,
            priority: 0
        },
        test: async () => xo("video/mp4"),
        add: async i => [...i, "mp4", "m4v"],
        remove: async i => i.filter(e => e !== "mp4" && e !== "m4v")
    }
      , L3 = {
        extension: {
            type: O.DetectionParser,
            priority: 0
        },
        test: async () => xo("video/ogg"),
        add: async i => [...i, "ogv"],
        remove: async i => i.filter(e => e !== "ogv")
    }
      , N3 = {
        extension: {
            type: O.DetectionParser,
            priority: 0
        },
        test: async () => xo("video/webm"),
        add: async i => [...i, "webm"],
        remove: async i => i.filter(e => e !== "webm")
    }
      , X3 = {
        extension: {
            type: O.DetectionParser,
            priority: 0
        },
        test: async () => hm("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
        add: async i => [...i, "webp"],
        remove: async i => i.filter(e => e !== "webp")
    }
      , Bl = class {
        constructor() {
            this._parsers = [],
            this._parsersValidated = !1,
            this.parsers = new Proxy(this._parsers,{
                set: (e, t, r) => (this._parsersValidated = !1,
                e[t] = r,
                !0)
            }),
            this.promiseCache = {}
        }
        reset() {
            this._parsersValidated = !1,
            this.promiseCache = {}
        }
        _getLoadPromiseAndParser(e, t) {
            let r = {
                promise: null,
                parser: null
            };
            return r.promise = (async () => {
                var s, n;
                let a = null
                  , o = null;
                if ((t.parser || t.loadParser) && (o = this._parserHash[t.parser || t.loadParser]),
                !o) {
                    for (let l = 0; l < this.parsers.length; l++) {
                        let u = this.parsers[l];
                        if (u.load && (s = u.test) != null && s.call(u, e, t, this)) {
                            o = u;
                            break
                        }
                    }
                    if (!o)
                        return null
                }
                a = await o.load(e, t, this),
                r.parser = o;
                for (let l = 0; l < this.parsers.length; l++) {
                    let u = this.parsers[l];
                    u.parse && u.parse && await ((n = u.testParse) == null ? void 0 : n.call(u, a, t, this)) && (a = await u.parse(a, t, this) || a,
                    r.parser = u)
                }
                return a
            }
            )(),
            r
        }
        async load(e, t) {
            this._parsersValidated || this._validateParsers();
            let r = 0
              , s = {}
              , n = Sn(e)
              , a = Vt(e, u => ({
                alias: [u],
                src: u,
                data: {}
            }))
              , o = a.length
              , l = a.map(async u => {
                let d = Mt.toAbsolute(u.src);
                if (!s[u.src])
                    try {
                        this.promiseCache[d] || (this.promiseCache[d] = this._getLoadPromiseAndParser(d, u)),
                        s[u.src] = await this.promiseCache[d].promise,
                        t && t(++r / o)
                    } catch (f) {
                        throw delete this.promiseCache[d],
                        delete s[u.src],
                        new Error(`[Loader.load] Failed to load ${d}.
${f}`)
                    }
            }
            );
            return await Promise.all(l),
            n ? s[a[0].src] : s
        }
        async unload(e) {
            let t = Vt(e, r => ({
                alias: [r],
                src: r
            })).map(async r => {
                var s, n;
                let a = Mt.toAbsolute(r.src)
                  , o = this.promiseCache[a];
                if (o) {
                    let l = await o.promise;
                    delete this.promiseCache[a],
                    await ((n = (s = o.parser) == null ? void 0 : s.unload) == null ? void 0 : n.call(s, l, r, this))
                }
            }
            );
            await Promise.all(t)
        }
        _validateParsers() {
            this._parsersValidated = !0,
            this._parserHash = this._parsers.filter(e => e.name || e.id).reduce( (e, t) => (!t.name && !t.id || e[t.name] || e[t.id],
            e[t.name] = t,
            t.id && (e[t.id] = t),
            e), {})
        }
    }
    ;
    function Rr(i, e) {
        if (Array.isArray(e)) {
            for (let t of e)
                if (i.startsWith(`data:${t}`))
                    return !0;
            return !1
        }
        return i.startsWith(`data:${e}`)
    }
    function Kt(i, e) {
        let t = i.split("?")[0]
          , r = Mt.extname(t).toLowerCase();
        return Array.isArray(e) ? e.includes(r) : r === e
    }
    var j3 = ".json"
      , H3 = "application/json"
      , z3 = {
        extension: {
            type: O.LoadParser,
            priority: Xt.Low
        },
        name: "loadJson",
        id: "json",
        test(i) {
            return Rr(i, H3) || Kt(i, j3)
        },
        async load(i) {
            return await (await ye.get().fetch(i)).json()
        }
    }
      , V3 = ".txt"
      , W3 = "text/plain"
      , Y3 = {
        name: "loadTxt",
        id: "text",
        extension: {
            type: O.LoadParser,
            priority: Xt.Low,
            name: "loadTxt"
        },
        test(i) {
            return Rr(i, W3) || Kt(i, V3)
        },
        async load(i) {
            return await (await ye.get().fetch(i)).text()
        }
    }
      , $3 = Object.defineProperty
      , K3 = Object.defineProperties
      , q3 = Object.getOwnPropertyDescriptors
      , $f = Object.getOwnPropertySymbols
      , Z3 = Object.prototype.hasOwnProperty
      , Q3 = Object.prototype.propertyIsEnumerable
      , Kf = (i, e, t) => e in i ? $3(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , J3 = (i, e) => {
        for (var t in e || (e = {}))
            Z3.call(e, t) && Kf(i, t, e[t]);
        if ($f)
            for (var t of $f(e))
                Q3.call(e, t) && Kf(i, t, e[t]);
        return i
    }
      , e4 = (i, e) => K3(i, q3(e))
      , t4 = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
      , i4 = [".ttf", ".otf", ".woff", ".woff2"]
      , r4 = ["font/ttf", "font/otf", "font/woff", "font/woff2"]
      , s4 = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    function n4(i) {
        let e = Mt.extname(i)
          , t = Mt.basename(i, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(n => n.charAt(0).toUpperCase() + n.slice(1))
          , r = t.length > 0;
        for (let n of t)
            if (!n.match(s4)) {
                r = !1;
                break
            }
        let s = t.join(" ");
        return r || (s = `"${s.replace(/[\\"]/g, "\\$&")}"`),
        s
    }
    var a4 = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
    function o4(i) {
        return a4.test(i) ? i : encodeURI(i)
    }
    var c4 = {
        extension: {
            type: O.LoadParser,
            priority: Xt.Low
        },
        name: "loadWebFont",
        id: "web-font",
        test(i) {
            return Rr(i, r4) || Kt(i, i4)
        },
        async load(i, e) {
            var t, r, s, n, a, o;
            let l = ye.get().getFontFaceSet();
            if (l) {
                let u = []
                  , d = (r = (t = e.data) == null ? void 0 : t.family) != null ? r : n4(i)
                  , f = (a = (n = (s = e.data) == null ? void 0 : s.weights) == null ? void 0 : n.filter(m => t4.includes(m))) != null ? a : ["normal"]
                  , b = (o = e.data) != null ? o : {};
                for (let m = 0; m < f.length; m++) {
                    let x = f[m]
                      , v = new FontFace(d,`url(${o4(i)})`,e4(J3({}, b), {
                        weight: x
                    }));
                    await v.load(),
                    l.add(v),
                    u.push(v)
                }
                return Ge.has(`${d}-and-url`) ? Ge.get(`${d}-and-url`).entries.push({
                    url: i,
                    faces: u
                }) : Ge.set(`${d}-and-url`, {
                    entries: [{
                        url: i,
                        faces: u
                    }]
                }),
                u.length === 1 ? u[0] : u
            }
            return null
        },
        unload(i) {
            let e = Array.isArray(i) ? i : [i]
              , t = e[0].family
              , r = Ge.get(`${t}-and-url`)
              , s = r.entries.find(n => n.faces.some(a => e.indexOf(a) !== -1));
            s.faces = s.faces.filter(n => e.indexOf(n) === -1),
            s.faces.length === 0 && (r.entries = r.entries.filter(n => n !== s)),
            e.forEach(n => {
                ye.get().getFontFaceSet().delete(n)
            }
            ),
            r.entries.length === 0 && Ge.remove(`${t}-and-url`)
        }
    };
    function Uh(i, e=1) {
        var t;
        let r = (t = bi.RETINA_PREFIX) == null ? void 0 : t.exec(i);
        return r ? parseFloat(r[1]) : e
    }
    function Qi(i, e, t) {
        i.label = t,
        i._sourceOrigin = t;
        let r = new Z({
            source: i,
            label: t
        })
          , s = () => {
            delete e.promiseCache[t],
            Ge.has(t) && Ge.remove(t)
        }
        ;
        return r.source.once("destroy", () => {
            e.promiseCache[t] && s()
        }
        ),
        r.once("destroy", () => {
            i.destroyed || s()
        }
        ),
        r
    }
    var l4 = Object.defineProperty
      , aa = Object.getOwnPropertySymbols
      , um = Object.prototype.hasOwnProperty
      , dm = Object.prototype.propertyIsEnumerable
      , qf = (i, e, t) => e in i ? l4(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , h4 = (i, e) => {
        for (var t in e || (e = {}))
            um.call(e, t) && qf(i, t, e[t]);
        if (aa)
            for (var t of aa(e))
                dm.call(e, t) && qf(i, t, e[t]);
        return i
    }
      , u4 = (i, e) => {
        var t = {};
        for (var r in i)
            um.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && aa)
            for (var r of aa(i))
                e.indexOf(r) < 0 && dm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , d4 = ".svg"
      , f4 = "image/svg+xml"
      , p4 = {
        extension: {
            type: O.LoadParser,
            priority: Xt.Low,
            name: "loadSVG"
        },
        name: "loadSVG",
        id: "svg",
        config: {
            crossOrigin: "anonymous",
            parseAsGraphicsContext: !1
        },
        test(i) {
            return Rr(i, f4) || Kt(i, d4)
        },
        async load(i, e, t) {
            var r, s;
            return ((s = (r = e.data) == null ? void 0 : r.parseAsGraphicsContext) != null ? s : this.config.parseAsGraphicsContext) ? m4(i) : b4(i, e, t, this.config.crossOrigin)
        },
        unload(i) {
            i.destroy(!0)
        }
    };
    async function b4(i, e, t, r) {
        var s, n, a, o, l, u;
        let d = await ye.get().fetch(i)
          , f = ye.get().createImage();
        f.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await d.text())}`,
        f.crossOrigin = r,
        await f.decode();
        let b = (n = (s = e.data) == null ? void 0 : s.width) != null ? n : f.width
          , m = (o = (a = e.data) == null ? void 0 : a.height) != null ? o : f.height
          , x = ((l = e.data) == null ? void 0 : l.resolution) || Uh(i)
          , v = Math.ceil(b * x)
          , S = Math.ceil(m * x)
          , w = ye.get().createCanvas(v, S)
          , E = w.getContext("2d");
        E.imageSmoothingEnabled = !0,
        E.imageSmoothingQuality = "high",
        E.drawImage(f, 0, 0, b * x, m * x);
        let P = (u = e.data) != null ? u : {}
          , {parseAsGraphicsContext: C} = P
          , L = u4(P, ["parseAsGraphicsContext"])
          , F = new mi(h4({
            resource: w,
            alphaMode: "premultiply-alpha-on-upload",
            resolution: x
        }, L));
        return Qi(F, t, i)
    }
    async function m4(i) {
        let e = await (await ye.get().fetch(i)).text()
          , t = new yt;
        return t.svg(e),
        t
    }
    var g4 = `(function(){"use strict";const e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";async function a(){try{if(typeof createImageBitmap!="function")return!1;const A=await(await fetch(e)).blob(),t=await createImageBitmap(A);return t.width===1&&t.height===1}catch(A){return!1}}a().then(A=>{self.postMessage(A)})})();
`
      , br = null
      , Fl = class {
        constructor() {
            br || (br = URL.createObjectURL(new Blob([g4],{
                type: "application/javascript"
            }))),
            this.worker = new Worker(br)
        }
    }
    ;
    Fl.revokeObjectURL = function() {
        br && (URL.revokeObjectURL(br),
        br = null)
    }
    ;
    var _4 = '(function(){"use strict";async function s(a,t){const e=await fetch(a);if(!e.ok)throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${a}: ${e.status} ${e.statusText}`);const i=await e.blob();return t==="premultiplied-alpha"?createImageBitmap(i,{premultiplyAlpha:"none"}):createImageBitmap(i)}self.onmessage=async a=>{try{const t=await s(a.data.data[0],a.data.data[1]);self.postMessage({data:t,uuid:a.data.uuid,id:a.data.id},[t])}catch(t){self.postMessage({error:t,uuid:a.data.uuid,id:a.data.id})}}})();\n'
      , mr = null
      , fm = class {
        constructor() {
            mr || (mr = URL.createObjectURL(new Blob([_4],{
                type: "application/javascript"
            }))),
            this.worker = new Worker(mr)
        }
    }
    ;
    fm.revokeObjectURL = function() {
        mr && (URL.revokeObjectURL(mr),
        mr = null)
    }
    ;
    var Zf = 0, fc, x4 = class {
        constructor() {
            this._initialized = !1,
            this._createdWorkers = 0,
            this._workerPool = [],
            this._queue = [],
            this._resolveHash = {}
        }
        isImageBitmapSupported() {
            return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(i => {
                let {worker: e} = new Fl;
                e.addEventListener("message", t => {
                    e.terminate(),
                    Fl.revokeObjectURL(),
                    i(t.data)
                }
                )
            }
            ),
            this._isImageBitmapSupported)
        }
        loadImageBitmap(i, e) {
            var t;
            return this._run("loadImageBitmap", [i, (t = e?.data) == null ? void 0 : t.alphaMode])
        }
        async _initWorkers() {
            this._initialized || (this._initialized = !0)
        }
        _getWorker() {
            fc === void 0 && (fc = navigator.hardwareConcurrency || 4);
            let i = this._workerPool.pop();
            return !i && this._createdWorkers < fc && (this._createdWorkers++,
            i = new fm().worker,
            i.addEventListener("message", e => {
                this._complete(e.data),
                this._returnWorker(e.target),
                this._next()
            }
            )),
            i
        }
        _returnWorker(i) {
            this._workerPool.push(i)
        }
        _complete(i) {
            i.error !== void 0 ? this._resolveHash[i.uuid].reject(i.error) : this._resolveHash[i.uuid].resolve(i.data),
            this._resolveHash[i.uuid] = null
        }
        async _run(i, e) {
            await this._initWorkers();
            let t = new Promise( (r, s) => {
                this._queue.push({
                    id: i,
                    arguments: e,
                    resolve: r,
                    reject: s
                })
            }
            );
            return this._next(),
            t
        }
        _next() {
            if (!this._queue.length)
                return;
            let i = this._getWorker();
            if (!i)
                return;
            let e = this._queue.pop()
              , t = e.id;
            this._resolveHash[Zf] = {
                resolve: e.resolve,
                reject: e.reject
            },
            i.postMessage({
                data: e.arguments,
                uuid: Zf++,
                id: t
            })
        }
        reset() {
            this._workerPool.forEach(i => i.terminate()),
            this._workerPool.length = 0,
            Object.values(this._resolveHash).forEach( ({reject: i}) => {
                i?.(new Error("WorkerManager destroyed"))
            }
            ),
            this._resolveHash = {},
            this._queue.length = 0,
            this._initialized = !1,
            this._createdWorkers = 0
        }
    }
    , Qf = new x4, y4 = Object.defineProperty, Jf = Object.getOwnPropertySymbols, v4 = Object.prototype.hasOwnProperty, T4 = Object.prototype.propertyIsEnumerable, ep = (i, e, t) => e in i ? y4(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, S4 = (i, e) => {
        for (var t in e || (e = {}))
            v4.call(e, t) && ep(i, t, e[t]);
        if (Jf)
            for (var t of Jf(e))
                T4.call(e, t) && ep(i, t, e[t]);
        return i
    }
    , w4 = [".jpeg", ".jpg", ".png", ".webp", ".avif"], A4 = ["image/jpeg", "image/png", "image/webp", "image/avif"];
    async function E4(i, e) {
        var t;
        let r = await ye.get().fetch(i);
        if (!r.ok)
            throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${r.status} ${r.statusText}`);
        let s = await r.blob();
        return ((t = e?.data) == null ? void 0 : t.alphaMode) === "premultiplied-alpha" ? createImageBitmap(s, {
            premultiplyAlpha: "none"
        }) : createImageBitmap(s)
    }
    var pm = {
        name: "loadTextures",
        id: "texture",
        extension: {
            type: O.LoadParser,
            priority: Xt.High,
            name: "loadTextures"
        },
        config: {
            preferWorkers: !0,
            preferCreateImageBitmap: !0,
            crossOrigin: "anonymous"
        },
        test(i) {
            return Rr(i, A4) || Kt(i, w4)
        },
        async load(i, e, t) {
            var r;
            let s = null;
            globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await Qf.isImageBitmapSupported() ? s = await Qf.loadImageBitmap(i, e) : s = await E4(i, e) : s = await new Promise( (a, o) => {
                s = ye.get().createImage(),
                s.crossOrigin = this.config.crossOrigin,
                s.src = i,
                s.complete ? a(s) : (s.onload = () => {
                    a(s)
                }
                ,
                s.onerror = o)
            }
            );
            let n = new mi(S4({
                resource: s,
                alphaMode: "premultiply-alpha-on-upload",
                resolution: ((r = e.data) == null ? void 0 : r.resolution) || Uh(i)
            }, e.data));
            return Qi(n, t, i)
        },
        unload(i) {
            i.destroy(!0)
        }
    }, P4 = Object.defineProperty, R4 = Object.defineProperties, M4 = Object.getOwnPropertyDescriptors, tp = Object.getOwnPropertySymbols, C4 = Object.prototype.hasOwnProperty, O4 = Object.prototype.propertyIsEnumerable, ip = (i, e, t) => e in i ? P4(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t, pc = (i, e) => {
        for (var t in e || (e = {}))
            C4.call(e, t) && ip(i, t, e[t]);
        if (tp)
            for (var t of tp(e))
                O4.call(e, t) && ip(i, t, e[t]);
        return i
    }
    , rp = (i, e) => R4(i, M4(e)), I4 = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"], bc, mc;
    function G4(i, e, t) {
        t === void 0 && !e.startsWith("data:") ? i.crossOrigin = F4(e) : t !== !1 && (i.crossOrigin = typeof t == "string" ? t : "anonymous")
    }
    function B4(i) {
        return new Promise( (e, t) => {
            i.addEventListener("canplaythrough", r),
            i.addEventListener("error", s),
            i.load();
            function r() {
                n(),
                e()
            }
            function s(a) {
                n(),
                t(a)
            }
            function n() {
                i.removeEventListener("canplaythrough", r),
                i.removeEventListener("error", s)
            }
        }
        )
    }
    function F4(i, e=globalThis.location) {
        if (i.startsWith("data:"))
            return "";
        e || (e = globalThis.location);
        let t = new URL(i,document.baseURI);
        return t.hostname !== e.hostname || t.port !== e.port || t.protocol !== e.protocol ? "anonymous" : ""
    }
    function D4() {
        let i = []
          , e = [];
        for (let t of I4) {
            let r = ss.MIME_TYPES[t.substring(1)] || `video/${t.substring(1)}`;
            xo(r) && (i.push(t),
            e.includes(r) || e.push(r))
        }
        return {
            validVideoExtensions: i,
            validVideoMime: e
        }
    }
    var k4 = {
        name: "loadVideo",
        id: "video",
        extension: {
            type: O.LoadParser,
            name: "loadVideo"
        },
        test(i) {
            if (!bc || !mc) {
                let {validVideoExtensions: r, validVideoMime: s} = D4();
                bc = r,
                mc = s
            }
            let e = Rr(i, mc)
              , t = Kt(i, bc);
            return e || t
        },
        async load(i, e, t) {
            var r, s;
            let n = pc(rp(pc({}, ss.defaultOptions), {
                resolution: ((r = e.data) == null ? void 0 : r.resolution) || Uh(i),
                alphaMode: ((s = e.data) == null ? void 0 : s.alphaMode) || await fb()
            }), e.data)
              , a = document.createElement("video")
              , o = {
                preload: n.autoLoad !== !1 ? "auto" : void 0,
                "webkit-playsinline": n.playsinline !== !1 ? "" : void 0,
                playsinline: n.playsinline !== !1 ? "" : void 0,
                muted: n.muted === !0 ? "" : void 0,
                loop: n.loop === !0 ? "" : void 0,
                autoplay: n.autoPlay !== !1 ? "" : void 0
            };
            Object.keys(o).forEach(d => {
                let f = o[d];
                f !== void 0 && a.setAttribute(d, f)
            }
            ),
            n.muted === !0 && (a.muted = !0),
            G4(a, i, n.crossorigin);
            let l = document.createElement("source"), u;
            if (n.mime)
                u = n.mime;
            else if (i.startsWith("data:"))
                u = i.slice(5, i.indexOf(";"));
            else if (!i.startsWith("blob:")) {
                let d = i.split("?")[0].slice(i.lastIndexOf(".") + 1).toLowerCase();
                u = ss.MIME_TYPES[d] || `video/${d}`
            }
            return l.src = i,
            u && (l.type = u),
            new Promise(d => {
                let f = async () => {
                    let b = new ss(rp(pc({}, n), {
                        resource: a
                    }));
                    a.removeEventListener("canplay", f),
                    e.data.preload && await B4(a),
                    d(Qi(b, t, i))
                }
                ;
                n.preload && !n.autoPlay && a.load(),
                a.addEventListener("canplay", f),
                a.appendChild(l)
            }
            )
        },
        unload(i) {
            i.destroy(!0)
        }
    }
      , bm = {
        extension: {
            type: O.ResolveParser,
            name: "resolveTexture"
        },
        test: pm.test,
        parse: i => {
            var e, t;
            return {
                resolution: parseFloat((t = (e = bi.RETINA_PREFIX.exec(i)) == null ? void 0 : e[1]) != null ? t : "1"),
                format: i.split(".").pop(),
                src: i
            }
        }
    }
      , U4 = {
        extension: {
            type: O.ResolveParser,
            priority: -2,
            name: "resolveJson"
        },
        test: i => bi.RETINA_PREFIX.test(i) && i.endsWith(".json"),
        parse: bm.parse
    }
      , Dl = class {
        constructor() {
            this._detections = [],
            this._initialized = !1,
            this.resolver = new bi,
            this.loader = new Bl,
            this.cache = Ge,
            this._backgroundLoader = new Gl(this.loader),
            this._backgroundLoader.active = !0,
            this.reset()
        }
        async init(e={}) {
            var t, r, s;
            if (this._initialized)
                return;
            if (this._initialized = !0,
            e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams),
            e.basePath && (this.resolver.basePath = e.basePath),
            e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier),
            e.manifest) {
                let l = e.manifest;
                typeof l == "string" && (l = await this.load(l)),
                this.resolver.addManifest(l)
            }
            let n = (r = (t = e.texturePreference) == null ? void 0 : t.resolution) != null ? r : 1
              , a = typeof n == "number" ? [n] : n
              , o = await this._detectFormats({
                preferredFormats: (s = e.texturePreference) == null ? void 0 : s.format,
                skipDetections: e.skipDetections,
                detections: this._detections
            });
            this.resolver.prefer({
                params: {
                    format: o,
                    resolution: a
                }
            }),
            e.preferences && this.setPreferences(e.preferences)
        }
        add(e) {
            this.resolver.add(e)
        }
        async load(e, t) {
            this._initialized || await this.init();
            let r = Sn(e)
              , s = Vt(e).map(o => {
                if (typeof o != "string") {
                    let l = this.resolver.getAlias(o);
                    return l.some(u => !this.resolver.hasKey(u)) && this.add(o),
                    Array.isArray(l) ? l[0] : l
                }
                return this.resolver.hasKey(o) || this.add({
                    alias: o,
                    src: o
                }),
                o
            }
            )
              , n = this.resolver.resolve(s)
              , a = await this._mapLoadToResolve(n, t);
            return r ? a[s[0]] : a
        }
        addBundle(e, t) {
            this.resolver.addBundle(e, t)
        }
        async loadBundle(e, t) {
            this._initialized || await this.init();
            let r = !1;
            typeof e == "string" && (r = !0,
            e = [e]);
            let s = this.resolver.resolveBundle(e)
              , n = {}
              , a = Object.keys(s)
              , o = 0
              , l = 0
              , u = () => {
                t?.(++o / l)
            }
              , d = a.map(f => {
                let b = s[f]
                  , m = Object.values(b)
                  , x = [...new Set(m.flat())];
                return l += x.length,
                this._mapLoadToResolve(b, u).then(v => {
                    n[f] = v
                }
                )
            }
            );
            return await Promise.all(d),
            r ? n[e[0]] : n
        }
        async backgroundLoad(e) {
            this._initialized || await this.init(),
            typeof e == "string" && (e = [e]);
            let t = this.resolver.resolve(e);
            this._backgroundLoader.add(Object.values(t))
        }
        async backgroundLoadBundle(e) {
            this._initialized || await this.init(),
            typeof e == "string" && (e = [e]);
            let t = this.resolver.resolveBundle(e);
            Object.values(t).forEach(r => {
                this._backgroundLoader.add(Object.values(r))
            }
            )
        }
        reset() {
            this.resolver.reset(),
            this.loader.reset(),
            this.cache.reset(),
            this._initialized = !1
        }
        get(e) {
            if (typeof e == "string")
                return Ge.get(e);
            let t = {};
            for (let r = 0; r < e.length; r++)
                t[r] = Ge.get(e[r]);
            return t
        }
        async _mapLoadToResolve(e, t) {
            let r = [...new Set(Object.values(e))];
            this._backgroundLoader.active = !1;
            let s = await this.loader.load(r, t);
            this._backgroundLoader.active = !0;
            let n = {};
            return r.forEach(a => {
                let o = s[a.src]
                  , l = [a.src];
                a.alias && l.push(...a.alias),
                l.forEach(u => {
                    n[u] = o
                }
                ),
                Ge.set(l, o)
            }
            ),
            n
        }
        async unload(e) {
            this._initialized || await this.init();
            let t = Vt(e).map(s => typeof s != "string" ? s.src : s)
              , r = this.resolver.resolve(t);
            await this._unloadFromResolved(r)
        }
        async unloadBundle(e) {
            this._initialized || await this.init(),
            e = Vt(e);
            let t = this.resolver.resolveBundle(e)
              , r = Object.keys(t).map(s => this._unloadFromResolved(t[s]));
            await Promise.all(r)
        }
        async _unloadFromResolved(e) {
            let t = Object.values(e);
            t.forEach(r => {
                Ge.remove(r.src)
            }
            ),
            await this.loader.unload(t)
        }
        async _detectFormats(e) {
            let t = [];
            e.preferredFormats && (t = Array.isArray(e.preferredFormats) ? e.preferredFormats : [e.preferredFormats]);
            for (let r of e.detections)
                e.skipDetections || await r.test() ? t = await r.add(t) : e.skipDetections || (t = await r.remove(t));
            return t = t.filter( (r, s) => t.indexOf(r) === s),
            t
        }
        get detections() {
            return this._detections
        }
        setPreferences(e) {
            this.loader.parsers.forEach(t => {
                t.config && Object.keys(t.config).filter(r => r in e).forEach(r => {
                    t.config[r] = e[r]
                }
                )
            }
            )
        }
    }
      , we = new Dl;
    be.handleByList(O.LoadParser, we.loader.parsers).handleByList(O.ResolveParser, we.resolver.parsers).handleByList(O.CacheParser, we.cache.parsers).handleByList(O.DetectionParser, we.detections),
    be.add(B3, D3, F3, X3, U3, L3, N3, z3, Y3, c4, p4, pm, k4, G3, I3, bm, U4);
    var sp = {
        loader: O.LoadParser,
        resolver: O.ResolveParser,
        cache: O.CacheParser,
        detection: O.DetectionParser
    };
    be.handle(O.Asset, i => {
        let e = i.ref;
        Object.entries(sp).filter( ([t]) => !!e[t]).forEach( ([t,r]) => {
            var s;
            return be.add(Object.assign(e[t], {
                extension: (s = e[t].extension) != null ? s : r
            }))
        }
        )
    }
    , i => {
        let e = i.ref;
        Object.keys(sp).filter(t => !!e[t]).forEach(t => be.remove(e[t]))
    }
    );
    var yw = {
        extension: {
            type: O.DetectionParser,
            priority: 3
        },
        test: async () => !!(await go() || mo()),
        add: async i => [...i, "basis"],
        remove: async i => i.filter(e => e !== "basis")
    }, Er = class extends Xe {
        constructor(e) {
            super(e),
            this.uploadMethodId = "compressed",
            this.resource = e.resource,
            this.mipLevelCount = this.resource.length
        }
    }
    , Qs;
    function np() {
        if (Qs)
            return Qs;
        let i = ye.get().createCanvas(1, 1).getContext("webgl");
        return i ? (Qs = [...i.getExtension("EXT_texture_compression_bptc") ? ["bc6h-rgb-ufloat", "bc6h-rgb-float", "bc7-rgba-unorm", "bc7-rgba-unorm-srgb"] : [], ...i.getExtension("WEBGL_compressed_texture_s3tc") ? ["bc1-rgba-unorm", "bc2-rgba-unorm", "bc3-rgba-unorm"] : [], ...i.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? ["bc1-rgba-unorm-srgb", "bc2-rgba-unorm-srgb", "bc3-rgba-unorm-srgb"] : [], ...i.getExtension("EXT_texture_compression_rgtc") ? ["bc4-r-unorm", "bc4-r-snorm", "bc5-rg-unorm", "bc5-rg-snorm"] : [], ...i.getExtension("WEBGL_compressed_texture_etc") ? ["etc2-rgb8unorm", "etc2-rgb8unorm-srgb", "etc2-rgba8unorm", "etc2-rgba8unorm-srgb", "etc2-rgb8a1unorm", "etc2-rgb8a1unorm-srgb", "eac-r11unorm", "eac-rg11unorm"] : [], ...i.getExtension("WEBGL_compressed_texture_astc") ? ["astc-4x4-unorm", "astc-4x4-unorm-srgb", "astc-5x4-unorm", "astc-5x4-unorm-srgb", "astc-5x5-unorm", "astc-5x5-unorm-srgb", "astc-6x5-unorm", "astc-6x5-unorm-srgb", "astc-6x6-unorm", "astc-6x6-unorm-srgb", "astc-8x5-unorm", "astc-8x5-unorm-srgb", "astc-8x6-unorm", "astc-8x6-unorm-srgb", "astc-8x8-unorm", "astc-8x8-unorm-srgb", "astc-10x5-unorm", "astc-10x5-unorm-srgb", "astc-10x6-unorm", "astc-10x6-unorm-srgb", "astc-10x8-unorm", "astc-10x8-unorm-srgb", "astc-10x10-unorm", "astc-10x10-unorm-srgb", "astc-12x10-unorm", "astc-12x10-unorm-srgb", "astc-12x12-unorm", "astc-12x12-unorm-srgb"] : []],
        Qs) : []
    }
    var Js;
    async function ap() {
        if (Js)
            return Js;
        let i = await ye.get().getNavigator().gpu.requestAdapter();
        return Js = [...i.features.has("texture-compression-bc") ? ["bc1-rgba-unorm", "bc1-rgba-unorm-srgb", "bc2-rgba-unorm", "bc2-rgba-unorm-srgb", "bc3-rgba-unorm", "bc3-rgba-unorm-srgb", "bc4-r-unorm", "bc4-r-snorm", "bc5-rg-unorm", "bc5-rg-snorm", "bc6h-rgb-ufloat", "bc6h-rgb-float", "bc7-rgba-unorm", "bc7-rgba-unorm-srgb"] : [], ...i.features.has("texture-compression-etc2") ? ["etc2-rgb8unorm", "etc2-rgb8unorm-srgb", "etc2-rgb8a1unorm", "etc2-rgb8a1unorm-srgb", "etc2-rgba8unorm", "etc2-rgba8unorm-srgb", "eac-r11unorm", "eac-r11snorm", "eac-rg11unorm", "eac-rg11snorm"] : [], ...i.features.has("texture-compression-astc") ? ["astc-4x4-unorm", "astc-4x4-unorm-srgb", "astc-5x4-unorm", "astc-5x4-unorm-srgb", "astc-5x5-unorm", "astc-5x5-unorm-srgb", "astc-6x5-unorm", "astc-6x5-unorm-srgb", "astc-6x6-unorm", "astc-6x6-unorm-srgb", "astc-8x5-unorm", "astc-8x5-unorm-srgb", "astc-8x6-unorm", "astc-8x6-unorm-srgb", "astc-8x8-unorm", "astc-8x8-unorm-srgb", "astc-10x5-unorm", "astc-10x5-unorm-srgb", "astc-10x6-unorm", "astc-10x6-unorm-srgb", "astc-10x8-unorm", "astc-10x8-unorm-srgb", "astc-10x10-unorm", "astc-10x10-unorm-srgb", "astc-12x10-unorm", "astc-12x10-unorm-srgb", "astc-12x12-unorm", "astc-12x12-unorm-srgb"] : []],
        Js
    }
    var gc;
    async function mm() {
        return gc !== void 0 || (gc = await (async () => {
            let i = await go()
              , e = mo();
            if (i && e) {
                let t = await ap()
                  , r = np();
                return t.filter(s => r.includes(s))
            } else {
                if (i)
                    return await ap();
                if (e)
                    return np()
            }
            return []
        }
        )()),
        gc
    }
    var L4 = ["r8unorm", "r8snorm", "r8uint", "r8sint", "r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm-srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm-srgb", "rgb9e5ufloat", "rgb10a2unorm", "rg11b10ufloat", "rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float", "rgba32uint", "rgba32sint", "rgba32float", "stencil8", "depth16unorm", "depth24plus", "depth24plus-stencil8", "depth32float", "depth32float-stencil8"], en;
    async function yo() {
        if (en !== void 0)
            return en;
        let i = await mm();
        return en = [...L4, ...i],
        en
    }
    var N4 = '(function(){"use strict";function g(r,a){const t=r.getNumImages(),s=r.getNumLevels(0);if(!r.startTranscoding())throw new Error("startTranscoding failed");const m=[];for(let e=0;e<s;++e)for(let o=0;o<t;++o){const B=r.getImageTranscodedSizeInBytes(o,e,a),f=new Uint8Array(B);if(!r.transcodeImage(f,o,e,a,1,0))throw new Error("transcodeImage failed");m.push(f)}return m}const w={"bc3-rgba-unorm":3,"bc7-rgba-unorm":6,"etc2-rgba8unorm":1,"astc-4x4-unorm":10,rgba8unorm:13,rgba4unorm:16};function d(r){const a=w[r];if(a)return a;throw new Error(`Unsupported transcoderFormat: ${r}`)}const n={jsUrl:"basis/basis_transcoder.js",wasmUrl:"basis/basis_transcoder.wasm"};let u,i,c;async function l(){if(!c){const r=new URL(n.jsUrl,location.origin).href,a=new URL(n.wasmUrl,location.origin).href;importScripts(r),c=new Promise(t=>{BASIS({locateFile:s=>a}).then(s=>{s.initializeBasis(),t(s.BasisFile)})})}return c}async function b(r,a){const t=await fetch(r);if(t.ok){const s=await t.arrayBuffer();return new a(new Uint8Array(s))}throw new Error(`Failed to load Basis texture: ${r}`)}const h=["bc7-rgba-unorm","astc-4x4-unorm","etc2-rgba8unorm","bc3-rgba-unorm","rgba8unorm"];async function p(r){const a=await l(),t=await b(r,a),s=g(t,u);return{width:t.getImageWidth(0,0),height:t.getImageHeight(0,0),format:i,resource:s,alphaMode:"no-premultiply-alpha"}}async function y(r,a,t){r&&(n.jsUrl=r),a&&(n.wasmUrl=a),i=h.filter(s=>t.includes(s))[0],u=d(i),await l()}const U={init:async r=>{const{jsUrl:a,wasmUrl:t,supportedTextures:s}=r;await y(a,t,s)},load:async r=>{var a;try{const t=await p(r.url);return{type:"load",url:r.url,success:!0,textureOptions:t,transferables:(a=t.resource)==null?void 0:a.map(s=>s.buffer)}}catch(t){throw t}}};self.onmessage=async r=>{const a=r.data,t=await U[a.type](a);t&&self.postMessage(t,t.transferables)}})();\n'
      , gr = null
      , gm = class {
        constructor() {
            gr || (gr = URL.createObjectURL(new Blob([N4],{
                type: "application/javascript"
            }))),
            this.worker = new Worker(gr)
        }
    }
    ;
    gm.revokeObjectURL = function() {
        gr && (URL.revokeObjectURL(gr),
        gr = null)
    }
    ;
    var op = {
        jsUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.js",
        wasmUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"
    };
    var zr, _m = {};
    function X4(i) {
        return zr || (zr = new gm().worker,
        zr.onmessage = e => {
            let {success: t, url: r, textureOptions: s} = e.data;
            _m[r](s)
        }
        ,
        zr.postMessage({
            type: "init",
            jsUrl: op.jsUrl,
            wasmUrl: op.wasmUrl,
            supportedTextures: i
        })),
        zr
    }
    function j4(i, e) {
        let t = X4(e);
        return new Promise(r => {
            _m[i] = r,
            t.postMessage({
                type: "load",
                url: i
            })
        }
        )
    }
    var vw = {
        extension: {
            type: O.LoadParser,
            priority: Xt.High,
            name: "loadBasis"
        },
        name: "loadBasis",
        id: "basis",
        test(i) {
            return Kt(i, [".basis"])
        },
        async load(i, e, t) {
            let r = await yo()
              , s = await j4(i, r)
              , n = new Er(s);
            return Qi(n, t, i)
        },
        unload(i) {
            Array.isArray(i) ? i.forEach(e => e.destroy(!0)) : i.destroy(!0)
        }
    };
    var H4 = {
        MAGIC: 0,
        SIZE: 1,
        FLAGS: 2,
        HEIGHT: 3,
        WIDTH: 4,
        MIPMAP_COUNT: 7,
        PIXEL_FORMAT: 19,
        PF_FLAGS: 20,
        FOURCC: 21,
        RGB_BITCOUNT: 22,
        R_BIT_MASK: 23,
        G_BIT_MASK: 24,
        B_BIT_MASK: 25,
        A_BIT_MASK: 26
    }
      , z4 = {
        DXGI_FORMAT: 0,
        RESOURCE_DIMENSION: 1,
        MISC_FLAG: 2,
        ARRAY_SIZE: 3,
        MISC_FLAGS2: 4
    }
      , xm = (i => (i[i.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN",
    i[i.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS",
    i[i.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT",
    i[i.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT",
    i[i.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT",
    i[i.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS",
    i[i.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT",
    i[i.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT",
    i[i.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT",
    i[i.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS",
    i[i.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT",
    i[i.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM",
    i[i.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT",
    i[i.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM",
    i[i.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT",
    i[i.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS",
    i[i.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT",
    i[i.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT",
    i[i.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT",
    i[i.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS",
    i[i.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT",
    i[i.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS",
    i[i.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT",
    i[i.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS",
    i[i.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM",
    i[i.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT",
    i[i.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT",
    i[i.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS",
    i[i.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM",
    i[i.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB",
    i[i.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT",
    i[i.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM",
    i[i.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT",
    i[i.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS",
    i[i.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT",
    i[i.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM",
    i[i.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT",
    i[i.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM",
    i[i.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT",
    i[i.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS",
    i[i.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT",
    i[i.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT",
    i[i.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT",
    i[i.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT",
    i[i.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS",
    i[i.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT",
    i[i.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS",
    i[i.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT",
    i[i.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS",
    i[i.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM",
    i[i.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT",
    i[i.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM",
    i[i.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT",
    i[i.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS",
    i[i.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT",
    i[i.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM",
    i[i.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM",
    i[i.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT",
    i[i.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM",
    i[i.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT",
    i[i.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS",
    i[i.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM",
    i[i.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT",
    i[i.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM",
    i[i.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT",
    i[i.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM",
    i[i.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM",
    i[i.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP",
    i[i.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM",
    i[i.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM",
    i[i.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS",
    i[i.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM",
    i[i.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB",
    i[i.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS",
    i[i.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM",
    i[i.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB",
    i[i.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS",
    i[i.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM",
    i[i.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB",
    i[i.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS",
    i[i.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM",
    i[i.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM",
    i[i.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS",
    i[i.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM",
    i[i.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM",
    i[i.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM",
    i[i.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM",
    i[i.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM",
    i[i.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM",
    i[i.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM",
    i[i.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS",
    i[i.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB",
    i[i.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS",
    i[i.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB",
    i[i.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS",
    i[i.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16",
    i[i.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16",
    i[i.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS",
    i[i.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM",
    i[i.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB",
    i[i.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV",
    i[i.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410",
    i[i.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416",
    i[i.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12",
    i[i.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010",
    i[i.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016",
    i[i.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE",
    i[i.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2",
    i[i.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210",
    i[i.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216",
    i[i.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11",
    i[i.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44",
    i[i.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44",
    i[i.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8",
    i[i.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8",
    i[i.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM",
    i[i.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208",
    i[i.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208",
    i[i.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408",
    i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE",
    i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE",
    i[i.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT",
    i))(xm || {})
      , ym = (i => (i[i.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D",
    i[i.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D",
    i[i.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D",
    i))(ym || {});
    function rt(i) {
        return i.charCodeAt(0) + (i.charCodeAt(1) << 8) + (i.charCodeAt(2) << 16) + (i.charCodeAt(3) << 24)
    }
    var At = (i => (i[i.UNKNOWN = 0] = "UNKNOWN",
    i[i.R8G8B8 = 20] = "R8G8B8",
    i[i.A8R8G8B8 = 21] = "A8R8G8B8",
    i[i.X8R8G8B8 = 22] = "X8R8G8B8",
    i[i.R5G6B5 = 23] = "R5G6B5",
    i[i.X1R5G5B5 = 24] = "X1R5G5B5",
    i[i.A1R5G5B5 = 25] = "A1R5G5B5",
    i[i.A4R4G4B4 = 26] = "A4R4G4B4",
    i[i.R3G3B2 = 27] = "R3G3B2",
    i[i.A8 = 28] = "A8",
    i[i.A8R3G3B2 = 29] = "A8R3G3B2",
    i[i.X4R4G4B4 = 30] = "X4R4G4B4",
    i[i.A2B10G10R10 = 31] = "A2B10G10R10",
    i[i.A8B8G8R8 = 32] = "A8B8G8R8",
    i[i.X8B8G8R8 = 33] = "X8B8G8R8",
    i[i.G16R16 = 34] = "G16R16",
    i[i.A2R10G10B10 = 35] = "A2R10G10B10",
    i[i.A16B16G16R16 = 36] = "A16B16G16R16",
    i[i.A8P8 = 40] = "A8P8",
    i[i.P8 = 41] = "P8",
    i[i.L8 = 50] = "L8",
    i[i.A8L8 = 51] = "A8L8",
    i[i.A4L4 = 52] = "A4L4",
    i[i.V8U8 = 60] = "V8U8",
    i[i.L6V5U5 = 61] = "L6V5U5",
    i[i.X8L8V8U8 = 62] = "X8L8V8U8",
    i[i.Q8W8V8U8 = 63] = "Q8W8V8U8",
    i[i.V16U16 = 64] = "V16U16",
    i[i.A2W10V10U10 = 67] = "A2W10V10U10",
    i[i.Q16W16V16U16 = 110] = "Q16W16V16U16",
    i[i.R16F = 111] = "R16F",
    i[i.G16R16F = 112] = "G16R16F",
    i[i.A16B16G16R16F = 113] = "A16B16G16R16F",
    i[i.R32F = 114] = "R32F",
    i[i.G32R32F = 115] = "G32R32F",
    i[i.A32B32G32R32F = 116] = "A32B32G32R32F",
    i[i.UYVY = rt("UYVY")] = "UYVY",
    i[i.R8G8_B8G8 = rt("RGBG")] = "R8G8_B8G8",
    i[i.YUY2 = rt("YUY2")] = "YUY2",
    i[i.D3DFMT_G8R8_G8B8 = rt("GRGB")] = "D3DFMT_G8R8_G8B8",
    i[i.DXT1 = rt("DXT1")] = "DXT1",
    i[i.DXT2 = rt("DXT2")] = "DXT2",
    i[i.DXT3 = rt("DXT3")] = "DXT3",
    i[i.DXT4 = rt("DXT4")] = "DXT4",
    i[i.DXT5 = rt("DXT5")] = "DXT5",
    i[i.ATI1 = rt("ATI1")] = "ATI1",
    i[i.AT1N = rt("AT1N")] = "AT1N",
    i[i.ATI2 = rt("ATI2")] = "ATI2",
    i[i.AT2N = rt("AT2N")] = "AT2N",
    i[i.BC4U = rt("BC4U")] = "BC4U",
    i[i.BC4S = rt("BC4S")] = "BC4S",
    i[i.BC5U = rt("BC5U")] = "BC5U",
    i[i.BC5S = rt("BC5S")] = "BC5S",
    i[i.DX10 = rt("DX10")] = "DX10",
    i))(At || {})
      , cp = {
        [At.DXT1]: "bc1-rgba-unorm",
        [At.DXT2]: "bc2-rgba-unorm",
        [At.DXT3]: "bc2-rgba-unorm",
        [At.DXT4]: "bc3-rgba-unorm",
        [At.DXT5]: "bc3-rgba-unorm",
        [At.ATI1]: "bc4-r-unorm",
        [At.BC4U]: "bc4-r-unorm",
        [At.BC4S]: "bc4-r-snorm",
        [At.ATI2]: "bc5-rg-unorm",
        [At.BC5U]: "bc5-rg-unorm",
        [At.BC5S]: "bc5-rg-snorm",
        36: "rgba16uint",
        110: "rgba16sint",
        111: "r16float",
        112: "rg16float",
        113: "rgba16float",
        114: "r32float",
        115: "rg32float",
        116: "rgba32float"
    }
      , Et = {
        70: "bc1-rgba-unorm",
        71: "bc1-rgba-unorm",
        72: "bc1-rgba-unorm-srgb",
        73: "bc2-rgba-unorm",
        74: "bc2-rgba-unorm",
        75: "bc2-rgba-unorm-srgb",
        76: "bc3-rgba-unorm",
        77: "bc3-rgba-unorm",
        78: "bc3-rgba-unorm-srgb",
        79: "bc4-r-unorm",
        80: "bc4-r-unorm",
        81: "bc4-r-snorm",
        82: "bc5-rg-unorm",
        83: "bc5-rg-unorm",
        84: "bc5-rg-snorm",
        94: "bc6h-rgb-ufloat",
        95: "bc6h-rgb-ufloat",
        96: "bc6h-rgb-float",
        97: "bc7-rgba-unorm",
        98: "bc7-rgba-unorm",
        99: "bc7-rgba-unorm-srgb",
        28: "rgba8unorm",
        29: "rgba8unorm-srgb",
        87: "bgra8unorm",
        91: "bgra8unorm-srgb",
        41: "r32float",
        49: "rg8unorm",
        56: "r16uint",
        61: "r8unorm",
        24: "rgb10a2unorm",
        11: "rgba16uint",
        13: "rgba16sint",
        10: "rgba16float",
        54: "r16float",
        34: "rg16float",
        16: "rg32float",
        2: "rgba32float"
    }
      , ge = {
        MAGIC_VALUE: 542327876,
        MAGIC_SIZE: 4,
        HEADER_SIZE: 124,
        HEADER_DX10_SIZE: 20,
        PIXEL_FORMAT_FLAGS: {
            ALPHAPIXELS: 1,
            ALPHA: 2,
            FOURCC: 4,
            RGB: 64,
            RGBA: 65,
            YUV: 512,
            LUMINANCE: 131072,
            LUMINANCEA: 131073
        },
        RESOURCE_MISC_TEXTURECUBE: 4,
        HEADER_FIELDS: H4,
        HEADER_DX10_FIELDS: z4,
        DXGI_FORMAT: xm,
        D3D10_RESOURCE_DIMENSION: ym,
        D3DFMT: At
    }
      , V4 = {
        "bc1-rgba-unorm": 8,
        "bc1-rgba-unorm-srgb": 8,
        "bc2-rgba-unorm": 16,
        "bc2-rgba-unorm-srgb": 16,
        "bc3-rgba-unorm": 16,
        "bc3-rgba-unorm-srgb": 16,
        "bc4-r-unorm": 8,
        "bc4-r-snorm": 8,
        "bc5-rg-unorm": 16,
        "bc5-rg-snorm": 16,
        "bc6h-rgb-ufloat": 16,
        "bc6h-rgb-float": 16,
        "bc7-rgba-unorm": 16,
        "bc7-rgba-unorm-srgb": 16
    };
    function W4(i, e) {
        let {format: t, fourCC: r, width: s, height: n, dataOffset: a, mipmapCount: o} = $4(i);
        if (!e.includes(t))
            throw new Error(`Unsupported texture format: ${r} ${t}, supported: ${e}`);
        if (o <= 1)
            return {
                format: t,
                width: s,
                height: n,
                resource: [new Uint8Array(i,a)],
                alphaMode: "no-premultiply-alpha"
            };
        let l = Y4(t, s, n, a, o, i);
        return {
            format: t,
            width: s,
            height: n,
            resource: l,
            alphaMode: "no-premultiply-alpha"
        }
    }
    function Y4(i, e, t, r, s, n) {
        let a = []
          , o = V4[i]
          , l = e
          , u = t
          , d = r;
        for (let f = 0; f < s; ++f) {
            let b = Math.ceil(Math.max(4, l) / 4) * 4
              , m = Math.ceil(Math.max(4, u) / 4) * 4
              , x = o ? b / 4 * m / 4 * o : l * u * 4
              , v = new Uint8Array(n,d,x);
            a.push(v),
            d += x,
            l = Math.max(l >> 1, 1),
            u = Math.max(u >> 1, 1)
        }
        return a
    }
    function $4(i) {
        let e = new Uint32Array(i,0,ge.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
        if (e[ge.HEADER_FIELDS.MAGIC] !== ge.MAGIC_VALUE)
            throw new Error("Invalid magic number in DDS header");
        let t = e[ge.HEADER_FIELDS.HEIGHT]
          , r = e[ge.HEADER_FIELDS.WIDTH]
          , s = Math.max(1, e[ge.HEADER_FIELDS.MIPMAP_COUNT])
          , n = e[ge.HEADER_FIELDS.PF_FLAGS]
          , a = e[ge.HEADER_FIELDS.FOURCC]
          , o = K4(e, n, a, i)
          , l = ge.MAGIC_SIZE + ge.HEADER_SIZE + (a === ge.D3DFMT.DX10 ? ge.HEADER_DX10_SIZE : 0);
        return {
            format: o,
            fourCC: a,
            width: r,
            height: t,
            dataOffset: l,
            mipmapCount: s
        }
    }
    function K4(i, e, t, r) {
        if (e & ge.PIXEL_FORMAT_FLAGS.FOURCC) {
            if (t === ge.D3DFMT.DX10) {
                let s = new Uint32Array(r,ge.MAGIC_SIZE + ge.HEADER_SIZE,ge.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
                if (s[ge.HEADER_DX10_FIELDS.MISC_FLAG] === ge.RESOURCE_MISC_TEXTURECUBE)
                    throw new Error("DDSParser does not support cubemap textures");
                if (s[ge.HEADER_DX10_FIELDS.RESOURCE_DIMENSION] === ge.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)
                    throw new Error("DDSParser does not supported 3D texture data");
                let n = s[ge.HEADER_DX10_FIELDS.DXGI_FORMAT];
                if (n in Et)
                    return Et[n];
                throw new Error(`DDSParser cannot parse texture data with DXGI format ${n}`)
            }
            if (t in cp)
                return cp[t];
            throw new Error(`DDSParser cannot parse texture data with fourCC format ${t}`)
        }
        if (e & ge.PIXEL_FORMAT_FLAGS.RGB || e & ge.PIXEL_FORMAT_FLAGS.RGBA)
            return q4(i);
        throw e & ge.PIXEL_FORMAT_FLAGS.YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : e & ge.PIXEL_FORMAT_FLAGS.LUMINANCE || e & ge.PIXEL_FORMAT_FLAGS.LUMINANCEA ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : e & ge.PIXEL_FORMAT_FLAGS.ALPHA || e & ge.PIXEL_FORMAT_FLAGS.ALPHAPIXELS ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
    }
    function q4(i) {
        let e = i[ge.HEADER_FIELDS.RGB_BITCOUNT]
          , t = i[ge.HEADER_FIELDS.R_BIT_MASK]
          , r = i[ge.HEADER_FIELDS.G_BIT_MASK]
          , s = i[ge.HEADER_FIELDS.B_BIT_MASK]
          , n = i[ge.HEADER_FIELDS.A_BIT_MASK];
        switch (e) {
        case 32:
            if (t === 255 && r === 65280 && s === 16711680 && n === 4278190080)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
            if (t === 16711680 && r === 65280 && s === 255 && n === 4278190080)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
            if (t === 1072693248 && r === 1047552 && s === 1023 && n === 3221225472)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
            if (t === 65535 && r === 4294901760 && s === 0 && n === 0)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
            if (t === 4294967295 && r === 0 && s === 0 && n === 0)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
            break;
        case 24:
            break;
        case 16:
            if (t === 31744 && r === 992 && s === 31 && n === 32768)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
            if (t === 63488 && r === 2016 && s === 31 && n === 0)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
            if (t === 3840 && r === 240 && s === 15 && n === 61440)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
            if (t === 255 && r === 0 && s === 0 && n === 65280)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
            if (t === 65535 && r === 0 && s === 0 && n === 0)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
            break;
        case 8:
            if (t === 255 && r === 0 && s === 0 && n === 0)
                return Et[ge.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
            break
        }
        throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${e}, rBitMask = ${t}, gBitMask = ${r}, aBitMask = ${n}`)
    }
    var Tw = {
        extension: {
            type: O.LoadParser,
            priority: Xt.High,
            name: "loadDDS"
        },
        name: "loadDDS",
        id: "dds",
        test(i) {
            return Kt(i, [".dds"])
        },
        async load(i, e, t) {
            let r = await yo()
              , s = await (await fetch(i)).arrayBuffer()
              , n = W4(s, r)
              , a = new Er(n);
            return Qi(a, t, i)
        },
        unload(i) {
            Array.isArray(i) ? i.forEach(e => e.destroy(!0)) : i.destroy(!0)
        }
    }
      , Z4 = (i => (i[i.RGBA8_SNORM = 36759] = "RGBA8_SNORM",
    i[i.RGBA = 6408] = "RGBA",
    i[i.RGBA8UI = 36220] = "RGBA8UI",
    i[i.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8",
    i[i.RGBA8I = 36238] = "RGBA8I",
    i[i.RGBA8 = 32856] = "RGBA8",
    i[i.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT",
    i[i.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT",
    i[i.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT",
    i[i.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT",
    i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",
    i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",
    i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",
    i[i.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT",
    i[i.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT",
    i[i.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT",
    i[i.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT",
    i[i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT",
    i[i.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC",
    i[i.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC",
    i[i.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC",
    i[i.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC",
    i[i.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2",
    i[i.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC",
    i[i.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2",
    i[i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
    i[i.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
    i[i.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
    i[i.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR",
    i[i.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR",
    i[i.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR",
    i[i.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR",
    i[i.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR",
    i[i.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR",
    i[i.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR",
    i[i.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR",
    i[i.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR",
    i[i.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR",
    i[i.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR",
    i[i.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR",
    i[i.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR",
    i[i.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",
    i[i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",
    i[i.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT",
    i[i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT",
    i[i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT",
    i[i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT",
    i))(Z4 || {})
      , Q4 = (i => (i[i.RGBA = 6408] = "RGBA",
    i[i.RGB = 6407] = "RGB",
    i[i.RG = 33319] = "RG",
    i[i.RED = 6403] = "RED",
    i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
    i[i.RGB_INTEGER = 36248] = "RGB_INTEGER",
    i[i.RG_INTEGER = 33320] = "RG_INTEGER",
    i[i.RED_INTEGER = 36244] = "RED_INTEGER",
    i[i.ALPHA = 6406] = "ALPHA",
    i[i.LUMINANCE = 6409] = "LUMINANCE",
    i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
    i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
    i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
    i))(Q4 || {})
      , J4 = (i => (i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
    i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
    i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
    i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
    i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
    i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
    i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
    i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
    i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
    i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
    i[i.BYTE = 5120] = "BYTE",
    i[i.SHORT = 5122] = "SHORT",
    i[i.INT = 5124] = "INT",
    i[i.FLOAT = 5126] = "FLOAT",
    i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
    i[i.HALF_FLOAT = 36193] = "HALF_FLOAT",
    i))(J4 || {})
      , eT = {
        33776: "bc1-rgba-unorm",
        33777: "bc1-rgba-unorm",
        33778: "bc2-rgba-unorm",
        33779: "bc3-rgba-unorm",
        35916: "bc1-rgba-unorm-srgb",
        35917: "bc1-rgba-unorm-srgb",
        35918: "bc2-rgba-unorm-srgb",
        35919: "bc3-rgba-unorm-srgb",
        36283: "bc4-r-unorm",
        36284: "bc4-r-snorm",
        36285: "bc5-rg-unorm",
        36286: "bc5-rg-snorm",
        37488: "eac-r11unorm",
        37490: "eac-rg11snorm",
        37492: "etc2-rgb8unorm",
        37496: "etc2-rgba8unorm",
        37493: "etc2-rgb8unorm-srgb",
        37497: "etc2-rgba8unorm-srgb",
        37494: "etc2-rgb8a1unorm",
        37495: "etc2-rgb8a1unorm-srgb",
        37808: "astc-4x4-unorm",
        37840: "astc-4x4-unorm-srgb",
        37809: "astc-5x4-unorm",
        37841: "astc-5x4-unorm-srgb",
        37810: "astc-5x5-unorm",
        37842: "astc-5x5-unorm-srgb",
        37811: "astc-6x5-unorm",
        37843: "astc-6x5-unorm-srgb",
        37812: "astc-6x6-unorm",
        37844: "astc-6x6-unorm-srgb",
        37813: "astc-8x5-unorm",
        37845: "astc-8x5-unorm-srgb",
        37814: "astc-8x6-unorm",
        37846: "astc-8x6-unorm-srgb",
        37815: "astc-8x8-unorm",
        37847: "astc-8x8-unorm-srgb",
        37816: "astc-10x5-unorm",
        37848: "astc-10x5-unorm-srgb",
        37817: "astc-10x6-unorm",
        37849: "astc-10x6-unorm-srgb",
        37818: "astc-10x8-unorm",
        37850: "astc-10x8-unorm-srgb",
        37819: "astc-10x10-unorm",
        37851: "astc-10x10-unorm-srgb",
        37820: "astc-12x10-unorm",
        37852: "astc-12x10-unorm-srgb",
        37821: "astc-12x12-unorm",
        37853: "astc-12x12-unorm-srgb",
        36492: "bc7-rgba-unorm",
        36493: "bc7-rgba-unorm-srgb",
        36494: "bc6h-rgb-float",
        36495: "bc6h-rgb-ufloat",
        35907: "rgba8unorm-srgb",
        36759: "rgba8snorm",
        36220: "rgba8uint",
        36238: "rgba8sint",
        6408: "rgba8unorm"
    }
      , tT = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
      , iT = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
    }
      , rT = 64
      , sT = 67305985
      , nT = {
        5121: 1,
        5123: 2,
        5124: 4,
        5125: 4,
        5126: 4,
        36193: 8
    }
      , aT = {
        6408: 4,
        6407: 3,
        33319: 2,
        6403: 1,
        6409: 1,
        6410: 2,
        6406: 1
    }
      , oT = {
        32819: 2,
        32820: 2,
        33635: 2
    }
      , cT = {
        33776: .5,
        33777: .5,
        33778: 1,
        33779: 1,
        35916: .5,
        35917: .5,
        35918: 1,
        35919: 1,
        36283: .5,
        36284: .5,
        36285: 1,
        36286: 1,
        37488: .5,
        37489: .5,
        37490: 1,
        37491: 1,
        37492: .5,
        37496: 1,
        37493: .5,
        37497: 1,
        37494: .5,
        37495: .5,
        37808: 1,
        37840: 1,
        37809: .8,
        37841: .8,
        37810: .64,
        37842: .64,
        37811: .53375,
        37843: .53375,
        37812: .445,
        37844: .445,
        37813: .4,
        37845: .4,
        37814: .33375,
        37846: .33375,
        37815: .25,
        37847: .25,
        37816: .32,
        37848: .32,
        37817: .26625,
        37849: .26625,
        37818: .2,
        37850: .2,
        37819: .16,
        37851: .16,
        37820: .13375,
        37852: .13375,
        37821: .11125,
        37853: .11125,
        36492: 1,
        36493: 1,
        36494: 1,
        36495: 1
    }
      , $e = {
        FILE_HEADER_SIZE: rT,
        FILE_IDENTIFIER: tT,
        FORMATS_TO_COMPONENTS: aT,
        INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: cT,
        INTERNAL_FORMAT_TO_TEXTURE_FORMATS: eT,
        FIELDS: iT,
        TYPES_TO_BYTES_PER_COMPONENT: nT,
        TYPES_TO_BYTES_PER_PIXEL: oT,
        ENDIANNESS: sT
    };
    function lT(i, e) {
        let t = new DataView(i);
        if (!fT(t))
            throw new Error("Invalid KTX identifier in header");
        let {littleEndian: r, glType: s, glFormat: n, glInternalFormat: a, pixelWidth: o, pixelHeight: l, numberOfMipmapLevels: u, offset: d} = dT(t)
          , f = $e.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[a];
        if (!f)
            throw new Error(`Unknown texture format ${a}`);
        if (!e.includes(f))
            throw new Error(`Unsupported texture format: ${f}, supportedFormats: ${e}`);
        let b = uT(s, n, a)
          , m = hT(t, s, b, o, l, d, u, r);
        return {
            format: f,
            width: o,
            height: l,
            resource: m,
            alphaMode: "no-premultiply-alpha"
        }
    }
    function hT(i, e, t, r, s, n, a, o) {
        let l = r + 3 & -4
          , u = s + 3 & -4
          , d = r * s;
        e === 0 && (d = l * u);
        let f = d * t
          , b = r
          , m = s
          , x = l
          , v = u
          , S = n
          , w = new Array(a);
        for (let E = 0; E < a; E++) {
            let P = i.getUint32(S, o)
              , C = S + 4;
            w[E] = new Uint8Array(i.buffer,C,f),
            C += f,
            S += P + 4,
            S = S % 4 !== 0 ? S + 4 - S % 4 : S,
            b = b >> 1 || 1,
            m = m >> 1 || 1,
            x = b + 4 - 1 & -4,
            v = m + 4 - 1 & -4,
            f = x * v * t
        }
        return w
    }
    function uT(i, e, t) {
        let r = $e.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[t];
        if (i !== 0 && ($e.TYPES_TO_BYTES_PER_COMPONENT[i] ? r = $e.TYPES_TO_BYTES_PER_COMPONENT[i] * $e.FORMATS_TO_COMPONENTS[e] : r = $e.TYPES_TO_BYTES_PER_PIXEL[i]),
        r === void 0)
            throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
        return r
    }
    function dT(i) {
        let e = i.getUint32($e.FIELDS.ENDIANNESS, !0) === $e.ENDIANNESS
          , t = i.getUint32($e.FIELDS.GL_TYPE, e)
          , r = i.getUint32($e.FIELDS.GL_FORMAT, e)
          , s = i.getUint32($e.FIELDS.GL_INTERNAL_FORMAT, e)
          , n = i.getUint32($e.FIELDS.PIXEL_WIDTH, e)
          , a = i.getUint32($e.FIELDS.PIXEL_HEIGHT, e) || 1
          , o = i.getUint32($e.FIELDS.PIXEL_DEPTH, e) || 1
          , l = i.getUint32($e.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, e) || 1
          , u = i.getUint32($e.FIELDS.NUMBER_OF_FACES, e)
          , d = i.getUint32($e.FIELDS.NUMBER_OF_MIPMAP_LEVELS, e)
          , f = i.getUint32($e.FIELDS.BYTES_OF_KEY_VALUE_DATA, e);
        if (a === 0 || o !== 1)
            throw new Error("Only 2D textures are supported");
        if (u !== 1)
            throw new Error("CubeTextures are not supported by KTXLoader yet!");
        if (l !== 1)
            throw new Error("WebGL does not support array textures");
        return {
            littleEndian: e,
            glType: t,
            glFormat: r,
            glInternalFormat: s,
            pixelWidth: n,
            pixelHeight: a,
            numberOfMipmapLevels: d,
            offset: $e.FILE_HEADER_SIZE + f
        }
    }
    function fT(i) {
        for (let e = 0; e < $e.FILE_IDENTIFIER.length; e++)
            if (i.getUint8(e) !== $e.FILE_IDENTIFIER[e])
                return !1;
        return !0
    }
    var Sw = {
        extension: {
            type: O.LoadParser,
            priority: Xt.High,
            name: "loadKTX"
        },
        name: "loadKTX",
        id: "ktx",
        test(i) {
            return Kt(i, ".ktx")
        },
        async load(i, e, t) {
            let r = await yo()
              , s = await (await fetch(i)).arrayBuffer()
              , n = lT(s, r)
              , a = new Er(n);
            return Qi(a, t, i)
        },
        unload(i) {
            Array.isArray(i) ? i.forEach(e => e.destroy(!0)) : i.destroy(!0)
        }
    }
      , pT = '(function(){"use strict";const s={rgb8unorm:{convertedFormat:"rgba8unorm",convertFunction:i},"rgb8unorm-srgb":{convertedFormat:"rgba8unorm-srgb",convertFunction:i}};function f(r){const t=r.format;if(s[t]){const n=s[t].convertFunction,o=r.resource;for(let e=0;e<o.length;e++)o[e]=n(o[e]);r.format=s[t].convertedFormat}}function i(r){const t=r.byteLength/3,n=new Uint32Array(t);for(let o=0;o<t;++o)n[o]=r[o*3]+(r[o*3+1]<<8)+(r[o*3+2]<<16)+4278190080;return new Uint8Array(n.buffer)}function d(r){const t=[];for(let n=0;n<r.numLevels;n++){const o=r.getImageData(n,0,0),e=new Uint8Array(o.byteLength);e.set(o),t.push(e)}return t}const w={6408:"rgba8unorm",32856:"bgra8unorm",32857:"rgb10a2unorm",33189:"depth16unorm",33190:"depth24plus",33321:"r8unorm",33323:"rg8unorm",33325:"r16float",33326:"r32float",33327:"rg16float",33328:"rg32float",33329:"r8sint",33330:"r8uint",33331:"r16sint",33332:"r16uint",33333:"r32sint",33334:"r32uint",33335:"rg8sint",33336:"rg8uint",33337:"rg16sint",33338:"rg16uint",33339:"rg32sint",33340:"rg32uint",33778:"bc2-rgba-unorm",33779:"bc3-rgba-unorm",34836:"rgba32float",34842:"rgba16float",35056:"depth24plus-stencil8",35898:"rg11b10ufloat",35901:"rgb9e5ufloat",35907:"rgba8unorm-srgb",36012:"depth32float",36013:"depth32float-stencil8",36168:"stencil8",36208:"rgba32uint",36214:"rgba16uint",36220:"rgba8uint",36226:"rgba32sint",36232:"rgba16sint",36238:"rgba8sint",36492:"bc7-rgba-unorm",36756:"r8snorm",36757:"rg8snorm",36759:"rgba8snorm",37496:"etc2-rgba8unorm",37808:"astc-4x4-unorm"};function p(r){const t=w[r];if(t)return t;throw new Error(`Unsupported glInternalFormat: ${r}`)}const h={23:"rgb8unorm",37:"rgba8unorm",43:"rgba8unorm-srgb"};function F(r){const t=h[r];if(t)return t;throw new Error(`Unsupported VkFormat: ${r}`)}function U(r){return r.classId===2?F(r.vkFormat):p(r.glInternalformat)}const T={"bc3-rgba-unorm":"BC3_RGBA","bc7-rgba-unorm":"BC7_M5_RGBA","etc2-rgba8unorm":"ETC2_RGBA","astc-4x4-unorm":"ASTC_4x4_RGBA",rgba8unorm:"RGBA32",rg11b10ufloat:"R11F_G11F_B10F"};function y(r){const t=T[r];if(t)return t;throw new Error(`Unsupported transcoderFormat: ${r}`)}const a={jsUrl:"",wasmUrl:""};let l,u,c;async function g(){if(!c){const r=new URL(a.jsUrl,location.origin).href,t=new URL(a.wasmUrl,location.origin).href;importScripts(r),c=new Promise(n=>{LIBKTX({locateFile:o=>t}).then(o=>{n(o)})})}return c}async function v(r,t){const n=await fetch(r);if(n.ok){const o=await n.arrayBuffer();return new t.ktxTexture(new Uint8Array(o))}throw new Error(`Failed to load KTX(2) texture: ${r}`)}const x=["bc7-rgba-unorm","astc-4x4-unorm","etc2-rgba8unorm","bc3-rgba-unorm","rgba8unorm"];async function B(r){const t=await g(),n=await v(r,t);let o;if(n.needsTranscoding){o=u;const R=t.TranscodeTarget[l];if(n.transcodeBasis(R,0)!==t.ErrorCode.SUCCESS)throw new Error("Unable to transcode basis texture.")}else o=U(n);const e=d(n),b={width:n.baseWidth,height:n.baseHeight,format:o,mipLevelCount:n.numLevels,resource:e,alphaMode:"no-premultiply-alpha"};return f(b),b}async function A(r,t,n){r&&(a.jsUrl=r),t&&(a.wasmUrl=t),u=x.filter(o=>n.includes(o))[0],l=y(u),await g()}const m={init:async r=>{const{jsUrl:t,wasmUrl:n,supportedTextures:o}=r;await A(t,n,o)},load:async r=>{var t;try{const n=await B(r.url);return{type:"load",url:r.url,success:!0,textureOptions:n,transferables:(t=n.resource)==null?void 0:t.map(o=>o.buffer)}}catch(n){throw n}}};self.onmessage=async r=>{var t;const n=r.data,o=await((t=m[n.type])==null?void 0:t.call(m,n));o&&self.postMessage(o,o.transferables)}})();\n'
      , _r = null
      , oa = class {
        constructor() {
            _r || (_r = URL.createObjectURL(new Blob([pT],{
                type: "application/javascript"
            }))),
            this.worker = new Worker(_r)
        }
    }
    ;
    oa.revokeObjectURL = function() {
        _r && (URL.revokeObjectURL(_r),
        _r = null)
    }
    ;
    var lp = {
        jsUrl: "https://files.pixijs.download/transcoders/ktx/libktx.js",
        wasmUrl: "https://files.pixijs.download/transcoders/ktx/libktx.wasm"
    };
    var Vr, vm = {};
    function bT(i) {
        return Vr || (Vr = new oa().worker,
        Vr.onmessage = e => {
            let {success: t, url: r, textureOptions: s} = e.data;
            vm[r](s)
        }
        ,
        Vr.postMessage({
            type: "init",
            jsUrl: lp.jsUrl,
            wasmUrl: lp.wasmUrl,
            supportedTextures: i
        })),
        Vr
    }
    function mT(i, e) {
        let t = bT(e);
        return new Promise(r => {
            vm[i] = r,
            t.postMessage({
                type: "load",
                url: i
            })
        }
        )
    }
    var ww = {
        extension: {
            type: O.LoadParser,
            priority: Xt.High,
            name: "loadKTX2"
        },
        name: "loadKTX2",
        id: "ktx2",
        test(i) {
            return Kt(i, ".ktx2")
        },
        async load(i, e, t) {
            let r = await yo()
              , s = await mT(i, r)
              , n = new Er(s);
            return Qi(n, t, i)
        },
        async unload(i) {
            Array.isArray(i) ? i.forEach(e => e.destroy(!0)) : i.destroy(!0)
        }
    };
    var kl = ["basis", "bc7", "bc6h", "astc", "etc2", "bc5", "bc4", "bc3", "bc2", "bc1", "eac"], Aw = {
        extension: O.ResolveParser,
        test: i => Kt(i, [".ktx", ".ktx2", ".dds"]),
        parse: i => {
            var e, t;
            let r, s = i.split(".");
            if (s.length > 2) {
                let n = s[s.length - 2];
                kl.includes(n) && (r = n)
            } else
                r = s[s.length - 1];
            return {
                resolution: parseFloat((t = (e = bi.RETINA_PREFIX.exec(i)) == null ? void 0 : e[1]) != null ? t : "1"),
                format: r,
                src: i
            }
        }
    }, tn, Ew = {
        extension: {
            type: O.DetectionParser,
            priority: 2
        },
        test: async () => !!(await go() || mo()),
        add: async i => {
            let e = await mm();
            return tn = gT(e),
            [...tn, ...i]
        }
        ,
        remove: async i => tn ? i.filter(e => !(e in tn)) : i
    };
    function gT(i) {
        let e = ["basis"]
          , t = {};
        return i.forEach(r => {
            let s = r.split("-")[0];
            s && !t[s] && (t[s] = !0,
            e.push(s))
        }
        ),
        e.sort( (r, s) => {
            let n = kl.indexOf(r)
              , a = kl.indexOf(s);
            return n === -1 ? 1 : a === -1 ? -1 : n - a
        }
        ),
        e
    }
    var _T = new at
      , Ul = class {
        cull(i, e, t=!0) {
            this._cullRecursive(i, e, t)
        }
        _cullRecursive(i, e, t=!0) {
            var r;
            if (i.cullable && i.measurable && i.includeInBuild) {
                let s = (r = i.cullArea) != null ? r : fo(i, t, _T);
                i.culled = s.x >= e.x + e.width || s.y >= e.y + e.height || s.x + s.width <= e.x || s.y + s.height <= e.y
            } else
                i.culled = !1;
            if (!(!i.cullableChildren || i.culled || !i.renderable || !i.measurable || !i.includeInBuild))
                for (let s = 0; s < i.children.length; s++)
                    this._cullRecursive(i.children[s], e, t)
        }
    }
    ;
    Ul.shared = new Ul;
    var xT = Ul
      , Ll = class {
        static init(e) {
            this._renderRef = this.render.bind(this),
            this.render = () => {
                var t;
                let r = ((t = e?.culler) == null ? void 0 : t.updateTransform) !== !0;
                xT.shared.cull(this.stage, this.renderer.screen, r),
                this.renderer.render({
                    container: this.stage
                })
            }
        }
        static destroy() {
            this.render = this._renderRef
        }
    }
    ;
    Ll.extension = {
        priority: 10,
        type: O.Application,
        name: "culler"
    };
    var Pw = {
        extension: {
            type: O.Environment,
            name: "browser",
            priority: -1
        },
        test: () => !0,
        load: async () => {
            await Promise.resolve().then(function() {
                return g3
            })
        }
    }
      , yT = Object.defineProperty
      , ca = Object.getOwnPropertySymbols
      , Tm = Object.prototype.hasOwnProperty
      , Sm = Object.prototype.propertyIsEnumerable
      , hp = (i, e, t) => e in i ? yT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , _c = (i, e) => {
        for (var t in e || (e = {}))
            Tm.call(e, t) && hp(i, t, e[t]);
        if (ca)
            for (var t of ca(e))
                Sm.call(e, t) && hp(i, t, e[t]);
        return i
    }
      , vT = (i, e) => {
        var t = {};
        for (var r in i)
            Tm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ca)
            for (var r of ca(i))
                e.indexOf(r) < 0 && Sm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , wm = class Nl extends vt {
        constructor(e) {
            e = _c(_c({}, Nl.defaultOptions), e),
            super(e),
            this.enabled = !0,
            this._state = Ut.for2d(),
            this.blendMode = e.blendMode,
            this.padding = e.padding,
            typeof e.antialias == "boolean" ? this.antialias = e.antialias ? "on" : "off" : this.antialias = e.antialias,
            this.resolution = e.resolution,
            this.blendRequired = e.blendRequired,
            this.clipToViewport = e.clipToViewport,
            this.addResource("uTexture", 0, 1)
        }
        apply(e, t, r, s) {
            e.applyFilter(this, t, r, s)
        }
        get blendMode() {
            return this._state.blendMode
        }
        set blendMode(e) {
            this._state.blendMode = e
        }
        static from(e) {
            let t = e, {gpu: r, gl: s} = t, n = vT(t, ["gpu", "gl"]), a, o;
            return r && (a = ni.from(r)),
            s && (o = yi.from(s)),
            new Nl(_c({
                gpuProgram: a,
                glProgram: o
            }, n))
        }
    }
    ;
    wm.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: !1,
        clipToViewport: !0
    };
    var Gs = wm;
    var Am = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`
      , TT = `
in vec2 vTextureCoord;

out vec4 finalColor;

uniform float uAlpha;
uniform sampler2D uTexture;

void main()
{
    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;
}
`
      , up = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uTexture, uSampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`
      , ST = Object.defineProperty
      , wT = Object.defineProperties
      , AT = Object.getOwnPropertyDescriptors
      , la = Object.getOwnPropertySymbols
      , Em = Object.prototype.hasOwnProperty
      , Pm = Object.prototype.propertyIsEnumerable
      , dp = (i, e, t) => e in i ? ST(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , xc = (i, e) => {
        for (var t in e || (e = {}))
            Em.call(e, t) && dp(i, t, e[t]);
        if (la)
            for (var t of la(e))
                Pm.call(e, t) && dp(i, t, e[t]);
        return i
    }
      , ET = (i, e) => wT(i, AT(e))
      , PT = (i, e) => {
        var t = {};
        for (var r in i)
            Em.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && la)
            for (var r of la(i))
                e.indexOf(r) < 0 && Pm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , RT = class Rm extends Gs {
        constructor(e) {
            e = xc(xc({}, Rm.defaultOptions), e);
            let t = ni.from({
                vertex: {
                    source: up,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: up,
                    entryPoint: "mainFragment"
                }
            })
              , r = yi.from({
                vertex: Am,
                fragment: TT,
                name: "alpha-filter"
            })
              , s = e
              , {alpha: n} = s
              , a = PT(s, ["alpha"])
              , o = new ot({
                uAlpha: {
                    value: n,
                    type: "f32"
                }
            });
            super(ET(xc({}, a), {
                gpuProgram: t,
                glProgram: r,
                resources: {
                    alphaUniforms: o
                }
            }))
        }
        get alpha() {
            return this.resources.alphaUniforms.uniforms.uAlpha
        }
        set alpha(e) {
            this.resources.alphaUniforms.uniforms.uAlpha = e
        }
    }
    ;
    RT.defaultOptions = {
        alpha: 1
    };
    var Mm = {
        5: [.153388, .221461, .250301],
        7: [.071303, .131514, .189879, .214607],
        9: [.028532, .067234, .124009, .179044, .20236],
        11: [.0093, .028002, .065984, .121703, .175713, .198596],
        13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
        15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
    }
      , MT = ["in vec2 vBlurTexCoords[%size%];", "uniform sampler2D uTexture;", "out vec4 finalColor;", "void main(void)", "{", "    finalColor = vec4(0.0);", "    %blur%", "}"].join(`
`);
    function CT(i) {
        let e = Mm[i], t = e.length, r = MT, s = "", n = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;", a;
        for (let o = 0; o < i; o++) {
            let l = n.replace("%index%", o.toString());
            a = o,
            o >= t && (a = i - o - 1),
            l = l.replace("%value%", e[a].toString()),
            s += l,
            s += `
`
        }
        return r = r.replace("%blur%", s),
        r = r.replace("%size%", i.toString()),
        r
    }
    var OT = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
    function IT(i, e) {
        let t = Math.ceil(i / 2), r = OT, s = "", n;
        e ? n = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : n = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
        for (let a = 0; a < i; a++) {
            let o = n.replace("%index%", a.toString());
            o = o.replace("%sampleIndex%", `${a - (t - 1)}.0`),
            s += o,
            s += `
`
        }
        return r = r.replace("%blur%", s),
        r = r.replace("%size%", i.toString()),
        r = r.replace("%dimension%", e ? "z" : "w"),
        r
    }
    function GT(i, e) {
        let t = IT(e, i)
          , r = CT(e);
        return yi.from({
            vertex: t,
            fragment: r,
            name: `blur-${i ? "horizontal" : "vertical"}-pass-filter`
        })
    }
    var BT = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;
    function FT(i, e) {
        let t = Mm[e]
          , r = t.length
          , s = []
          , n = []
          , a = [];
        for (let f = 0; f < e; f++) {
            s[f] = `@location(${f}) offset${f}: vec2<f32>,`,
            i ? n[f] = `filteredCord + vec2(${f - r + 1} * pixelStrength, 0.0),` : n[f] = `filteredCord + vec2(0.0, ${f - r + 1} * pixelStrength),`;
            let b = f < r ? f : e - f - 1
              , m = t[b].toString();
            a[f] = `finalColor += textureSample(uTexture, uSampler, offset${f}) * ${m};`
        }
        let o = s.join(`
`)
          , l = n.join(`
`)
          , u = a.join(`
`)
          , d = BT.replace("%blur-struct%", o).replace("%blur-vertex-out%", l).replace("%blur-fragment-in%", o).replace("%blur-sampling%", u).replace("%dimension%", i ? "z" : "w");
        return ni.from({
            vertex: {
                source: d,
                entryPoint: "mainVertex"
            },
            fragment: {
                source: d,
                entryPoint: "mainFragment"
            }
        })
    }
    var DT = Object.defineProperty
      , fp = Object.getOwnPropertySymbols
      , kT = Object.prototype.hasOwnProperty
      , UT = Object.prototype.propertyIsEnumerable
      , pp = (i, e, t) => e in i ? DT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , yc = (i, e) => {
        for (var t in e || (e = {}))
            kT.call(e, t) && pp(i, t, e[t]);
        if (fp)
            for (var t of fp(e))
                UT.call(e, t) && pp(i, t, e[t]);
        return i
    }
      , Cm = class Om extends Gs {
        constructor(e) {
            e = yc(yc({}, Om.defaultOptions), e);
            let t = GT(e.horizontal, e.kernelSize)
              , r = FT(e.horizontal, e.kernelSize);
            super(yc({
                glProgram: t,
                gpuProgram: r,
                resources: {
                    blurUniforms: {
                        uStrength: {
                            value: 0,
                            type: "f32"
                        }
                    }
                }
            }, e)),
            this.horizontal = e.horizontal,
            this._quality = 0,
            this.quality = e.quality,
            this.blur = e.strength,
            this._uniforms = this.resources.blurUniforms.uniforms
        }
        apply(e, t, r, s) {
            if (this._uniforms.uStrength = this.strength / this.passes,
            this.passes === 1)
                e.applyFilter(this, t, r, s);
            else {
                let n = Ke.getSameSizeTexture(t)
                  , a = t
                  , o = n;
                this._state.blend = !1;
                let l = e.renderer.type === Ct.WEBGPU;
                for (let u = 0; u < this.passes - 1; u++) {
                    e.applyFilter(this, a, o, u === 0 ? !0 : l);
                    let d = o;
                    o = a,
                    a = d
                }
                this._state.blend = !0,
                e.applyFilter(this, a, r, s),
                Ke.returnTexture(n)
            }
        }
        get blur() {
            return this.strength
        }
        set blur(e) {
            this.padding = 1 + Math.abs(e) * 2,
            this.strength = e
        }
        get quality() {
            return this._quality
        }
        set quality(e) {
            this._quality = e,
            this.passes = e
        }
    }
    ;
    Cm.defaultOptions = {
        strength: 8,
        quality: 4,
        kernelSize: 5
    };
    var vc = Cm
      , LT = Object.defineProperty
      , NT = Object.defineProperties
      , XT = Object.getOwnPropertyDescriptors
      , ha = Object.getOwnPropertySymbols
      , Im = Object.prototype.hasOwnProperty
      , Gm = Object.prototype.propertyIsEnumerable
      , bp = (i, e, t) => e in i ? LT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Wr = (i, e) => {
        for (var t in e || (e = {}))
            Im.call(e, t) && bp(i, t, e[t]);
        if (ha)
            for (var t of ha(e))
                Gm.call(e, t) && bp(i, t, e[t]);
        return i
    }
      , jT = (i, e) => NT(i, XT(e))
      , HT = (i, e) => {
        var t = {};
        for (var r in i)
            Im.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ha)
            for (var r of ha(i))
                e.indexOf(r) < 0 && Gm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Xl = class extends Gs {
        constructor(...e) {
            var t;
            let r = (t = e[0]) != null ? t : {};
            typeof r == "number" && (r = {
                strength: r
            },
            e[1] !== void 0 && (r.quality = e[1]),
            e[2] !== void 0 && (r.resolution = e[2] || "inherit"),
            e[3] !== void 0 && (r.kernelSize = e[3])),
            r = Wr(Wr({}, vc.defaultOptions), r);
            let s = r
              , {strength: n, strengthX: a, strengthY: o, quality: l} = s
              , u = HT(s, ["strength", "strengthX", "strengthY", "quality"]);
            super(jT(Wr({}, u), {
                compatibleRenderers: Ct.BOTH,
                resources: {}
            })),
            this._repeatEdgePixels = !1,
            this.blurXFilter = new vc(Wr({
                horizontal: !0
            }, r)),
            this.blurYFilter = new vc(Wr({
                horizontal: !1
            }, r)),
            this.quality = l,
            this.strengthX = a ?? n,
            this.strengthY = o ?? n,
            this.repeatEdgePixels = !1
        }
        apply(e, t, r, s) {
            let n = Math.abs(this.blurXFilter.strength)
              , a = Math.abs(this.blurYFilter.strength);
            if (n && a) {
                let o = Ke.getSameSizeTexture(t);
                this.blurXFilter.blendMode = "normal",
                this.blurXFilter.apply(e, t, o, !0),
                this.blurYFilter.blendMode = this.blendMode,
                this.blurYFilter.apply(e, o, r, s),
                Ke.returnTexture(o)
            } else
                a ? (this.blurYFilter.blendMode = this.blendMode,
                this.blurYFilter.apply(e, t, r, s)) : (this.blurXFilter.blendMode = this.blendMode,
                this.blurXFilter.apply(e, t, r, s))
        }
        updatePadding() {
            this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2
        }
        get strength() {
            if (this.strengthX !== this.strengthY)
                throw new Error("BlurFilter's strengthX and strengthY are different");
            return this.strengthX
        }
        set strength(e) {
            this.blurXFilter.blur = this.blurYFilter.blur = e,
            this.updatePadding()
        }
        get quality() {
            return this.blurXFilter.quality
        }
        set quality(e) {
            this.blurXFilter.quality = this.blurYFilter.quality = e
        }
        get strengthX() {
            return this.blurXFilter.blur
        }
        set strengthX(e) {
            this.blurXFilter.blur = e,
            this.updatePadding()
        }
        get strengthY() {
            return this.blurYFilter.blur
        }
        set strengthY(e) {
            this.blurYFilter.blur = e,
            this.updatePadding()
        }
        get blur() {
            return this.strength
        }
        set blur(e) {
            this.strength = e
        }
        get blurX() {
            return this.strengthX
        }
        set blurX(e) {
            this.strengthX = e
        }
        get blurY() {
            return this.strengthY
        }
        set blurY(e) {
            this.strengthY = e
        }
        get repeatEdgePixels() {
            return this._repeatEdgePixels
        }
        set repeatEdgePixels(e) {
            this._repeatEdgePixels = e,
            this.updatePadding()
        }
    }
    ;
    Xl.defaultOptions = {
        strength: 8,
        quality: 4,
        kernelSize: 5
    };
    var zT = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) *  uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    finalColor = color;
}
`
      , mp = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct NoiseUniforms {
  uNoise:f32,
  uSeed:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

fn rand(co:vec2<f32>) -> f32
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}



@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);
  
    
    var sample = textureSample(uTexture, uSampler, uv);
    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);
    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;
  
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (sample.a > 0.0) {
      sample.r /= sample.a;
      sample.g /= sample.a;
      sample.b /= sample.a;
    }

    sample.r += diff;
    sample.g += diff;
    sample.b += diff;

    // Premultiply alpha again.
    sample.r *= sample.a;
    sample.g *= sample.a;
    sample.b *= sample.a;
    
    return sample;
}`
      , VT = Object.defineProperty
      , WT = Object.defineProperties
      , YT = Object.getOwnPropertyDescriptors
      , ua = Object.getOwnPropertySymbols
      , Bm = Object.prototype.hasOwnProperty
      , Fm = Object.prototype.propertyIsEnumerable
      , gp = (i, e, t) => e in i ? VT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Tc = (i, e) => {
        for (var t in e || (e = {}))
            Bm.call(e, t) && gp(i, t, e[t]);
        if (ua)
            for (var t of ua(e))
                Fm.call(e, t) && gp(i, t, e[t]);
        return i
    }
      , $T = (i, e) => WT(i, YT(e))
      , KT = (i, e) => {
        var t = {};
        for (var r in i)
            Bm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ua)
            for (var r of ua(i))
                e.indexOf(r) < 0 && Fm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , qT = class Dm extends Gs {
        constructor(e={}) {
            e = Tc(Tc({}, Dm.defaultOptions), e);
            let t = ni.from({
                vertex: {
                    source: mp,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: mp,
                    entryPoint: "mainFragment"
                }
            })
              , r = yi.from({
                vertex: Am,
                fragment: zT,
                name: "noise-filter"
            })
              , s = e
              , {noise: n, seed: a} = s
              , o = KT(s, ["noise", "seed"]);
            super($T(Tc({}, o), {
                gpuProgram: t,
                glProgram: r,
                resources: {
                    noiseUniforms: new ot({
                        uNoise: {
                            value: 1,
                            type: "f32"
                        },
                        uSeed: {
                            value: 1,
                            type: "f32"
                        }
                    })
                }
            })),
            this.noise = n,
            this.seed = a ?? Math.random()
        }
        get noise() {
            return this.resources.noiseUniforms.uniforms.uNoise
        }
        set noise(e) {
            this.resources.noiseUniforms.uniforms.uNoise = e
        }
        get seed() {
            return this.resources.noiseUniforms.uniforms.uSeed
        }
        set seed(e) {
            this.resources.noiseUniforms.uniforms.uSeed = e
        }
    }
    ;
    qT.defaultOptions = {
        noise: .5
    };
    var ZT = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`
      , QT = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`
      , _p = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`
      , JT = Object.defineProperty
      , e5 = Object.defineProperties
      , t5 = Object.getOwnPropertyDescriptors
      , da = Object.getOwnPropertySymbols
      , km = Object.prototype.hasOwnProperty
      , Um = Object.prototype.propertyIsEnumerable
      , xp = (i, e, t) => e in i ? JT(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , i5 = (i, e) => {
        for (var t in e || (e = {}))
            km.call(e, t) && xp(i, t, e[t]);
        if (da)
            for (var t of da(e))
                Um.call(e, t) && xp(i, t, e[t]);
        return i
    }
      , r5 = (i, e) => e5(i, t5(e))
      , s5 = (i, e) => {
        var t = {};
        for (var r in i)
            km.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && da)
            for (var r of da(i))
                e.indexOf(r) < 0 && Um.call(i, r) && (t[r] = i[r]);
        return t
    }
      , jl = class extends Gs {
        constructor(e) {
            let t = e
              , {sprite: r} = t
              , s = s5(t, ["sprite"])
              , n = new gn(r.texture)
              , a = new ot({
                uFilterMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uMaskClamp: {
                    value: n.uClampFrame,
                    type: "vec4<f32>"
                },
                uAlpha: {
                    value: 1,
                    type: "f32"
                },
                uInverse: {
                    value: e.inverse ? 1 : 0,
                    type: "f32"
                }
            })
              , o = ni.from({
                vertex: {
                    source: _p,
                    entryPoint: "mainVertex"
                },
                fragment: {
                    source: _p,
                    entryPoint: "mainFragment"
                }
            })
              , l = yi.from({
                vertex: QT,
                fragment: ZT,
                name: "mask-filter"
            });
            super(r5(i5({}, s), {
                gpuProgram: o,
                glProgram: l,
                clipToViewport: !1,
                resources: {
                    filterUniforms: a,
                    uMaskTexture: r.texture.source
                }
            })),
            this.sprite = r,
            this._textureMatrix = n
        }
        set inverse(e) {
            this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0
        }
        get inverse() {
            return this.resources.filterUniforms.uniforms.uInverse === 1
        }
        apply(e, t, r, s) {
            this._textureMatrix.texture = this.sprite.texture,
            e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord),
            this.resources.uMaskTexture = this.sprite.texture.source,
            e.applyFilter(this, t, r, s)
        }
    }
    ;
    var Lm = class Nm {
        constructor(e) {
            this._tick = () => {
                this.timeout = setTimeout(this._processQueue, 0)
            }
            ,
            this._processQueue = () => {
                let {queue: t} = this
                  , r = 0;
                for (; t.length && r < Nm.uploadsPerFrame; ) {
                    let s = t.shift();
                    this.uploadQueueItem(s),
                    r++
                }
                t.length ? nt.system.addOnce(this._tick, this, fi.UTILITY) : this._resolve()
            }
            ,
            this.renderer = e,
            this.queue = [],
            this.resolves = []
        }
        getQueue() {
            return [...this.queue]
        }
        add(e) {
            let t = Array.isArray(e) ? e : [e];
            for (let r of t)
                r instanceof Te ? this._addContainer(r) : this.resolveQueueItem(r, this.queue);
            return this
        }
        _addContainer(e) {
            this.resolveQueueItem(e, this.queue);
            for (let t of e.children)
                this._addContainer(t)
        }
        upload(e) {
            return e && this.add(e),
            new Promise(t => {
                this.queue.length ? (this.resolves.push(t),
                this.dedupeQueue(),
                nt.system.addOnce(this._tick, this, fi.UTILITY)) : t()
            }
            )
        }
        dedupeQueue() {
            let e = Object.create(null)
              , t = 0;
            for (let r = 0; r < this.queue.length; r++) {
                let s = this.queue[r];
                e[s.uid] || (e[s.uid] = !0,
                this.queue[t++] = s)
            }
            this.queue.length = t
        }
        _resolve() {
            let {resolves: e} = this
              , t = e.slice(0);
            e.length = 0;
            for (let r of t)
                r()
        }
    }
    ;
    Lm.uploadsPerFrame = 4;
    var n5 = Lm
      , a5 = Object.defineProperty
      , fa = Object.getOwnPropertySymbols
      , Xm = Object.prototype.hasOwnProperty
      , jm = Object.prototype.propertyIsEnumerable
      , yp = (i, e, t) => e in i ? a5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , o5 = (i, e) => {
        for (var t in e || (e = {}))
            Xm.call(e, t) && yp(i, t, e[t]);
        if (fa)
            for (var t of fa(e))
                jm.call(e, t) && yp(i, t, e[t]);
        return i
    }
      , c5 = (i, e) => {
        var t = {};
        for (var r in i)
            Xm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && fa)
            for (var r of fa(i))
                e.indexOf(r) < 0 && jm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Zi = class extends pi {
        constructor(...e) {
            var t;
            let r = e[0];
            r instanceof si && (r = {
                geometry: r,
                shader: e[1]
            },
            e[3] && (r.geometry.topology = e[3]));
            let s = r
              , {geometry: n, shader: a, texture: o, roundPixels: l, state: u} = s
              , d = c5(s, ["geometry", "shader", "texture", "roundPixels", "state"]);
            super(o5({
                label: "Mesh"
            }, d)),
            this.renderPipeId = "mesh",
            this._shader = null,
            this.allowChildren = !1,
            this.shader = a ?? null,
            this.texture = (t = o ?? a?.texture) != null ? t : Z.WHITE,
            this.state = u ?? Ut.for2d(),
            this._geometry = n,
            this._geometry.on("update", this.onViewUpdate, this),
            this.roundPixels = l ?? !1
        }
        get material() {
            return this._shader
        }
        set shader(e) {
            this._shader !== e && (this._shader = e,
            this.onViewUpdate())
        }
        get shader() {
            return this._shader
        }
        set geometry(e) {
            var t;
            this._geometry !== e && ((t = this._geometry) == null || t.off("update", this.onViewUpdate, this),
            e.on("update", this.onViewUpdate, this),
            this._geometry = e,
            this.onViewUpdate())
        }
        get geometry() {
            return this._geometry
        }
        set texture(e) {
            e || (e = Z.EMPTY);
            let t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            this.shader && (this.shader.texture = e),
            this._texture = e,
            this.onViewUpdate())
        }
        get texture() {
            return this._texture
        }
        get batched() {
            return this._shader || this.state.data & 12 ? !1 : this._geometry instanceof Is ? this._geometry.batchMode === "auto" ? this._geometry.positions.length / 2 <= 100 : this._geometry.batchMode === "batch" : !1
        }
        get bounds() {
            return this._geometry.bounds
        }
        updateBounds() {
            this._bounds = this._geometry.bounds
        }
        containsPoint(e) {
            let {x: t, y: r} = e;
            if (!this.bounds.containsPoint(t, r))
                return !1;
            let s = this.geometry.getBuffer("aPosition").data
              , n = this.geometry.topology === "triangle-strip" ? 3 : 1;
            if (this.geometry.getIndex()) {
                let a = this.geometry.getIndex().data
                  , o = a.length;
                for (let l = 0; l + 2 < o; l += n) {
                    let u = a[l] * 2
                      , d = a[l + 1] * 2
                      , f = a[l + 2] * 2;
                    if (Df(t, r, s[u], s[u + 1], s[d], s[d + 1], s[f], s[f + 1]))
                        return !0
                }
            } else {
                let a = s.length / 2;
                for (let o = 0; o + 2 < a; o += n) {
                    let l = o * 2
                      , u = (o + 1) * 2
                      , d = (o + 2) * 2;
                    if (Df(t, r, s[l], s[l + 1], s[u], s[u + 1], s[d], s[d + 1]))
                        return !0
                }
            }
            return !1
        }
        destroy(e) {
            var t;
            if (super.destroy(e),
            typeof e == "boolean" ? e : e?.texture) {
                let r = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(r)
            }
            (t = this._geometry) == null || t.off("update", this.onViewUpdate, this),
            this._texture = null,
            this._geometry = null,
            this._shader = null,
            this._gpuData = null
        }
    }
      , l5 = Object.defineProperty
      , h5 = Object.defineProperties
      , u5 = Object.getOwnPropertyDescriptors
      , pa = Object.getOwnPropertySymbols
      , Hm = Object.prototype.hasOwnProperty
      , zm = Object.prototype.propertyIsEnumerable
      , vp = (i, e, t) => e in i ? l5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , d5 = (i, e) => {
        for (var t in e || (e = {}))
            Hm.call(e, t) && vp(i, t, e[t]);
        if (pa)
            for (var t of pa(e))
                zm.call(e, t) && vp(i, t, e[t]);
        return i
    }
      , f5 = (i, e) => h5(i, u5(e))
      , p5 = (i, e) => {
        var t = {};
        for (var r in i)
            Hm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && pa)
            for (var r of pa(i))
                e.indexOf(r) < 0 && zm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Hl = class i extends Fe {
        constructor(...e) {
            let t = e[0];
            Array.isArray(e[0]) && (t = {
                textures: e[0],
                autoUpdate: e[1]
            });
            let r = t
              , {animationSpeed: s=1, autoPlay: n=!1, autoUpdate: a=!0, loop: o=!0, onComplete: l=null, onFrameChange: u=null, onLoop: d=null, textures: f, updateAnchor: b=!1} = r
              , m = p5(r, ["animationSpeed", "autoPlay", "autoUpdate", "loop", "onComplete", "onFrameChange", "onLoop", "textures", "updateAnchor"])
              , [x] = f;
            super(f5(d5({}, m), {
                texture: x instanceof Z ? x : x.texture
            })),
            this._textures = null,
            this._durations = null,
            this._autoUpdate = a,
            this._isConnectedToTicker = !1,
            this.animationSpeed = s,
            this.loop = o,
            this.updateAnchor = b,
            this.onComplete = l,
            this.onFrameChange = u,
            this.onLoop = d,
            this._currentTime = 0,
            this._playing = !1,
            this._previousFrame = null,
            this.textures = f,
            n && this.play()
        }
        stop() {
            this._playing && (this._playing = !1,
            this._autoUpdate && this._isConnectedToTicker && (nt.shared.remove(this.update, this),
            this._isConnectedToTicker = !1))
        }
        play() {
            this._playing || (this._playing = !0,
            this._autoUpdate && !this._isConnectedToTicker && (nt.shared.add(this.update, this, fi.HIGH),
            this._isConnectedToTicker = !0))
        }
        gotoAndStop(e) {
            this.stop(),
            this.currentFrame = e
        }
        gotoAndPlay(e) {
            this.currentFrame = e,
            this.play()
        }
        update(e) {
            if (!this._playing)
                return;
            let t = e.deltaTime
              , r = this.animationSpeed * t
              , s = this.currentFrame;
            if (this._durations !== null) {
                let n = this._currentTime % 1 * this._durations[this.currentFrame];
                for (n += r / 60 * 1e3; n < 0; )
                    this._currentTime--,
                    n += this._durations[this.currentFrame];
                let a = Math.sign(this.animationSpeed * t);
                for (this._currentTime = Math.floor(this._currentTime); n >= this._durations[this.currentFrame]; )
                    n -= this._durations[this.currentFrame] * a,
                    this._currentTime += a;
                this._currentTime += n / this._durations[this.currentFrame]
            } else
                this._currentTime += r;
            this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0),
            this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1),
            this.onComplete && this.onComplete()) : s !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < s || this.animationSpeed < 0 && this.currentFrame > s) && this.onLoop(),
            this._updateTexture())
        }
        _updateTexture() {
            let e = this.currentFrame;
            this._previousFrame !== e && (this._previousFrame = e,
            this.texture = this._textures[e],
            this.updateAnchor && this.texture.defaultAnchor && this.anchor.copyFrom(this.texture.defaultAnchor),
            this.onFrameChange && this.onFrameChange(this.currentFrame))
        }
        destroy(e=!1) {
            if (typeof e == "boolean" ? e : e != null && e.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._textures.forEach(r => {
                    this.texture !== r && r.destroy(t)
                }
                )
            }
            this._textures = [],
            this._durations = null,
            this.stop(),
            super.destroy(e),
            this.onComplete = null,
            this.onFrameChange = null,
            this.onLoop = null
        }
        static fromFrames(e) {
            let t = [];
            for (let r = 0; r < e.length; ++r)
                t.push(Z.from(e[r]));
            return new i(t)
        }
        static fromImages(e) {
            let t = [];
            for (let r = 0; r < e.length; ++r)
                t.push(Z.from(e[r]));
            return new i(t)
        }
        get totalFrames() {
            return this._textures.length
        }
        get textures() {
            return this._textures
        }
        set textures(e) {
            if (e[0]instanceof Z)
                this._textures = e,
                this._durations = null;
            else {
                this._textures = [],
                this._durations = [];
                for (let t = 0; t < e.length; t++)
                    this._textures.push(e[t].texture),
                    this._durations.push(e[t].time)
            }
            this._previousFrame = null,
            this.gotoAndStop(0),
            this._updateTexture()
        }
        get currentFrame() {
            let e = Math.floor(this._currentTime) % this._textures.length;
            return e < 0 && (e += this._textures.length),
            e
        }
        set currentFrame(e) {
            if (e < 0 || e > this.totalFrames - 1)
                throw new Error(`[AnimatedSprite]: Invalid frame index value ${e}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
            let t = this.currentFrame;
            this._currentTime = e,
            t !== this.currentFrame && this._updateTexture()
        }
        get playing() {
            return this._playing
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(e) {
            e !== this._autoUpdate && (this._autoUpdate = e,
            !this._autoUpdate && this._isConnectedToTicker ? (nt.shared.remove(this.update, this),
            this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (nt.shared.add(this.update, this),
            this._isConnectedToTicker = !0))
        }
    }
      , zl = class {
        constructor({matrix: e, observer: t}={}) {
            this.dirty = !0,
            this._matrix = e ?? new ce,
            this.observer = t,
            this.position = new ze(this,0,0),
            this.scale = new ze(this,1,1),
            this.pivot = new ze(this,0,0),
            this.skew = new ze(this,0,0),
            this._rotation = 0,
            this._cx = 1,
            this._sx = 0,
            this._cy = 0,
            this._sy = 1
        }
        get matrix() {
            let e = this._matrix;
            return this.dirty && (e.a = this._cx * this.scale.x,
            e.b = this._sx * this.scale.x,
            e.c = this._cy * this.scale.y,
            e.d = this._sy * this.scale.y,
            e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c),
            e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d),
            this.dirty = !1),
            e
        }
        _onUpdate(e) {
            var t;
            this.dirty = !0,
            e === this.skew && this.updateSkew(),
            (t = this.observer) == null || t._onUpdate(this)
        }
        updateSkew() {
            this._cx = Math.cos(this._rotation + this.skew.y),
            this._sx = Math.sin(this._rotation + this.skew.y),
            this._cy = -Math.sin(this._rotation - this.skew.x),
            this._sy = Math.cos(this._rotation - this.skew.x),
            this.dirty = !0
        }
        setFromMatrix(e) {
            e.decompose(this),
            this.dirty = !0
        }
        get rotation() {
            return this._rotation
        }
        set rotation(e) {
            this._rotation !== e && (this._rotation = e,
            this._onUpdate(this.skew))
        }
    }
      , b5 = Object.defineProperty
      , ba = Object.getOwnPropertySymbols
      , Vm = Object.prototype.hasOwnProperty
      , Wm = Object.prototype.propertyIsEnumerable
      , Tp = (i, e, t) => e in i ? b5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Yr = (i, e) => {
        for (var t in e || (e = {}))
            Vm.call(e, t) && Tp(i, t, e[t]);
        if (ba)
            for (var t of ba(e))
                Wm.call(e, t) && Tp(i, t, e[t]);
        return i
    }
      , m5 = (i, e) => {
        var t = {};
        for (var r in i)
            Vm.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ba)
            for (var r of ba(i))
                e.indexOf(r) < 0 && Wm.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Ym = class hn extends pi {
        constructor(...e) {
            let t = e[0] || {};
            t instanceof Z && (t = {
                texture: t
            }),
            e.length > 1 && (t.width = e[1],
            t.height = e[2]),
            t = Yr(Yr({}, hn.defaultOptions), t);
            let r = t ?? {}
              , {texture: s, anchor: n, tilePosition: a, tileScale: o, tileRotation: l, width: u, height: d, applyAnchorToTexture: f, roundPixels: b} = r
              , m = m5(r, ["texture", "anchor", "tilePosition", "tileScale", "tileRotation", "width", "height", "applyAnchorToTexture", "roundPixels"]);
            super(Yr({
                label: "TilingSprite"
            }, m)),
            this.renderPipeId = "tilingSprite",
            this.batched = !0,
            this.allowChildren = !1,
            this._anchor = new ze({
                _onUpdate: () => {
                    this.onViewUpdate()
                }
            }),
            this.applyAnchorToTexture = f,
            this.texture = s,
            this._width = u ?? s.width,
            this._height = d ?? s.height,
            this._tileTransform = new zl({
                observer: {
                    _onUpdate: () => this.onViewUpdate()
                }
            }),
            n && (this.anchor = n),
            this.tilePosition = a,
            this.tileScale = o,
            this.tileRotation = l,
            this.roundPixels = b ?? !1
        }
        static from(e, t={}) {
            return typeof e == "string" ? new hn(Yr({
                texture: Ge.get(e)
            }, t)) : new hn(Yr({
                texture: e
            }, t))
        }
        get uvRespectAnchor() {
            return Rn(td, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"),
            this.applyAnchorToTexture
        }
        set uvRespectAnchor(e) {
            Rn(td, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"),
            this.applyAnchorToTexture = e
        }
        get clampMargin() {
            return this._texture.textureMatrix.clampMargin
        }
        set clampMargin(e) {
            this._texture.textureMatrix.clampMargin = e
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get tilePosition() {
            return this._tileTransform.position
        }
        set tilePosition(e) {
            this._tileTransform.position.copyFrom(e)
        }
        get tileScale() {
            return this._tileTransform.scale
        }
        set tileScale(e) {
            typeof e == "number" ? this._tileTransform.scale.set(e) : this._tileTransform.scale.copyFrom(e)
        }
        set tileRotation(e) {
            this._tileTransform.rotation = e
        }
        get tileRotation() {
            return this._tileTransform.rotation
        }
        get tileTransform() {
            return this._tileTransform
        }
        set texture(e) {
            e || (e = Z.EMPTY);
            let t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            this._texture = e,
            this.onViewUpdate())
        }
        get texture() {
            return this._texture
        }
        set width(e) {
            this._width = e,
            this.onViewUpdate()
        }
        get width() {
            return this._width
        }
        set height(e) {
            this._height = e,
            this.onViewUpdate()
        }
        get height() {
            return this._height
        }
        setSize(e, t) {
            var r;
            typeof e == "object" && (t = (r = e.height) != null ? r : e.width,
            e = e.width),
            this._width = e,
            this._height = t ?? e,
            this.onViewUpdate()
        }
        getSize(e) {
            return e || (e = {}),
            e.width = this._width,
            e.height = this._height,
            e
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = this._width
              , s = this._height;
            e.minX = -t._x * r,
            e.maxX = e.minX + r,
            e.minY = -t._y * s,
            e.maxY = e.minY + s
        }
        containsPoint(e) {
            let t = this._width
              , r = this._height
              , s = -t * this._anchor._x
              , n = 0;
            return e.x >= s && e.x <= s + t && (n = -r * this._anchor._y,
            e.y >= n && e.y <= n + r)
        }
        destroy(e=!1) {
            if (super.destroy(e),
            this._anchor = null,
            this._tileTransform = null,
            this._bounds = null,
            typeof e == "boolean" ? e : e?.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(t)
            }
            this._texture = null
        }
    }
    ;
    Ym.defaultOptions = {
        texture: Z.EMPTY,
        anchor: {
            x: 0,
            y: 0
        },
        tilePosition: {
            x: 0,
            y: 0
        },
        tileScale: {
            x: 1,
            y: 1
        },
        tileRotation: 0,
        applyAnchorToTexture: !1
    };
    var g5 = Ym
      , _5 = Object.defineProperty
      , ma = Object.getOwnPropertySymbols
      , $m = Object.prototype.hasOwnProperty
      , Km = Object.prototype.propertyIsEnumerable
      , Sp = (i, e, t) => e in i ? _5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , x5 = (i, e) => {
        for (var t in e || (e = {}))
            $m.call(e, t) && Sp(i, t, e[t]);
        if (ma)
            for (var t of ma(e))
                Km.call(e, t) && Sp(i, t, e[t]);
        return i
    }
      , y5 = (i, e) => {
        var t = {};
        for (var r in i)
            $m.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ma)
            for (var r of ma(i))
                e.indexOf(r) < 0 && Km.call(i, r) && (t[r] = i[r]);
        return t
    }
      , Ss = class extends pi {
        constructor(e, t) {
            let r = e
              , {text: s, resolution: n, style: a, anchor: o, width: l, height: u, roundPixels: d} = r
              , f = y5(r, ["text", "resolution", "style", "anchor", "width", "height", "roundPixels"]);
            super(x5({}, f)),
            this.batched = !0,
            this._resolution = null,
            this._autoResolution = !0,
            this._didTextUpdate = !0,
            this._styleClass = t,
            this.text = s ?? "",
            this.style = a,
            this.resolution = n ?? null,
            this.allowChildren = !1,
            this._anchor = new ze({
                _onUpdate: () => {
                    this.onViewUpdate()
                }
            }),
            o && (this.anchor = o),
            this.roundPixels = d ?? !1,
            l !== void 0 && (this.width = l),
            u !== void 0 && (this.height = u)
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        set text(e) {
            e = e.toString(),
            this._text !== e && (this._text = e,
            this.onViewUpdate())
        }
        get text() {
            return this._text
        }
        set resolution(e) {
            this._autoResolution = e === null,
            this._resolution = e,
            this.onViewUpdate()
        }
        get resolution() {
            return this._resolution
        }
        get style() {
            return this._style
        }
        set style(e) {
            var t;
            e || (e = {}),
            (t = this._style) == null || t.off("update", this.onViewUpdate, this),
            e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e),
            this._style.on("update", this.onViewUpdate, this),
            this.onViewUpdate()
        }
        get width() {
            return Math.abs(this.scale.x) * this.bounds.width
        }
        set width(e) {
            this._setWidth(e, this.bounds.width)
        }
        get height() {
            return Math.abs(this.scale.y) * this.bounds.height
        }
        set height(e) {
            this._setHeight(e, this.bounds.height)
        }
        getSize(e) {
            return e || (e = {}),
            e.width = Math.abs(this.scale.x) * this.bounds.width,
            e.height = Math.abs(this.scale.y) * this.bounds.height,
            e
        }
        setSize(e, t) {
            var r;
            typeof e == "object" ? (t = (r = e.height) != null ? r : e.width,
            e = e.width) : t != null || (t = e),
            e !== void 0 && this._setWidth(e, this.bounds.width),
            t !== void 0 && this._setHeight(t, this.bounds.height)
        }
        containsPoint(e) {
            let t = this.bounds.width
              , r = this.bounds.height
              , s = -t * this.anchor.x
              , n = 0;
            return e.x >= s && e.x <= s + t && (n = -r * this.anchor.y,
            e.y >= n && e.y <= n + r)
        }
        onViewUpdate() {
            this.didViewUpdate || (this._didTextUpdate = !0),
            super.onViewUpdate()
        }
        destroy(e=!1) {
            super.destroy(e),
            this.owner = null,
            this._bounds = null,
            this._anchor = null,
            (typeof e == "boolean" ? e : e != null && e.style) && this._style.destroy(e),
            this._style = null,
            this._text = null
        }
        get styleKey() {
            return `${this._text}:${this._style.styleKey}:${this._resolution}`
        }
    }
    ;
    function Lh(i, e) {
        var t;
        let r = (t = i[0]) != null ? t : {};
        return (typeof r == "string" || i[1]) && (r = {
            text: r,
            style: i[1]
        }),
        r
    }
    var ke = class extends Ss {
        constructor(...e) {
            let t = Lh(e, "Text");
            super(t, Lt),
            this.renderPipeId = "text",
            t.textureStyle && (this.textureStyle = t.textureStyle instanceof kt ? t.textureStyle : new kt(t.textureStyle))
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = 0
              , s = 0;
            if (this._style.trim) {
                let {frame: n, canvasAndContext: a} = cs.getCanvasAndContext({
                    text: this.text,
                    style: this._style,
                    resolution: 1
                });
                cs.returnCanvasAndContext(a),
                r = n.width,
                s = n.height
            } else {
                let n = ft.measureText(this._text, this._style);
                r = n.width,
                s = n.height
            }
            e.minX = -t._x * r,
            e.maxX = e.minX + r,
            e.minY = -t._y * s,
            e.maxY = e.minY + s
        }
    }
      , Vl = class extends n5 {
        resolveQueueItem(e, t) {
            return e instanceof Te ? this.resolveContainerQueueItem(e, t) : e instanceof Xe || e instanceof Z ? t.push(e.source) : e instanceof yt && t.push(e),
            null
        }
        resolveContainerQueueItem(e, t) {
            e instanceof Fe || e instanceof g5 || e instanceof Zi ? t.push(e.texture.source) : e instanceof ke ? t.push(e) : e instanceof Ze ? t.push(e.context) : e instanceof Hl && e.textures.forEach(r => {
                r.source ? t.push(r.source) : t.push(r.texture.source)
            }
            )
        }
        resolveGraphicsContextQueueItem(e) {
            this.renderer.graphicsContext.getGpuContext(e);
            let {instructions: t} = e;
            for (let r of t)
                if (r.action === "texture") {
                    let {image: s} = r.data;
                    return s.source
                } else if (r.action === "fill") {
                    let {texture: s} = r.data.style;
                    return s.source
                }
            return null
        }
    }
      , ga = class extends Ss {
        constructor(...e) {
            var t, r, s;
            let n = Lh(e, "BitmapText");
            (t = n.style) != null || (n.style = n.style || {}),
            (s = (r = n.style).fill) != null || (r.fill = 16777215),
            super(n, Lt),
            this.renderPipeId = "bitmapText"
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = Ts.measureText(this.text, this._style)
              , s = r.scale
              , n = r.offsetY * s
              , a = r.width * s
              , o = r.height * s
              , l = this._style._stroke;
            l && (a += l.width,
            o += l.width),
            e.minX = -t._x * a,
            e.maxX = e.minX + a,
            e.minY = -t._y * (o + n),
            e.maxY = e.minY + o
        }
        set resolution(e) {}
        get resolution() {
            return this._resolution
        }
    }
    ;
    function v5(i) {
        let e = i._stroke
          , t = i._fill
          , r = [`div { ${[`color: ${Be.shared.setValue(t.color).toHex()}`, `font-size: ${i.fontSize}px`, `font-family: ${i.fontFamily}`, `font-weight: ${i.fontWeight}`, `font-style: ${i.fontStyle}`, `font-variant: ${i.fontVariant}`, `letter-spacing: ${i.letterSpacing}px`, `text-align: ${i.align}`, `padding: ${i.padding}px`, `white-space: ${i.whiteSpace === "pre" && i.wordWrap ? "pre-wrap" : i.whiteSpace}`, ...i.lineHeight ? [`line-height: ${i.lineHeight}px`] : [], ...i.wordWrap ? [`word-wrap: ${i.breakWords ? "break-all" : "break-word"}`, `max-width: ${i.wordWrapWidth}px`] : [], ...e ? [Zm(e)] : [], ...i.dropShadow ? [qm(i.dropShadow)] : [], ...i.cssOverrides].join(";")} }`];
        return T5(i.tagStyles, r),
        r.join(" ")
    }
    function qm(i) {
        let e = Be.shared.setValue(i.color).setAlpha(i.alpha).toHexa()
          , t = Math.round(Math.cos(i.angle) * i.distance)
          , r = Math.round(Math.sin(i.angle) * i.distance)
          , s = `${t}px ${r}px`;
        return i.blur > 0 ? `text-shadow: ${s} ${i.blur}px ${e}` : `text-shadow: ${s} ${e}`
    }
    function Zm(i) {
        return [`-webkit-text-stroke-width: ${i.width}px`, `-webkit-text-stroke-color: ${Be.shared.setValue(i.color).toHex()}`, `text-stroke-width: ${i.width}px`, `text-stroke-color: ${Be.shared.setValue(i.color).toHex()}`, "paint-order: stroke"].join(";")
    }
    var wp = {
        fontSize: "font-size: {{VALUE}}px",
        fontFamily: "font-family: {{VALUE}}",
        fontWeight: "font-weight: {{VALUE}}",
        fontStyle: "font-style: {{VALUE}}",
        fontVariant: "font-variant: {{VALUE}}",
        letterSpacing: "letter-spacing: {{VALUE}}px",
        align: "text-align: {{VALUE}}",
        padding: "padding: {{VALUE}}px",
        whiteSpace: "white-space: {{VALUE}}",
        lineHeight: "line-height: {{VALUE}}px",
        wordWrapWidth: "max-width: {{VALUE}}px"
    }
      , Ap = {
        fill: i => `color: ${Be.shared.setValue(i).toHex()}`,
        breakWords: i => `word-wrap: ${i ? "break-all" : "break-word"}`,
        stroke: Zm,
        dropShadow: qm
    };
    function T5(i, e) {
        for (let t in i) {
            let r = i[t]
              , s = [];
            for (let n in r)
                Ap[n] ? s.push(Ap[n](r[n])) : wp[n] && s.push(wp[n].replace("{{VALUE}}", r[n]));
            e.push(`${t} { ${s.join(";")} }`)
        }
    }
    var S5 = Object.defineProperty
      , Ep = Object.getOwnPropertySymbols
      , w5 = Object.prototype.hasOwnProperty
      , A5 = Object.prototype.propertyIsEnumerable
      , Pp = (i, e, t) => e in i ? S5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Rp = (i, e) => {
        for (var t in e || (e = {}))
            w5.call(e, t) && Pp(i, t, e[t]);
        if (Ep)
            for (var t of Ep(e))
                A5.call(e, t) && Pp(i, t, e[t]);
        return i
    }
      , Wl = class i extends Lt {
        constructor(e={}) {
            var t, r;
            super(e),
            this._cssOverrides = [],
            this.cssOverrides = (t = e.cssOverrides) != null ? t : [],
            this.tagStyles = (r = e.tagStyles) != null ? r : {}
        }
        set cssOverrides(e) {
            this._cssOverrides = e instanceof Array ? e : [e],
            this.update()
        }
        get cssOverrides() {
            return this._cssOverrides
        }
        update() {
            this._cssStyle = null,
            super.update()
        }
        clone() {
            return new i({
                align: this.align,
                breakWords: this.breakWords,
                dropShadow: this.dropShadow ? Rp({}, this.dropShadow) : null,
                fill: this._fill,
                fontFamily: this.fontFamily,
                fontSize: this.fontSize,
                fontStyle: this.fontStyle,
                fontVariant: this.fontVariant,
                fontWeight: this.fontWeight,
                letterSpacing: this.letterSpacing,
                lineHeight: this.lineHeight,
                padding: this.padding,
                stroke: this._stroke,
                whiteSpace: this.whiteSpace,
                wordWrap: this.wordWrap,
                wordWrapWidth: this.wordWrapWidth,
                cssOverrides: this.cssOverrides,
                tagStyles: Rp({}, this.tagStyles)
            })
        }
        get cssStyle() {
            return this._cssStyle || (this._cssStyle = v5(this)),
            this._cssStyle
        }
        addOverride(...e) {
            let t = e.filter(r => !this.cssOverrides.includes(r));
            t.length > 0 && (this.cssOverrides.push(...t),
            this.update())
        }
        removeOverride(...e) {
            let t = e.filter(r => this.cssOverrides.includes(r));
            t.length > 0 && (this.cssOverrides = this.cssOverrides.filter(r => !t.includes(r)),
            this.update())
        }
        set fill(e) {
            super.fill = e
        }
        set stroke(e) {
            super.stroke = e
        }
    }
      , Yl = class extends Ss {
        constructor(...e) {
            let t = Lh(e, "HtmlText");
            super(t, Wl),
            this.renderPipeId = "htmlText",
            t.textureStyle && (this.textureStyle = t.textureStyle instanceof kt ? t.textureStyle : new kt(t.textureStyle))
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = Qb(this.text, this._style)
              , {width: s, height: n} = r;
            e.minX = -t._x * s,
            e.maxX = e.minX + s,
            e.minY = -t._y * n,
            e.maxY = e.minY + n
        }
        get text() {
            return this._text
        }
        set text(e) {
            let t = this._sanitiseText(e.toString());
            super.text = t
        }
        _sanitiseText(e) {
            return this._removeInvalidHtmlTags(e.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;"))
        }
        _removeInvalidHtmlTags(e) {
            let t = /<[^>]*?(?=<|$)/g;
            return e.replace(t, "")
        }
    }
      , $l = class extends Vl {
        uploadQueueItem(e) {
            e instanceof Xe ? this.uploadTextureSource(e) : e instanceof ke ? this.uploadText(e) : e instanceof Yl ? this.uploadHTMLText(e) : e instanceof ga ? this.uploadBitmapText(e) : e instanceof yt && this.uploadGraphicsContext(e)
        }
        uploadTextureSource(e) {
            this.renderer.texture.initSource(e)
        }
        uploadText(e) {
            this.renderer.renderPipes.text.initGpuText(e)
        }
        uploadBitmapText(e) {
            this.renderer.renderPipes.bitmapText.initGpuText(e)
        }
        uploadHTMLText(e) {
            this.renderer.renderPipes.htmlText.initGpuText(e)
        }
        uploadGraphicsContext(e) {
            this.renderer.graphicsContext.getGpuContext(e);
            let {instructions: t} = e;
            for (let r of t)
                if (r.action === "texture") {
                    let {image: s} = r.data;
                    this.uploadTextureSource(s.source)
                } else if (r.action === "fill") {
                    let {texture: s} = r.data.style;
                    this.uploadTextureSource(s.source)
                }
            return null
        }
    }
      , Kl = class extends $l {
        destroy() {
            clearTimeout(this.timeout),
            this.renderer = null,
            this.queue = null,
            this.resolves = null
        }
    }
    ;
    Kl.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem],
        name: "prepare"
    };
    var _a = class {
        constructor() {
            this._tempState = Ut.for2d(),
            this._didUploadHash = {}
        }
        init(e) {
            e.renderer.runners.contextChange.add(this)
        }
        contextChange() {
            this._didUploadHash = {}
        }
        start(e, t, r) {
            let s = e.renderer
              , n = this._didUploadHash[r.uid];
            s.shader.bind(r, n),
            n || (this._didUploadHash[r.uid] = !0),
            s.shader.updateUniformGroup(s.globalUniforms.uniformGroup),
            s.geometry.bind(t, r.glProgram)
        }
        execute(e, t) {
            let r = e.renderer;
            this._tempState.blendMode = t.blendMode,
            r.state.set(this._tempState);
            let s = t.textures.textures;
            for (let n = 0; n < t.textures.count; n++)
                r.texture.bind(s[n], n);
            r.geometry.draw(t.topology, t.size, t.start)
        }
    }
    ;
    _a.extension = {
        type: [O.WebGLPipesAdaptor],
        name: "batch"
    };
    var rn = Ut.for2d()
      , xa = class {
        start(e, t, r) {
            let s = e.renderer
              , n = s.encoder
              , a = r.gpuProgram;
            this._shader = r,
            this._geometry = t,
            n.setGeometry(t, a),
            rn.blendMode = "normal",
            s.pipeline.getPipeline(t, a, rn);
            let o = s.globalUniforms.bindGroup;
            n.resetBindGroup(1),
            n.setBindGroup(0, o, a)
        }
        execute(e, t) {
            let r = this._shader.gpuProgram
              , s = e.renderer
              , n = s.encoder;
            if (!t.bindGroup) {
                let l = t.textures;
                t.bindGroup = Rh(l.textures, l.count, s.limits.maxBatchableTextures)
            }
            rn.blendMode = t.blendMode;
            let a = s.bindGroup.getBindGroup(t.bindGroup, r, 1)
              , o = s.pipeline.getPipeline(this._geometry, r, rn, t.topology);
            t.bindGroup._touch(s.textureGC.count),
            n.setPipeline(o),
            n.renderPassEncoder.setBindGroup(1, a),
            n.renderPassEncoder.drawIndexed(t.size, 1, t.start)
        }
    }
    ;
    xa.extension = {
        type: [O.WebGPUPipesAdaptor],
        name: "batch"
    };
    var ql = class Qm {
        constructor(e, t) {
            this.state = Ut.for2d(),
            this._batchersByInstructionSet = Object.create(null),
            this._activeBatches = Object.create(null);
            var r, s;
            this.renderer = e,
            this._adaptor = t,
            (s = (r = this._adaptor).init) == null || s.call(r, this)
        }
        static getBatcher(e) {
            return new this._availableBatchers[e]
        }
        buildStart(e) {
            let t = this._batchersByInstructionSet[e.uid];
            t || (t = this._batchersByInstructionSet[e.uid] = Object.create(null),
            t.default || (t.default = new Bh({
                maxTextures: this.renderer.limits.maxBatchableTextures
            }))),
            this._activeBatches = t,
            this._activeBatch = this._activeBatches.default;
            for (let r in this._activeBatches)
                this._activeBatches[r].begin()
        }
        addToBatch(e, t) {
            if (this._activeBatch.name !== e.batcherName) {
                this._activeBatch.break(t);
                let r = this._activeBatches[e.batcherName];
                r || (r = this._activeBatches[e.batcherName] = Qm.getBatcher(e.batcherName),
                r.begin()),
                this._activeBatch = r
            }
            this._activeBatch.add(e)
        }
        break(e) {
            this._activeBatch.break(e)
        }
        buildEnd(e) {
            this._activeBatch.break(e);
            let t = this._activeBatches;
            for (let r in t) {
                let s = t[r]
                  , n = s.geometry;
                n.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, !0),
                n.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, !1)
            }
        }
        upload(e) {
            let t = this._batchersByInstructionSet[e.uid];
            for (let r in t) {
                let s = t[r]
                  , n = s.geometry;
                s.dirty && (s.dirty = !1,
                n.buffers[0].update(s.attributeSize * 4))
            }
        }
        execute(e) {
            if (e.action === "startBatch") {
                let t = e.batcher
                  , r = t.geometry
                  , s = t.shader;
                this._adaptor.start(this, r, s)
            }
            this._adaptor.execute(this, e)
        }
        destroy() {
            this.state = null,
            this.renderer = null,
            this._adaptor = null;
            for (let e in this._activeBatches)
                this._activeBatches[e].destroy();
            this._activeBatches = null
        }
    }
    ;
    ql.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "batch"
    },
    ql._availableBatchers = Object.create(null);
    var Jm = ql;
    be.handleByMap(O.Batcher, Jm._availableBatchers),
    be.add(Bh);
    var E5 = {
        name: "texture-bit",
        vertex: {
            header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
            main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,
            main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        }
    }
      , P5 = {
        name: "texture-bit",
        vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
        uniform sampler2D uTexture;


        `,
            main: `
            outColor = texture(uTexture, vUV);
        `
        }
    }
      , R5 = new at
      , M5 = class extends xr {
        constructor() {
            super(),
            this.filters = [new jl({
                sprite: new Fe(Z.EMPTY),
                inverse: !1,
                resolution: "inherit",
                antialias: "inherit"
            })]
        }
        get sprite() {
            return this.filters[0].sprite
        }
        set sprite(i) {
            this.filters[0].sprite = i
        }
        get inverse() {
            return this.filters[0].inverse
        }
        set inverse(i) {
            this.filters[0].inverse = i
        }
    }
      , ya = class {
        constructor(e) {
            this._activeMaskStage = [],
            this._renderer = e
        }
        push(e, t, r) {
            let s = this._renderer;
            if (s.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: t
            }),
            e.inverse = t._maskOptions.inverse,
            e.renderMaskToTexture) {
                let n = e.mask;
                n.includeInBuild = !0,
                n.collectRenderables(r, s, null),
                n.includeInBuild = !1
            }
            s.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "alphaMask",
                action: "pushMaskEnd",
                mask: e,
                maskedContainer: t,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            })
        }
        pop(e, t, r) {
            this._renderer.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "alphaMask",
                action: "popMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            })
        }
        execute(e) {
            let t = this._renderer
              , r = e.mask.renderMaskToTexture;
            if (e.action === "pushMaskBegin") {
                let s = Je.get(M5);
                if (s.inverse = e.inverse,
                r) {
                    e.mask.mask.measurable = !0;
                    let n = fo(e.mask.mask, !0, R5);
                    e.mask.mask.measurable = !1,
                    n.ceil();
                    let a = t.renderTarget.renderTarget.colorTexture.source
                      , o = Ke.getOptimalTexture(n.width, n.height, a._resolution, a.antialias);
                    t.renderTarget.push(o, !0),
                    t.globalUniforms.push({
                        offset: n,
                        worldColor: 4294967295
                    });
                    let l = s.sprite;
                    l.texture = o,
                    l.worldTransform.tx = n.minX,
                    l.worldTransform.ty = n.minY,
                    this._activeMaskStage.push({
                        filterEffect: s,
                        maskedContainer: e.maskedContainer,
                        filterTexture: o
                    })
                } else
                    s.sprite = e.mask.mask,
                    this._activeMaskStage.push({
                        filterEffect: s,
                        maskedContainer: e.maskedContainer
                    })
            } else if (e.action === "pushMaskEnd") {
                let s = this._activeMaskStage[this._activeMaskStage.length - 1];
                r && (t.type === Ct.WEBGL && t.renderTarget.finishRenderPass(),
                t.renderTarget.pop(),
                t.globalUniforms.pop()),
                t.filter.push({
                    renderPipeId: "filter",
                    action: "pushFilter",
                    container: s.maskedContainer,
                    filterEffect: s.filterEffect,
                    canBundle: !1
                })
            } else if (e.action === "popMaskEnd") {
                t.filter.pop();
                let s = this._activeMaskStage.pop();
                r && Ke.returnTexture(s.filterTexture),
                Je.return(s.filterEffect)
            }
        }
        destroy() {
            this._renderer = null,
            this._activeMaskStage = null
        }
    }
    ;
    ya.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "alphaMask"
    };
    var va = class {
        constructor(e) {
            this._colorStack = [],
            this._colorStackIndex = 0,
            this._currentColor = 0,
            this._renderer = e
        }
        buildStart() {
            this._colorStack[0] = 15,
            this._colorStackIndex = 1,
            this._currentColor = 15
        }
        push(e, t, r) {
            this._renderer.renderPipes.batch.break(r);
            let s = this._colorStack;
            s[this._colorStackIndex] = s[this._colorStackIndex - 1] & e.mask;
            let n = this._colorStack[this._colorStackIndex];
            n !== this._currentColor && (this._currentColor = n,
            r.add({
                renderPipeId: "colorMask",
                colorMask: n,
                canBundle: !1
            })),
            this._colorStackIndex++
        }
        pop(e, t, r) {
            this._renderer.renderPipes.batch.break(r);
            let s = this._colorStack;
            this._colorStackIndex--;
            let n = s[this._colorStackIndex - 1];
            n !== this._currentColor && (this._currentColor = n,
            r.add({
                renderPipeId: "colorMask",
                colorMask: n,
                canBundle: !1
            }))
        }
        execute(e) {
            this._renderer.colorMask.setMask(e.colorMask)
        }
        destroy() {
            this._renderer = null,
            this._colorStack = null
        }
    }
    ;
    va.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "colorMask"
    };
    var Ta = class {
        constructor(e) {
            this._maskStackHash = {},
            this._maskHash = new WeakMap,
            this._renderer = e
        }
        push(e, t, r) {
            var s, n;
            let a = e
              , o = this._renderer;
            o.renderPipes.batch.break(r),
            o.renderPipes.blendMode.setBlendMode(a.mask, "none", r),
            r.add({
                renderPipeId: "stencilMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            let l = a.mask;
            l.includeInBuild = !0,
            this._maskHash.has(a) || this._maskHash.set(a, {
                instructionsStart: 0,
                instructionsLength: 0
            });
            let u = this._maskHash.get(a);
            u.instructionsStart = r.instructionSize,
            l.collectRenderables(r, o, null),
            l.includeInBuild = !1,
            o.renderPipes.batch.break(r),
            r.add({
                renderPipeId: "stencilMask",
                action: "pushMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            let d = r.instructionSize - u.instructionsStart - 1;
            u.instructionsLength = d;
            let f = o.renderTarget.renderTarget.uid;
            (n = (s = this._maskStackHash)[f]) != null || (s[f] = 0)
        }
        pop(e, t, r) {
            let s = e
              , n = this._renderer;
            n.renderPipes.batch.break(r),
            n.renderPipes.blendMode.setBlendMode(s.mask, "none", r),
            r.add({
                renderPipeId: "stencilMask",
                action: "popMaskBegin",
                inverse: t._maskOptions.inverse,
                canBundle: !1
            });
            let a = this._maskHash.get(e);
            for (let o = 0; o < a.instructionsLength; o++)
                r.instructions[r.instructionSize++] = r.instructions[a.instructionsStart++];
            r.add({
                renderPipeId: "stencilMask",
                action: "popMaskEnd",
                canBundle: !1
            })
        }
        execute(e) {
            var t, r;
            let s = this._renderer
              , n = s.renderTarget.renderTarget.uid
              , a = (r = (t = this._maskStackHash)[n]) != null ? r : t[n] = 0;
            e.action === "pushMaskBegin" ? (s.renderTarget.ensureDepthStencil(),
            s.stencil.setStencilMode(qe.RENDERING_MASK_ADD, a),
            a++,
            s.colorMask.setMask(0)) : e.action === "pushMaskEnd" ? (e.inverse ? s.stencil.setStencilMode(qe.INVERSE_MASK_ACTIVE, a) : s.stencil.setStencilMode(qe.MASK_ACTIVE, a),
            s.colorMask.setMask(15)) : e.action === "popMaskBegin" ? (s.colorMask.setMask(0),
            a !== 0 ? s.stencil.setStencilMode(qe.RENDERING_MASK_REMOVE, a) : (s.renderTarget.clear(null, Rt.STENCIL),
            s.stencil.setStencilMode(qe.DISABLED, a)),
            a--) : e.action === "popMaskEnd" && (e.inverse ? s.stencil.setStencilMode(qe.INVERSE_MASK_ACTIVE, a) : s.stencil.setStencilMode(qe.MASK_ACTIVE, a),
            s.colorMask.setMask(15)),
            this._maskStackHash[n] = a
        }
        destroy() {
            this._renderer = null,
            this._maskStackHash = null,
            this._maskHash = null
        }
    }
    ;
    Ta.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "stencilMask"
    };
    var un = (i => (i[i.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
    i[i.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
    i[i.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER",
    i))(un || {})
      , Zl = class {
        constructor(e, t) {
            this._lastBindBaseLocation = -1,
            this._lastBindCallId = -1,
            this.buffer = e || null,
            this.updateID = -1,
            this.byteLength = -1,
            this.type = t
        }
    }
      , Sa = class {
        constructor(e) {
            this._gpuBuffers = Object.create(null),
            this._boundBufferBases = Object.create(null),
            this._minBaseLocation = 0,
            this._nextBindBaseIndex = this._minBaseLocation,
            this._bindCallId = 0,
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers")
        }
        destroy() {
            this._renderer = null,
            this._gl = null,
            this._gpuBuffers = null,
            this._boundBufferBases = null
        }
        contextChange() {
            this._gl = this._renderer.gl,
            this._gpuBuffers = Object.create(null),
            this._maxBindings = this._renderer.limits.maxUniformBindings
        }
        getGlBuffer(e) {
            return this._gpuBuffers[e.uid] || this.createGLBuffer(e)
        }
        bind(e) {
            let {_gl: t} = this
              , r = this.getGlBuffer(e);
            t.bindBuffer(r.type, r.buffer)
        }
        bindBufferBase(e, t) {
            let {_gl: r} = this;
            this._boundBufferBases[t] !== e && (this._boundBufferBases[t] = e,
            e._lastBindBaseLocation = t,
            r.bindBufferBase(r.UNIFORM_BUFFER, t, e.buffer))
        }
        nextBindBase(e) {
            this._bindCallId++,
            this._minBaseLocation = 0,
            e && (this._boundBufferBases[0] = null,
            this._minBaseLocation = 1,
            this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1))
        }
        freeLocationForBufferBase(e) {
            let t = this.getLastBindBaseLocation(e);
            if (t >= this._minBaseLocation)
                return e._lastBindCallId = this._bindCallId,
                t;
            let r = 0
              , s = this._nextBindBaseIndex;
            for (; r < 2; ) {
                s >= this._maxBindings && (s = this._minBaseLocation,
                r++);
                let n = this._boundBufferBases[s];
                if (n && n._lastBindCallId === this._bindCallId) {
                    s++;
                    continue
                }
                break
            }
            return t = s,
            this._nextBindBaseIndex = s + 1,
            r >= 2 ? -1 : (e._lastBindCallId = this._bindCallId,
            this._boundBufferBases[t] = null,
            t)
        }
        getLastBindBaseLocation(e) {
            let t = e._lastBindBaseLocation;
            return this._boundBufferBases[t] === e ? t : -1
        }
        bindBufferRange(e, t, r, s) {
            let {_gl: n} = this;
            r || (r = 0),
            t || (t = 0),
            this._boundBufferBases[t] = null,
            n.bindBufferRange(n.UNIFORM_BUFFER, t || 0, e.buffer, r * 256, s || 256)
        }
        updateBuffer(e) {
            let {_gl: t} = this
              , r = this.getGlBuffer(e);
            if (e._updateID === r.updateID)
                return r;
            r.updateID = e._updateID,
            t.bindBuffer(r.type, r.buffer);
            let s = e.data
              , n = e.descriptor.usage & Pe.STATIC ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
            return s ? r.byteLength >= s.byteLength ? t.bufferSubData(r.type, 0, s, 0, e._updateSize / s.BYTES_PER_ELEMENT) : (r.byteLength = s.byteLength,
            t.bufferData(r.type, s, n)) : (r.byteLength = e.descriptor.size,
            t.bufferData(r.type, r.byteLength, n)),
            r
        }
        destroyAll() {
            let e = this._gl;
            for (let t in this._gpuBuffers)
                e.deleteBuffer(this._gpuBuffers[t].buffer);
            this._gpuBuffers = Object.create(null)
        }
        onBufferDestroy(e, t) {
            let r = this._gpuBuffers[e.uid]
              , s = this._gl;
            t || s.deleteBuffer(r.buffer),
            this._gpuBuffers[e.uid] = null
        }
        createGLBuffer(e) {
            let {_gl: t} = this
              , r = un.ARRAY_BUFFER;
            e.descriptor.usage & Pe.INDEX ? r = un.ELEMENT_ARRAY_BUFFER : e.descriptor.usage & Pe.UNIFORM && (r = un.UNIFORM_BUFFER);
            let s = new Zl(t.createBuffer(),r);
            return this._gpuBuffers[e.uid] = s,
            e.on("destroy", this.onBufferDestroy, this),
            s
        }
        resetState() {
            this._boundBufferBases = Object.create(null)
        }
    }
    ;
    Sa.extension = {
        type: [O.WebGLSystem],
        name: "buffer"
    };
    var C5 = Object.defineProperty
      , O5 = Object.defineProperties
      , I5 = Object.getOwnPropertyDescriptors
      , Mp = Object.getOwnPropertySymbols
      , G5 = Object.prototype.hasOwnProperty
      , B5 = Object.prototype.propertyIsEnumerable
      , Cp = (i, e, t) => e in i ? C5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , sn = (i, e) => {
        for (var t in e || (e = {}))
            G5.call(e, t) && Cp(i, t, e[t]);
        if (Mp)
            for (var t of Mp(e))
                B5.call(e, t) && Cp(i, t, e[t]);
        return i
    }
      , Op = (i, e) => O5(i, I5(e))
      , Ql = class eg {
        constructor(e) {
            this.supports = {
                uint32Indices: !0,
                uniformBufferObject: !0,
                vertexArrayObject: !0,
                srgbTextures: !0,
                nonPowOf2wrapping: !0,
                msaa: !0,
                nonPowOf2mipmaps: !0
            },
            this._renderer = e,
            this.extensions = Object.create(null),
            this.handleContextLost = this.handleContextLost.bind(this),
            this.handleContextRestored = this.handleContextRestored.bind(this)
        }
        get isLost() {
            return !this.gl || this.gl.isContextLost()
        }
        contextChange(e) {
            this.gl = e,
            this._renderer.gl = e
        }
        init(e) {
            var t, r;
            e = sn(sn({}, eg.defaultOptions), e);
            let s = this.multiView = e.multiView;
            if (e.context && s && (_i("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."),
            s = !1),
            s ? this.canvas = ye.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas,
            e.context)
                this.initFromContext(e.context);
            else {
                let n = this._renderer.background.alpha < 1
                  , a = (t = e.premultipliedAlpha) != null ? t : !0
                  , o = e.antialias && !this._renderer.backBuffer.useBackBuffer;
                this.createContext(e.preferWebGLVersion, {
                    alpha: n,
                    premultipliedAlpha: a,
                    antialias: o,
                    stencil: !0,
                    preserveDrawingBuffer: e.preserveDrawingBuffer,
                    powerPreference: (r = e.powerPreference) != null ? r : "default"
                })
            }
        }
        ensureCanvasSize(e) {
            if (!this.multiView) {
                e !== this.canvas && _i("multiView is disabled, but targetCanvas is not the main canvas");
                return
            }
            let {canvas: t} = this;
            (t.width < e.width || t.height < e.height) && (t.width = Math.max(e.width, e.width),
            t.height = Math.max(e.height, e.height))
        }
        initFromContext(e) {
            this.gl = e,
            this.webGLVersion = e instanceof ye.get().getWebGLRenderingContext() ? 1 : 2,
            this.getExtensions(),
            this.validateContext(e),
            this._renderer.runners.contextChange.emit(e);
            let t = this._renderer.view.canvas;
            t.addEventListener("webglcontextlost", this.handleContextLost, !1),
            t.addEventListener("webglcontextrestored", this.handleContextRestored, !1)
        }
        createContext(e, t) {
            let r, s = this.canvas;
            if (e === 2 && (r = s.getContext("webgl2", t)),
            !r && (r = s.getContext("webgl", t),
            !r))
                throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            this.gl = r,
            this.initFromContext(this.gl)
        }
        getExtensions() {
            let {gl: e} = this
              , t = {
                anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
                floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: e.getExtension("WEBGL_compressed_texture_etc"),
                etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: e.getExtension("WEBGL_compressed_texture_atc"),
                astc: e.getExtension("WEBGL_compressed_texture_astc"),
                bptc: e.getExtension("EXT_texture_compression_bptc"),
                rgtc: e.getExtension("EXT_texture_compression_rgtc"),
                loseContext: e.getExtension("WEBGL_lose_context")
            };
            if (this.webGLVersion === 1)
                this.extensions = Op(sn({}, t), {
                    drawBuffers: e.getExtension("WEBGL_draw_buffers"),
                    depthTexture: e.getExtension("WEBGL_depth_texture"),
                    vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
                    uint32ElementIndex: e.getExtension("OES_element_index_uint"),
                    floatTexture: e.getExtension("OES_texture_float"),
                    floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                    textureHalfFloat: e.getExtension("OES_texture_half_float"),
                    textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear"),
                    vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"),
                    srgb: e.getExtension("EXT_sRGB")
                });
            else {
                this.extensions = Op(sn({}, t), {
                    colorBufferFloat: e.getExtension("EXT_color_buffer_float")
                });
                let r = e.getExtension("WEBGL_provoking_vertex");
                r && r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL)
            }
        }
        handleContextLost(e) {
            e.preventDefault(),
            this._contextLossForced && (this._contextLossForced = !1,
            setTimeout( () => {
                var t;
                this.gl.isContextLost() && ((t = this.extensions.loseContext) == null || t.restoreContext())
            }
            , 0))
        }
        handleContextRestored() {
            this.getExtensions(),
            this._renderer.runners.contextChange.emit(this.gl)
        }
        destroy() {
            var e;
            let t = this._renderer.view.canvas;
            this._renderer = null,
            t.removeEventListener("webglcontextlost", this.handleContextLost),
            t.removeEventListener("webglcontextrestored", this.handleContextRestored),
            this.gl.useProgram(null),
            (e = this.extensions.loseContext) == null || e.loseContext()
        }
        forceContextLoss() {
            var e;
            (e = this.extensions.loseContext) == null || e.loseContext(),
            this._contextLossForced = !0
        }
        validateContext(e) {
            let t = e.getContextAttributes();
            t && t.stencil;
            let r = this.supports
              , s = this.webGLVersion === 2
              , n = this.extensions;
            r.uint32Indices = s || !!n.uint32ElementIndex,
            r.uniformBufferObject = s,
            r.vertexArrayObject = s || !!n.vertexArrayObject,
            r.srgbTextures = s || !!n.srgb,
            r.nonPowOf2wrapping = s,
            r.nonPowOf2mipmaps = s,
            r.msaa = s,
            r.uint32Indices
        }
    }
    ;
    Ql.extension = {
        type: [O.WebGLSystem],
        name: "context"
    },
    Ql.defaultOptions = {
        context: null,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        powerPreference: void 0,
        preferWebGLVersion: 2,
        multiView: !1
    };
    var F5 = Ql;
    function tg(i, e) {
        var t, r, s;
        for (let n in i.attributes) {
            let a = i.attributes[n]
              , o = e[n];
            o ? ((t = a.format) != null || (a.format = o.format),
            (r = a.offset) != null || (a.offset = o.offset),
            (s = a.instance) != null || (a.instance = o.instance)) : _i(`Attribute ${n} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)
        }
        D5(i)
    }
    function D5(i) {
        var e, t;
        let {buffers: r, attributes: s} = i
          , n = {}
          , a = {};
        for (let o in r) {
            let l = r[o];
            n[l.uid] = 0,
            a[l.uid] = 0
        }
        for (let o in s) {
            let l = s[o];
            n[l.buffer.uid] += Mi(l.format).stride
        }
        for (let o in s) {
            let l = s[o];
            (e = l.stride) != null || (l.stride = n[l.buffer.uid]),
            (t = l.start) != null || (l.start = a[l.buffer.uid]),
            a[l.buffer.uid] += Mi(l.format).stride
        }
    }
    var Jl = (i => (i[i.RGBA = 6408] = "RGBA",
    i[i.RGB = 6407] = "RGB",
    i[i.RG = 33319] = "RG",
    i[i.RED = 6403] = "RED",
    i[i.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
    i[i.RGB_INTEGER = 36248] = "RGB_INTEGER",
    i[i.RG_INTEGER = 33320] = "RG_INTEGER",
    i[i.RED_INTEGER = 36244] = "RED_INTEGER",
    i[i.ALPHA = 6406] = "ALPHA",
    i[i.LUMINANCE = 6409] = "LUMINANCE",
    i[i.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
    i[i.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
    i[i.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
    i))(Jl || {})
      , ig = (i => (i[i.TEXTURE_2D = 3553] = "TEXTURE_2D",
    i[i.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP",
    i[i.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY",
    i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X",
    i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X",
    i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y",
    i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y",
    i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z",
    i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z",
    i))(ig || {})
      , k5 = (i => (i[i.CLAMP = 33071] = "CLAMP",
    i[i.REPEAT = 10497] = "REPEAT",
    i[i.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT",
    i))(k5 || {})
      , Ce = (i => (i[i.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
    i[i.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
    i[i.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
    i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
    i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
    i[i.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
    i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
    i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
    i[i.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
    i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
    i[i.BYTE = 5120] = "BYTE",
    i[i.SHORT = 5122] = "SHORT",
    i[i.INT = 5124] = "INT",
    i[i.FLOAT = 5126] = "FLOAT",
    i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
    i[i.HALF_FLOAT = 36193] = "HALF_FLOAT",
    i))(Ce || {})
      , Ip = {
        uint8x2: Ce.UNSIGNED_BYTE,
        uint8x4: Ce.UNSIGNED_BYTE,
        sint8x2: Ce.BYTE,
        sint8x4: Ce.BYTE,
        unorm8x2: Ce.UNSIGNED_BYTE,
        unorm8x4: Ce.UNSIGNED_BYTE,
        snorm8x2: Ce.BYTE,
        snorm8x4: Ce.BYTE,
        uint16x2: Ce.UNSIGNED_SHORT,
        uint16x4: Ce.UNSIGNED_SHORT,
        sint16x2: Ce.SHORT,
        sint16x4: Ce.SHORT,
        unorm16x2: Ce.UNSIGNED_SHORT,
        unorm16x4: Ce.UNSIGNED_SHORT,
        snorm16x2: Ce.SHORT,
        snorm16x4: Ce.SHORT,
        float16x2: Ce.HALF_FLOAT,
        float16x4: Ce.HALF_FLOAT,
        float32: Ce.FLOAT,
        float32x2: Ce.FLOAT,
        float32x3: Ce.FLOAT,
        float32x4: Ce.FLOAT,
        uint32: Ce.UNSIGNED_INT,
        uint32x2: Ce.UNSIGNED_INT,
        uint32x3: Ce.UNSIGNED_INT,
        uint32x4: Ce.UNSIGNED_INT,
        sint32: Ce.INT,
        sint32x2: Ce.INT,
        sint32x3: Ce.INT,
        sint32x4: Ce.INT
    };
    function U5(i) {
        var e;
        return (e = Ip[i]) != null ? e : Ip.float32
    }
    var L5 = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
    }
      , wa = class {
        constructor(e) {
            this._geometryVaoHash = Object.create(null),
            this._renderer = e,
            this._activeGeometry = null,
            this._activeVao = null,
            this.hasVao = !0,
            this.hasInstance = !0,
            this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash")
        }
        contextChange() {
            let e = this.gl = this._renderer.gl;
            if (!this._renderer.context.supports.vertexArrayObject)
                throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
            let t = this._renderer.context.extensions.vertexArrayObject;
            t && (e.createVertexArray = () => t.createVertexArrayOES(),
            e.bindVertexArray = s => t.bindVertexArrayOES(s),
            e.deleteVertexArray = s => t.deleteVertexArrayOES(s));
            let r = this._renderer.context.extensions.vertexAttribDivisorANGLE;
            r && (e.drawArraysInstanced = (s, n, a, o) => {
                r.drawArraysInstancedANGLE(s, n, a, o)
            }
            ,
            e.drawElementsInstanced = (s, n, a, o, l) => {
                r.drawElementsInstancedANGLE(s, n, a, o, l)
            }
            ,
            e.vertexAttribDivisor = (s, n) => r.vertexAttribDivisorANGLE(s, n)),
            this._activeGeometry = null,
            this._activeVao = null,
            this._geometryVaoHash = Object.create(null)
        }
        bind(e, t) {
            let r = this.gl;
            this._activeGeometry = e;
            let s = this.getVao(e, t);
            this._activeVao !== s && (this._activeVao = s,
            r.bindVertexArray(s)),
            this.updateBuffers()
        }
        resetState() {
            this.unbind()
        }
        updateBuffers() {
            let e = this._activeGeometry
              , t = this._renderer.buffer;
            for (let r = 0; r < e.buffers.length; r++) {
                let s = e.buffers[r];
                t.updateBuffer(s)
            }
        }
        checkCompatibility(e, t) {
            let r = e.attributes
              , s = t._attributeData;
            for (let n in s)
                if (!r[n])
                    throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`)
        }
        getSignature(e, t) {
            let r = e.attributes
              , s = t._attributeData
              , n = ["g", e.uid];
            for (let a in r)
                s[a] && n.push(a, s[a].location);
            return n.join("-")
        }
        getVao(e, t) {
            var r;
            return ((r = this._geometryVaoHash[e.uid]) == null ? void 0 : r[t._key]) || this.initGeometryVao(e, t)
        }
        initGeometryVao(e, t, r=!0) {
            let s = this._renderer.gl
              , n = this._renderer.buffer;
            this._renderer.shader._getProgramData(t),
            this.checkCompatibility(e, t);
            let a = this.getSignature(e, t);
            this._geometryVaoHash[e.uid] || (this._geometryVaoHash[e.uid] = Object.create(null),
            e.on("destroy", this.onGeometryDestroy, this));
            let o = this._geometryVaoHash[e.uid]
              , l = o[a];
            if (l)
                return o[t._key] = l,
                l;
            tg(e, t._attributeData);
            let u = e.buffers;
            l = s.createVertexArray(),
            s.bindVertexArray(l);
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                n.bind(f)
            }
            return this.activateVao(e, t),
            o[t._key] = l,
            o[a] = l,
            s.bindVertexArray(null),
            l
        }
        onGeometryDestroy(e, t) {
            let r = this._geometryVaoHash[e.uid]
              , s = this.gl;
            if (r) {
                if (t)
                    for (let n in r)
                        this._activeVao !== r[n] && this.unbind(),
                        s.deleteVertexArray(r[n]);
                this._geometryVaoHash[e.uid] = null
            }
        }
        destroyAll(e=!1) {
            let t = this.gl;
            for (let r in this._geometryVaoHash) {
                if (e)
                    for (let s in this._geometryVaoHash[r]) {
                        let n = this._geometryVaoHash[r];
                        this._activeVao !== n && this.unbind(),
                        t.deleteVertexArray(n[s])
                    }
                this._geometryVaoHash[r] = null
            }
        }
        activateVao(e, t) {
            var r, s;
            let n = this._renderer.gl
              , a = this._renderer.buffer
              , o = e.attributes;
            e.indexBuffer && a.bind(e.indexBuffer);
            let l = null;
            for (let u in o) {
                let d = o[u]
                  , f = d.buffer
                  , b = a.getGlBuffer(f)
                  , m = t._attributeData[u];
                if (m) {
                    l !== b && (a.bind(f),
                    l = b);
                    let x = m.location;
                    n.enableVertexAttribArray(x);
                    let v = Mi(d.format)
                      , S = U5(d.format);
                    if (((r = m.format) == null ? void 0 : r.substring(1, 4)) === "int" ? n.vertexAttribIPointer(x, v.size, S, d.stride, d.offset) : n.vertexAttribPointer(x, v.size, S, v.normalised, d.stride, d.offset),
                    d.instance)
                        if (this.hasInstance) {
                            let w = (s = d.divisor) != null ? s : 1;
                            n.vertexAttribDivisor(x, w)
                        } else
                            throw new Error("geometry error, GPU Instancing is not supported on this device")
                }
            }
        }
        draw(e, t, r, s) {
            let {gl: n} = this._renderer
              , a = this._activeGeometry
              , o = L5[e || a.topology];
            if (s != null || (s = a.instanceCount),
            a.indexBuffer) {
                let l = a.indexBuffer.data.BYTES_PER_ELEMENT
                  , u = l === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
                s > 1 ? n.drawElementsInstanced(o, t || a.indexBuffer.data.length, u, (r || 0) * l, s) : n.drawElements(o, t || a.indexBuffer.data.length, u, (r || 0) * l)
            } else
                s > 1 ? n.drawArraysInstanced(o, r || 0, t || a.getSize(), s) : n.drawArrays(o, r || 0, t || a.getSize());
            return this
        }
        unbind() {
            this.gl.bindVertexArray(null),
            this._activeVao = null,
            this._activeGeometry = null
        }
        destroy() {
            this._renderer = null,
            this.gl = null,
            this._activeVao = null,
            this._activeGeometry = null,
            this._geometryVaoHash = null
        }
    }
    ;
    wa.extension = {
        type: [O.WebGLSystem],
        name: "geometry"
    };
    var N5 = Object.defineProperty
      , Gp = Object.getOwnPropertySymbols
      , X5 = Object.prototype.hasOwnProperty
      , j5 = Object.prototype.propertyIsEnumerable
      , Bp = (i, e, t) => e in i ? N5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Fp = (i, e) => {
        for (var t in e || (e = {}))
            X5.call(e, t) && Bp(i, t, e[t]);
        if (Gp)
            for (var t of Gp(e))
                j5.call(e, t) && Bp(i, t, e[t]);
        return i
    }
      , H5 = new si({
        attributes: {
            aPosition: [-1, -1, 3, -1, -1, 3]
        }
    })
      , eh = class rg {
        constructor(e) {
            this.useBackBuffer = !1,
            this._useBackBufferThisRender = !1,
            this._renderer = e
        }
        init(e={}) {
            let {useBackBuffer: t, antialias: r} = Fp(Fp({}, rg.defaultOptions), e);
            this.useBackBuffer = t,
            this._antialias = r,
            this._renderer.context.supports.msaa || (_i("antialiasing, is not supported on when using the back buffer"),
            this._antialias = !1),
            this._state = Ut.for2d();
            let s = new yi({
                vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
                fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
                name: "big-triangle"
            });
            this._bigTriangleShader = new vt({
                glProgram: s,
                resources: {
                    uTexture: Z.WHITE.source
                }
            })
        }
        renderStart(e) {
            let t = this._renderer.renderTarget.getRenderTarget(e.target);
            if (this._useBackBufferThisRender = this.useBackBuffer && !!t.isRoot,
            this._useBackBufferThisRender) {
                let r = this._renderer.renderTarget.getRenderTarget(e.target);
                this._targetTexture = r.colorTexture,
                e.target = this._getBackBufferTexture(r.colorTexture)
            }
        }
        renderEnd() {
            this._presentBackBuffer()
        }
        _presentBackBuffer() {
            let e = this._renderer;
            e.renderTarget.finishRenderPass(),
            this._useBackBufferThisRender && (e.renderTarget.bind(this._targetTexture, !1),
            this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source,
            e.encoder.draw({
                geometry: H5,
                shader: this._bigTriangleShader,
                state: this._state
            }))
        }
        _getBackBufferTexture(e) {
            return this._backBufferTexture = this._backBufferTexture || new Z({
                source: new Xe({
                    width: e.width,
                    height: e.height,
                    resolution: e._resolution,
                    antialias: this._antialias
                })
            }),
            this._backBufferTexture.source.resize(e.width, e.height, e._resolution),
            this._backBufferTexture
        }
        destroy() {
            this._backBufferTexture && (this._backBufferTexture.destroy(),
            this._backBufferTexture = null)
        }
    }
    ;
    eh.extension = {
        type: [O.WebGLSystem],
        name: "backBuffer",
        priority: 1
    },
    eh.defaultOptions = {
        useBackBuffer: !1
    };
    var z5 = eh
      , Aa = class {
        constructor(e) {
            this._colorMaskCache = 15,
            this._renderer = e
        }
        setMask(e) {
            this._colorMaskCache !== e && (this._colorMaskCache = e,
            this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1)))
        }
    }
    ;
    Aa.extension = {
        type: [O.WebGLSystem],
        name: "colorMask"
    };
    var Ea = class {
        constructor(e) {
            this.commandFinished = Promise.resolve(),
            this._renderer = e
        }
        setGeometry(e, t) {
            this._renderer.geometry.bind(e, t.glProgram)
        }
        finishRenderPass() {}
        draw(e) {
            let t = this._renderer
              , {geometry: r, shader: s, state: n, skipSync: a, topology: o, size: l, start: u, instanceCount: d} = e;
            t.shader.bind(s, a),
            t.geometry.bind(r, t.shader._activeProgram),
            n && t.state.set(n),
            t.geometry.draw(o, l, u, d ?? r.instanceCount)
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Ea.extension = {
        type: [O.WebGLSystem],
        name: "encoder"
    };
    var Pa = class {
        constructor(e) {
            this._renderer = e
        }
        contextChange() {
            let e = this._renderer.gl;
            this.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
            this.maxBatchableTextures = _b(this.maxTextures, e);
            let t = this._renderer.context.webGLVersion === 2;
            this.maxUniformBindings = t ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0
        }
        destroy() {}
    }
    ;
    Pa.extension = {
        type: [O.WebGLSystem],
        name: "limits"
    };
    var th = class {
        constructor() {
            this.width = -1,
            this.height = -1,
            this.msaa = !1,
            this.msaaRenderBuffer = []
        }
    }
      , Ei = [];
    Ei[qe.NONE] = void 0,
    Ei[qe.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
    },
    Ei[qe.RENDERING_MASK_ADD] = {
        stencilFront: {
            compare: "equal",
            passOp: "increment-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "increment-clamp"
        }
    },
    Ei[qe.RENDERING_MASK_REMOVE] = {
        stencilFront: {
            compare: "equal",
            passOp: "decrement-clamp"
        },
        stencilBack: {
            compare: "equal",
            passOp: "decrement-clamp"
        }
    },
    Ei[qe.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "equal",
            passOp: "keep"
        },
        stencilBack: {
            compare: "equal",
            passOp: "keep"
        }
    },
    Ei[qe.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
            compare: "not-equal",
            passOp: "keep"
        },
        stencilBack: {
            compare: "not-equal",
            passOp: "keep"
        }
    };
    var Ra = class {
        constructor(e) {
            this._stencilCache = {
                enabled: !1,
                stencilReference: 0,
                stencilMode: qe.NONE
            },
            this._renderTargetStencilState = Object.create(null),
            e.renderTarget.onRenderTargetChange.add(this)
        }
        contextChange(e) {
            this._gl = e,
            this._comparisonFuncMapping = {
                always: e.ALWAYS,
                never: e.NEVER,
                equal: e.EQUAL,
                "not-equal": e.NOTEQUAL,
                less: e.LESS,
                "less-equal": e.LEQUAL,
                greater: e.GREATER,
                "greater-equal": e.GEQUAL
            },
            this._stencilOpsMapping = {
                keep: e.KEEP,
                zero: e.ZERO,
                replace: e.REPLACE,
                invert: e.INVERT,
                "increment-clamp": e.INCR,
                "decrement-clamp": e.DECR,
                "increment-wrap": e.INCR_WRAP,
                "decrement-wrap": e.DECR_WRAP
            },
            this.resetState()
        }
        onRenderTargetChange(e) {
            if (this._activeRenderTarget === e)
                return;
            this._activeRenderTarget = e;
            let t = this._renderTargetStencilState[e.uid];
            t || (t = this._renderTargetStencilState[e.uid] = {
                stencilMode: qe.DISABLED,
                stencilReference: 0
            }),
            this.setStencilMode(t.stencilMode, t.stencilReference)
        }
        resetState() {
            this._stencilCache.enabled = !1,
            this._stencilCache.stencilMode = qe.NONE,
            this._stencilCache.stencilReference = 0
        }
        setStencilMode(e, t) {
            let r = this._renderTargetStencilState[this._activeRenderTarget.uid]
              , s = this._gl
              , n = Ei[e]
              , a = this._stencilCache;
            if (r.stencilMode = e,
            r.stencilReference = t,
            e === qe.DISABLED) {
                this._stencilCache.enabled && (this._stencilCache.enabled = !1,
                s.disable(s.STENCIL_TEST));
                return
            }
            this._stencilCache.enabled || (this._stencilCache.enabled = !0,
            s.enable(s.STENCIL_TEST)),
            (e !== a.stencilMode || a.stencilReference !== t) && (a.stencilMode = e,
            a.stencilReference = t,
            s.stencilFunc(this._comparisonFuncMapping[n.stencilBack.compare], t, 255),
            s.stencilOp(s.KEEP, s.KEEP, this._stencilOpsMapping[n.stencilBack.passOp]))
        }
    }
    ;
    Ra.extension = {
        type: [O.WebGLSystem],
        name: "stencil"
    };
    var Ma = class {
        constructor(e) {
            this._syncFunctionHash = Object.create(null),
            this._adaptor = e,
            this._systemCheck()
        }
        _systemCheck() {
            if (!am())
                throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")
        }
        ensureUniformGroup(e) {
            let t = this.getUniformGroupData(e);
            e.buffer || (e.buffer = new bt({
                data: new Float32Array(t.layout.size / 4),
                usage: Pe.UNIFORM | Pe.COPY_DST
            }))
        }
        getUniformGroupData(e) {
            return this._syncFunctionHash[e._signature] || this._initUniformGroup(e)
        }
        _initUniformGroup(e) {
            let t = e._signature
              , r = this._syncFunctionHash[t];
            if (!r) {
                let s = Object.keys(e.uniformStructures).map(o => e.uniformStructures[o])
                  , n = this._adaptor.createUboElements(s)
                  , a = this._generateUboSync(n.uboElements);
                r = this._syncFunctionHash[t] = {
                    layout: n,
                    syncFunction: a
                }
            }
            return this._syncFunctionHash[t]
        }
        _generateUboSync(e) {
            return this._adaptor.generateUboSync(e)
        }
        syncUniformGroup(e, t, r) {
            let s = this.getUniformGroupData(e);
            e.buffer || (e.buffer = new bt({
                data: new Float32Array(s.layout.size / 4),
                usage: Pe.UNIFORM | Pe.COPY_DST
            }));
            let n = null;
            return t || (t = e.buffer.data,
            n = e.buffer.dataInt32),
            r || (r = 0),
            s.syncFunction(e.uniforms, t, n, r),
            !0
        }
        updateUniformGroup(e) {
            if (e.isStatic && !e._dirtyId)
                return !1;
            e._dirtyId = 0;
            let t = this.syncUniformGroup(e);
            return e.buffer.update(),
            t
        }
        destroy() {
            this._syncFunctionHash = null
        }
    }
      , sg = {
        f32: 4,
        i32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "vec2<i32>": 8,
        "vec3<i32>": 12,
        "vec4<i32>": 16,
        "mat2x2<f32>": 32,
        "mat3x3<f32>": 48,
        "mat4x4<f32>": 64
    };
    function V5(i) {
        let e = i.map(n => ({
            data: n,
            offset: 0,
            size: 0
        }))
          , t = 16
          , r = 0
          , s = 0;
        for (let n = 0; n < e.length; n++) {
            let a = e[n];
            if (r = sg[a.data.type],
            !r)
                throw new Error(`Unknown type ${a.data.type}`);
            a.data.size > 1 && (r = Math.max(r, t) * a.data.size);
            let o = r === 12 ? 16 : r;
            a.size = r;
            let l = s % t;
            l > 0 && t - l < o ? s += (t - l) % 16 : s += (r - l % r) % r,
            a.offset = s,
            s += r
        }
        return s = Math.ceil(s / 16) * 16,
        {
            uboElements: e,
            size: s
        }
    }
    var Ki = [{
        type: "mat3x3<f32>",
        test: i => i.value.a !== void 0,
        ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
        uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
    }, {
        type: "vec4<f32>",
        test: i => i.type === "vec4<f32>" && i.size === 1 && i.value.width !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
    }, {
        type: "vec2<f32>",
        test: i => i.type === "vec2<f32>" && i.size === 1 && i.value.x !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
    }, {
        type: "vec4<f32>",
        test: i => i.type === "vec4<f32>" && i.size === 1 && i.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
    }, {
        type: "vec3<f32>",
        test: i => i.type === "vec3<f32>" && i.size === 1 && i.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
    }];
    function ng(i, e, t, r) {
        let s = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `]
          , n = 0;
        for (let o = 0; o < i.length; o++) {
            let l = i[o]
              , u = l.data.name
              , d = !1
              , f = 0;
            for (let b = 0; b < Ki.length; b++)
                if (Ki[b].test(l.data)) {
                    f = l.offset / 4,
                    s.push(`name = "${u}";`, `offset += ${f - n};`, Ki[b][e] || Ki[b].ubo),
                    d = !0;
                    break
                }
            if (!d)
                if (l.data.size > 1)
                    f = l.offset / 4,
                    s.push(t(l, f - n));
                else {
                    let b = r[l.data.type];
                    f = l.offset / 4,
                    s.push(`
                    v = uv.${u};
                    offset += ${f - n};
                    ${b};
                `)
                }
            n = f
        }
        let a = s.join(`
`);
        return new Function("uv","data","dataInt32","offset",a)
    }
    var W5 = Object.defineProperty
      , Y5 = Object.defineProperties
      , $5 = Object.getOwnPropertyDescriptors
      , Dp = Object.getOwnPropertySymbols
      , K5 = Object.prototype.hasOwnProperty
      , q5 = Object.prototype.propertyIsEnumerable
      , kp = (i, e, t) => e in i ? W5(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Z5 = (i, e) => {
        for (var t in e || (e = {}))
            K5.call(e, t) && kp(i, t, e[t]);
        if (Dp)
            for (var t of Dp(e))
                q5.call(e, t) && kp(i, t, e[t]);
        return i
    }
      , Q5 = (i, e) => Y5(i, $5(e));
    function lr(i, e) {
        return `
        for (let i = 0; i < ${i * e}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `
    }
    var ag = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": lr(3, 2),
        "mat4x2<f32>": lr(4, 2),
        "mat2x3<f32>": lr(2, 3),
        "mat4x3<f32>": lr(4, 3),
        "mat2x4<f32>": lr(2, 4),
        "mat3x4<f32>": lr(3, 4)
    }
      , J5 = Q5(Z5({}, ag), {
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
    });
    function e8(i, e) {
        let t = Math.max(sg[i.data.type] / 16, 1)
          , r = i.data.value.length / i.data.size
          , s = (4 - r % 4) % 4
          , n = i.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
        return `
        v = uv.${i.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size * t}; i++)
        {
            for(var j = 0; j < ${r}; j++)
            {
                ${n}[arrayOffset++] = v[t++];
            }
            ${s !== 0 ? `arrayOffset += ${s};` : ""}
        }
    `
    }
    function t8(i) {
        return ng(i, "uboStd40", e8, ag)
    }
    var Ca = class extends Ma {
        constructor() {
            super({
                createUboElements: V5,
                generateUboSync: t8
            })
        }
    }
    ;
    Ca.extension = {
        type: [O.WebGLSystem],
        name: "ubo"
    };
    var ih = class {
        constructor() {
            this._clearColorCache = [0, 0, 0, 0],
            this._viewPortCache = new Oe
        }
        init(e, t) {
            this._renderer = e,
            this._renderTargetSystem = t,
            e.runners.contextChange.add(this)
        }
        contextChange() {
            this._clearColorCache = [0, 0, 0, 0],
            this._viewPortCache = new Oe
        }
        copyToTexture(e, t, r, s, n) {
            let a = this._renderTargetSystem
              , o = this._renderer
              , l = a.getGpuRenderTarget(e)
              , u = o.gl;
            return this.finishRenderPass(e),
            u.bindFramebuffer(u.FRAMEBUFFER, l.resolveTargetFramebuffer),
            o.texture.bind(t, 0),
            u.copyTexSubImage2D(u.TEXTURE_2D, 0, n.x, n.y, r.x, r.y, s.width, s.height),
            t
        }
        startRenderPass(e, t=!0, r, s) {
            let n = this._renderTargetSystem
              , a = e.colorTexture
              , o = n.getGpuRenderTarget(e)
              , l = s.y;
            e.isRoot && (l = a.pixelHeight - s.height),
            e.colorTextures.forEach(f => {
                this._renderer.texture.unbind(f)
            }
            );
            let u = this._renderer.gl;
            u.bindFramebuffer(u.FRAMEBUFFER, o.framebuffer);
            let d = this._viewPortCache;
            (d.x !== s.x || d.y !== l || d.width !== s.width || d.height !== s.height) && (d.x = s.x,
            d.y = l,
            d.width = s.width,
            d.height = s.height,
            u.viewport(s.x, l, s.width, s.height)),
            !o.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(o),
            this.clear(e, t, r)
        }
        finishRenderPass(e) {
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            if (!t.msaa)
                return;
            let r = this._renderer.gl;
            r.bindFramebuffer(r.FRAMEBUFFER, t.resolveTargetFramebuffer),
            r.bindFramebuffer(r.READ_FRAMEBUFFER, t.framebuffer),
            r.blitFramebuffer(0, 0, t.width, t.height, 0, 0, t.width, t.height, r.COLOR_BUFFER_BIT, r.NEAREST),
            r.bindFramebuffer(r.FRAMEBUFFER, t.framebuffer)
        }
        initGpuRenderTarget(e) {
            let t = this._renderer.gl
              , r = new th;
            return e.colorTexture instanceof Wt ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource),
            r.framebuffer = null,
            r) : (this._initColor(e, r),
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            r)
        }
        destroyGpuRenderTarget(e) {
            let t = this._renderer.gl;
            e.framebuffer && (t.deleteFramebuffer(e.framebuffer),
            e.framebuffer = null),
            e.resolveTargetFramebuffer && (t.deleteFramebuffer(e.resolveTargetFramebuffer),
            e.resolveTargetFramebuffer = null),
            e.depthStencilRenderBuffer && (t.deleteRenderbuffer(e.depthStencilRenderBuffer),
            e.depthStencilRenderBuffer = null),
            e.msaaRenderBuffer.forEach(r => {
                t.deleteRenderbuffer(r)
            }
            ),
            e.msaaRenderBuffer = null
        }
        clear(e, t, r) {
            if (!t)
                return;
            let s = this._renderTargetSystem;
            typeof t == "boolean" && (t = t ? Rt.ALL : Rt.NONE);
            let n = this._renderer.gl;
            if (t & Rt.COLOR) {
                r != null || (r = s.defaultClearColor);
                let a = this._clearColorCache
                  , o = r;
                (a[0] !== o[0] || a[1] !== o[1] || a[2] !== o[2] || a[3] !== o[3]) && (a[0] = o[0],
                a[1] = o[1],
                a[2] = o[2],
                a[3] = o[3],
                n.clearColor(o[0], o[1], o[2], o[3]))
            }
            n.clear(t)
        }
        resizeGpuRenderTarget(e) {
            if (e.isRoot)
                return;
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            this._resizeColor(e, t),
            (e.stencil || e.depth) && this._resizeStencil(t)
        }
        _initColor(e, t) {
            let r = this._renderer
              , s = r.gl
              , n = s.createFramebuffer();
            if (t.resolveTargetFramebuffer = n,
            s.bindFramebuffer(s.FRAMEBUFFER, n),
            t.width = e.colorTexture.source.pixelWidth,
            t.height = e.colorTexture.source.pixelHeight,
            e.colorTextures.forEach( (a, o) => {
                let l = a.source;
                l.antialias && (r.context.supports.msaa ? t.msaa = !0 : _i("[RenderTexture] Antialiasing on textures is not supported in WebGL1")),
                r.texture.bindSource(l, 0);
                let u = r.texture.getGlSource(l).texture;
                s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + o, 3553, u, 0)
            }
            ),
            t.msaa) {
                let a = s.createFramebuffer();
                t.framebuffer = a,
                s.bindFramebuffer(s.FRAMEBUFFER, a),
                e.colorTextures.forEach( (o, l) => {
                    let u = s.createRenderbuffer();
                    t.msaaRenderBuffer[l] = u
                }
                )
            } else
                t.framebuffer = n;
            this._resizeColor(e, t)
        }
        _resizeColor(e, t) {
            let r = e.colorTexture.source;
            if (t.width = r.pixelWidth,
            t.height = r.pixelHeight,
            e.colorTextures.forEach( (s, n) => {
                n !== 0 && s.source.resize(r.width, r.height, r._resolution)
            }
            ),
            t.msaa) {
                let s = this._renderer
                  , n = s.gl
                  , a = t.framebuffer;
                n.bindFramebuffer(n.FRAMEBUFFER, a),
                e.colorTextures.forEach( (o, l) => {
                    let u = o.source;
                    s.texture.bindSource(u, 0);
                    let d = s.texture.getGlSource(u).internalFormat
                      , f = t.msaaRenderBuffer[l];
                    n.bindRenderbuffer(n.RENDERBUFFER, f),
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, 4, d, u.pixelWidth, u.pixelHeight),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + l, n.RENDERBUFFER, f)
                }
                )
            }
        }
        _initStencil(e) {
            if (e.framebuffer === null)
                return;
            let t = this._renderer.gl
              , r = t.createRenderbuffer();
            e.depthStencilRenderBuffer = r,
            t.bindRenderbuffer(t.RENDERBUFFER, r),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, r),
            this._resizeStencil(e)
        }
        _resizeStencil(e) {
            let t = this._renderer.gl;
            t.bindRenderbuffer(t.RENDERBUFFER, e.depthStencilRenderBuffer),
            e.msaa ? t.renderbufferStorageMultisample(t.RENDERBUFFER, 4, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? t.DEPTH24_STENCIL8 : t.DEPTH_STENCIL, e.width, e.height)
        }
        prerender(e) {
            let t = e.colorTexture.resource;
            this._renderer.context.multiView && Wt.test(t) && this._renderer.context.ensureCanvasSize(t)
        }
        postrender(e) {
            if (this._renderer.context.multiView && Wt.test(e.colorTexture.resource)) {
                let t = this._renderer.context.canvas
                  , r = e.colorTexture;
                r.context2D.drawImage(t, 0, r.pixelHeight - t.height)
            }
        }
    }
    ;
    function i8(i, e, t, r, s, n) {
        let a = n ? 1 : -1;
        return i.identity(),
        i.a = 1 / r * 2,
        i.d = a * (1 / s * 2),
        i.tx = -1 - e * i.a,
        i.ty = -a - t * i.d,
        i
    }
    var r8 = Object.defineProperty
      , Up = Object.getOwnPropertySymbols
      , s8 = Object.prototype.hasOwnProperty
      , n8 = Object.prototype.propertyIsEnumerable
      , Lp = (i, e, t) => e in i ? r8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , a8 = (i, e) => {
        for (var t in e || (e = {}))
            s8.call(e, t) && Lp(i, t, e[t]);
        if (Up)
            for (var t of Up(e))
                n8.call(e, t) && Lp(i, t, e[t]);
        return i
    }
      , fr = new Map;
    Pr.register(fr);
    function og(i, e) {
        if (!fr.has(i)) {
            let t = new Z({
                source: new Wt(a8({
                    resource: i
                }, e))
            })
              , r = () => {
                fr.get(i) === t && fr.delete(i)
            }
            ;
            t.once("destroy", r),
            t.source.once("destroy", r),
            fr.set(i, t)
        }
        return fr.get(i)
    }
    function o8(i) {
        let e = i.colorTexture.source.resource;
        return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e)
    }
    var c8 = Object.defineProperty
      , Np = Object.getOwnPropertySymbols
      , l8 = Object.prototype.hasOwnProperty
      , h8 = Object.prototype.propertyIsEnumerable
      , Xp = (i, e, t) => e in i ? c8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , jp = (i, e) => {
        for (var t in e || (e = {}))
            l8.call(e, t) && Xp(i, t, e[t]);
        if (Np)
            for (var t of Np(e))
                h8.call(e, t) && Xp(i, t, e[t]);
        return i
    }
      , cg = class lg {
        constructor(e={}) {
            if (this.uid = Le("renderTarget"),
            this.colorTextures = [],
            this.dirtyId = 0,
            this.isRoot = !1,
            this._size = new Float32Array(2),
            this._managedColorTextures = !1,
            e = jp(jp({}, lg.defaultOptions), e),
            this.stencil = e.stencil,
            this.depth = e.depth,
            this.isRoot = e.isRoot,
            typeof e.colorTextures == "number") {
                this._managedColorTextures = !0;
                for (let t = 0; t < e.colorTextures; t++)
                    this.colorTextures.push(new Xe({
                        width: e.width,
                        height: e.height,
                        resolution: e.resolution,
                        antialias: e.antialias
                    }))
            } else {
                this.colorTextures = [...e.colorTextures.map(r => r.source)];
                let t = this.colorTexture.source;
                this.resize(t.width, t.height, t._resolution)
            }
            this.colorTexture.source.on("resize", this.onSourceResize, this),
            (e.depthStencilTexture || this.stencil) && (e.depthStencilTexture instanceof Z || e.depthStencilTexture instanceof Xe ? this.depthStencilTexture = e.depthStencilTexture.source : this.ensureDepthStencilTexture())
        }
        get size() {
            let e = this._size;
            return e[0] = this.pixelWidth,
            e[1] = this.pixelHeight,
            e
        }
        get width() {
            return this.colorTexture.source.width
        }
        get height() {
            return this.colorTexture.source.height
        }
        get pixelWidth() {
            return this.colorTexture.source.pixelWidth
        }
        get pixelHeight() {
            return this.colorTexture.source.pixelHeight
        }
        get resolution() {
            return this.colorTexture.source._resolution
        }
        get colorTexture() {
            return this.colorTextures[0]
        }
        onSourceResize(e) {
            this.resize(e.width, e.height, e._resolution, !0)
        }
        ensureDepthStencilTexture() {
            this.depthStencilTexture || (this.depthStencilTexture = new Xe({
                width: this.width,
                height: this.height,
                resolution: this.resolution,
                format: "depth24plus-stencil8",
                autoGenerateMipmaps: !1,
                antialias: !1,
                mipLevelCount: 1
            }))
        }
        resize(e, t, r=this.resolution, s=!1) {
            this.dirtyId++,
            this.colorTextures.forEach( (n, a) => {
                s && a === 0 || n.source.resize(e, t, r)
            }
            ),
            this.depthStencilTexture && this.depthStencilTexture.source.resize(e, t, r)
        }
        destroy() {
            this.colorTexture.source.off("resize", this.onSourceResize, this),
            this._managedColorTextures && this.colorTextures.forEach(e => {
                e.destroy()
            }
            ),
            this.depthStencilTexture && (this.depthStencilTexture.destroy(),
            delete this.depthStencilTexture)
        }
    }
    ;
    cg.defaultOptions = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: !1,
        depth: !1,
        antialias: !1,
        isRoot: !1
    };
    var rh = cg
      , Oa = class {
        constructor(e) {
            this.rootViewPort = new Oe,
            this.viewport = new Oe,
            this.onRenderTargetChange = new ta("onRenderTargetChange"),
            this.projectionMatrix = new ce,
            this.defaultClearColor = [0, 0, 0, 0],
            this._renderSurfaceToRenderTargetHash = new Map,
            this._gpuRenderTargetHash = Object.create(null),
            this._renderTargetStack = [],
            this._renderer = e,
            e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash")
        }
        finishRenderPass() {
            this.adaptor.finishRenderPass(this.renderTarget)
        }
        renderStart({target: e, clear: t, clearColor: r, frame: s}) {
            var n, a;
            this._renderTargetStack.length = 0,
            this.push(e, t, r, s),
            this.rootViewPort.copyFrom(this.viewport),
            this.rootRenderTarget = this.renderTarget,
            this.renderingToScreen = o8(this.rootRenderTarget),
            (a = (n = this.adaptor).prerender) == null || a.call(n, this.rootRenderTarget)
        }
        postrender() {
            var e, t;
            (t = (e = this.adaptor).postrender) == null || t.call(e, this.rootRenderTarget)
        }
        bind(e, t=!0, r, s) {
            let n = this.getRenderTarget(e)
              , a = this.renderTarget !== n;
            this.renderTarget = n,
            this.renderSurface = e;
            let o = this.getGpuRenderTarget(n);
            (n.pixelWidth !== o.width || n.pixelHeight !== o.height) && (this.adaptor.resizeGpuRenderTarget(n),
            o.width = n.pixelWidth,
            o.height = n.pixelHeight);
            let l = n.colorTexture
              , u = this.viewport
              , d = l.pixelWidth
              , f = l.pixelHeight;
            if (!s && e instanceof Z && (s = e.frame),
            s) {
                let b = l._resolution;
                u.x = s.x * b + .5 | 0,
                u.y = s.y * b + .5 | 0,
                u.width = s.width * b + .5 | 0,
                u.height = s.height * b + .5 | 0
            } else
                u.x = 0,
                u.y = 0,
                u.width = d,
                u.height = f;
            return i8(this.projectionMatrix, 0, 0, u.width / l.resolution, u.height / l.resolution, !n.isRoot),
            this.adaptor.startRenderPass(n, t, r, u),
            a && this.onRenderTargetChange.emit(n),
            n
        }
        clear(e, t=Rt.ALL, r) {
            t && (e && (e = this.getRenderTarget(e)),
            this.adaptor.clear(e || this.renderTarget, t, r, this.viewport))
        }
        contextChange() {
            this._gpuRenderTargetHash = Object.create(null)
        }
        push(e, t=Rt.ALL, r, s) {
            let n = this.bind(e, t, r, s);
            return this._renderTargetStack.push({
                renderTarget: n,
                frame: s
            }),
            n
        }
        pop() {
            this._renderTargetStack.pop();
            let e = this._renderTargetStack[this._renderTargetStack.length - 1];
            this.bind(e.renderTarget, !1, null, e.frame)
        }
        getRenderTarget(e) {
            var t;
            return e.isTexture && (e = e.source),
            (t = this._renderSurfaceToRenderTargetHash.get(e)) != null ? t : this._initRenderTarget(e)
        }
        copyToTexture(e, t, r, s, n) {
            r.x < 0 && (s.width += r.x,
            n.x -= r.x,
            r.x = 0),
            r.y < 0 && (s.height += r.y,
            n.y -= r.y,
            r.y = 0);
            let {pixelWidth: a, pixelHeight: o} = e;
            return s.width = Math.min(s.width, a - r.x),
            s.height = Math.min(s.height, o - r.y),
            this.adaptor.copyToTexture(e, t, r, s, n)
        }
        ensureDepthStencil() {
            this.renderTarget.stencil || (this.renderTarget.stencil = !0,
            this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport))
        }
        destroy() {
            this._renderer = null,
            this._renderSurfaceToRenderTargetHash.forEach( (e, t) => {
                e !== t && e.destroy()
            }
            ),
            this._renderSurfaceToRenderTargetHash.clear(),
            this._gpuRenderTargetHash = Object.create(null)
        }
        _initRenderTarget(e) {
            let t = null;
            return Wt.test(e) && (e = og(e).source),
            e instanceof rh ? t = e : e instanceof Xe && (t = new rh({
                colorTextures: [e]
            }),
            e.source instanceof Wt && (t.isRoot = !0),
            e.once("destroy", () => {
                t.destroy(),
                this._renderSurfaceToRenderTargetHash.delete(e);
                let r = this._gpuRenderTargetHash[t.uid];
                r && (this._gpuRenderTargetHash[t.uid] = null,
                this.adaptor.destroyGpuRenderTarget(r))
            }
            )),
            this._renderSurfaceToRenderTargetHash.set(e, t),
            t
        }
        getGpuRenderTarget(e) {
            return this._gpuRenderTargetHash[e.uid] || (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e))
        }
        resetState() {
            this.renderTarget = null,
            this.renderSurface = null
        }
    }
      , Ia = class extends Oa {
        constructor(e) {
            super(e),
            this.adaptor = new ih,
            this.adaptor.init(e, this)
        }
    }
    ;
    Ia.extension = {
        type: [O.WebGLSystem],
        name: "renderTarget"
    };
    var ws = class extends Ot {
        constructor({buffer: e, offset: t, size: r}) {
            super(),
            this.uid = Le("buffer"),
            this._resourceType = "bufferResource",
            this._touched = 0,
            this._resourceId = Le("resource"),
            this._bufferResource = !0,
            this.destroyed = !1,
            this.buffer = e,
            this.offset = t | 0,
            this.size = r,
            this.buffer.on("change", this.onBufferChange, this)
        }
        onBufferChange() {
            this._resourceId = Le("resource"),
            this.emit("change", this)
        }
        destroy(e=!1) {
            this.destroyed = !0,
            e && this.buffer.destroy(),
            this.emit("change", this),
            this.buffer = null
        }
    }
    ;
    function u8(i, e) {
        let t = []
          , r = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `]
          , s = !1
          , n = 0
          , a = e._getProgramData(i.glProgram);
        for (let l in i.groups) {
            let u = i.groups[l];
            t.push(`
            resources = g[${l}].resources;
        `);
            for (let d in u.resources) {
                let f = u.resources[d];
                if (f instanceof ot)
                    if (f.ubo) {
                        let b = i._uniformBindMap[l][Number(d)];
                        t.push(`
                        sS.bindUniformBlock(
                            resources[${d}],
                            '${b}',
                            ${i.glProgram._uniformBlockData[b].index}
                        );
                    `)
                    } else
                        t.push(`
                        ugS.updateUniformGroup(resources[${d}], p, sD);
                    `);
                else if (f instanceof ws) {
                    let b = i._uniformBindMap[l][Number(d)];
                    t.push(`
                    sS.bindUniformBlock(
                        resources[${d}],
                        '${b}',
                        ${i.glProgram._uniformBlockData[b].index}
                    );
                `)
                } else if (f instanceof Xe) {
                    let b = i._uniformBindMap[l][d]
                      , m = a.uniformData[b];
                    m && (s || (s = !0,
                    r.push(`
                        var tS = r.texture;
                        `)),
                    e._gl.uniform1i(m.location, n),
                    t.push(`
                        tS.bind(resources[${d}], ${n});
                    `),
                    n++)
                }
            }
        }
        let o = [...r, ...t].join(`
`);
        return new Function("r","s","sD",o)
    }
    var sh = class {
        constructor(e, t) {
            this.program = e,
            this.uniformData = t,
            this.uniformGroups = {},
            this.uniformDirtyGroups = {},
            this.uniformBlockBindings = {}
        }
        destroy() {
            this.uniformData = null,
            this.uniformGroups = null,
            this.uniformDirtyGroups = null,
            this.uniformBlockBindings = null,
            this.program = null
        }
    }
    ;
    function Hp(i, e, t) {
        let r = i.createShader(e);
        return i.shaderSource(r, t),
        i.compileShader(r),
        r
    }
    function Sc(i) {
        let e = new Array(i);
        for (let t = 0; t < e.length; t++)
            e[t] = !1;
        return e
    }
    function hg(i, e) {
        switch (i) {
        case "float":
            return 0;
        case "vec2":
            return new Float32Array(2 * e);
        case "vec3":
            return new Float32Array(3 * e);
        case "vec4":
            return new Float32Array(4 * e);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
            return 0;
        case "ivec2":
            return new Int32Array(2 * e);
        case "ivec3":
            return new Int32Array(3 * e);
        case "ivec4":
            return new Int32Array(4 * e);
        case "uvec2":
            return new Uint32Array(2 * e);
        case "uvec3":
            return new Uint32Array(3 * e);
        case "uvec4":
            return new Uint32Array(4 * e);
        case "bool":
            return !1;
        case "bvec2":
            return Sc(2 * e);
        case "bvec3":
            return Sc(3 * e);
        case "bvec4":
            return Sc(4 * e);
        case "mat2":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
        }
        return null
    }
    var nn = null
      , zp = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    }
      , d8 = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
    };
    function ug(i, e) {
        if (!nn) {
            let t = Object.keys(zp);
            nn = {};
            for (let r = 0; r < t.length; ++r) {
                let s = t[r];
                nn[i[s]] = zp[s]
            }
        }
        return nn[e]
    }
    function f8(i, e) {
        let t = ug(i, e);
        return d8[t] || "float32"
    }
    function p8(i, e, t=!1) {
        let r = {}
          , s = e.getProgramParameter(i, e.ACTIVE_ATTRIBUTES);
        for (let a = 0; a < s; a++) {
            let o = e.getActiveAttrib(i, a);
            if (o.name.startsWith("gl_"))
                continue;
            let l = f8(e, o.type);
            r[o.name] = {
                location: 0,
                format: l,
                stride: Mi(l).stride,
                offset: 0,
                instance: !1,
                start: 0
            }
        }
        let n = Object.keys(r);
        if (t) {
            n.sort( (a, o) => a > o ? 1 : -1);
            for (let a = 0; a < n.length; a++)
                r[n[a]].location = a,
                e.bindAttribLocation(i, a, n[a]);
            e.linkProgram(i)
        } else
            for (let a = 0; a < n.length; a++)
                r[n[a]].location = e.getAttribLocation(i, n[a]);
        return r
    }
    function b8(i, e) {
        if (!e.ACTIVE_UNIFORM_BLOCKS)
            return {};
        let t = {}
          , r = e.getProgramParameter(i, e.ACTIVE_UNIFORM_BLOCKS);
        for (let s = 0; s < r; s++) {
            let n = e.getActiveUniformBlockName(i, s)
              , a = e.getUniformBlockIndex(i, n)
              , o = e.getActiveUniformBlockParameter(i, s, e.UNIFORM_BLOCK_DATA_SIZE);
            t[n] = {
                name: n,
                index: a,
                size: o
            }
        }
        return t
    }
    function m8(i, e) {
        let t = {}
          , r = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
        for (let s = 0; s < r; s++) {
            let n = e.getActiveUniform(i, s)
              , a = n.name.replace(/\[.*?\]$/, "")
              , o = !!n.name.match(/\[.*?\]$/)
              , l = ug(e, n.type);
            t[a] = {
                name: a,
                index: s,
                type: l,
                size: n.size,
                isArray: o,
                value: hg(l, n.size)
            }
        }
        return t
    }
    function Vp(i, e) {
        let t = i.getShaderSource(e).split(`
`).map( (u, d) => `${d}: ${u}`)
          , r = i.getShaderInfoLog(e)
          , s = r.split(`
`)
          , n = {}
          , a = s.map(u => parseFloat(u.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(u => u && !n[u] ? (n[u] = !0,
        !0) : !1)
          , o = [""];
        a.forEach(u => {
            t[u - 1] = `%c${t[u - 1]}%c`,
            o.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
        }
        );
        let l = t.join(`
`);
        o[0] = l
    }
    function g8(i, e, t, r) {
        i.getProgramParameter(e, i.LINK_STATUS) || (i.getShaderParameter(t, i.COMPILE_STATUS) || Vp(i, t),
        i.getShaderParameter(r, i.COMPILE_STATUS) || Vp(i, r),
        i.getProgramInfoLog(e))
    }
    function _8(i, e) {
        let t = Hp(i, i.VERTEX_SHADER, e.vertex)
          , r = Hp(i, i.FRAGMENT_SHADER, e.fragment)
          , s = i.createProgram();
        i.attachShader(s, t),
        i.attachShader(s, r);
        let n = e.transformFeedbackVaryings;
        n && (typeof i.transformFeedbackVaryings != "function" || i.transformFeedbackVaryings(s, n.names, n.bufferMode === "separate" ? i.SEPARATE_ATTRIBS : i.INTERLEAVED_ATTRIBS)),
        i.linkProgram(s),
        i.getProgramParameter(s, i.LINK_STATUS) || g8(i, s, t, r),
        e._attributeData = p8(s, i, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)),
        e._uniformData = m8(s, i),
        e._uniformBlockData = b8(s, i),
        i.deleteShader(t),
        i.deleteShader(r);
        let a = {};
        for (let o in e._uniformData) {
            let l = e._uniformData[o];
            a[o] = {
                location: i.getUniformLocation(s, o),
                value: hg(l.type, l.size)
            }
        }
        return new sh(s,a)
    }
    var an = {
        textureCount: 0,
        blockIndex: 0
    }
      , Ga = class {
        constructor(e) {
            this._activeProgram = null,
            this._programDataHash = Object.create(null),
            this._shaderSyncFunctions = Object.create(null),
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_programDataHash")
        }
        contextChange(e) {
            this._gl = e,
            this._programDataHash = Object.create(null),
            this._shaderSyncFunctions = Object.create(null),
            this._activeProgram = null
        }
        bind(e, t) {
            if (this._setProgram(e.glProgram),
            t)
                return;
            an.textureCount = 0,
            an.blockIndex = 0;
            let r = this._shaderSyncFunctions[e.glProgram._key];
            r || (r = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)),
            this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings),
            r(this._renderer, e, an)
        }
        updateUniformGroup(e) {
            this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, an)
        }
        bindUniformBlock(e, t, r=0) {
            let s = this._renderer.buffer
              , n = this._getProgramData(this._activeProgram)
              , a = e._bufferResource;
            a || this._renderer.ubo.updateUniformGroup(e);
            let o = e.buffer
              , l = s.updateBuffer(o)
              , u = s.freeLocationForBufferBase(l);
            if (a) {
                let {offset: f, size: b} = e;
                f === 0 && b === o.data.byteLength ? s.bindBufferBase(l, u) : s.bindBufferRange(l, u, f)
            } else
                s.getLastBindBaseLocation(l) !== u && s.bindBufferBase(l, u);
            let d = this._activeProgram._uniformBlockData[t].index;
            n.uniformBlockBindings[r] !== u && (n.uniformBlockBindings[r] = u,
            this._renderer.gl.uniformBlockBinding(n.program, d, u))
        }
        _setProgram(e) {
            if (this._activeProgram === e)
                return;
            this._activeProgram = e;
            let t = this._getProgramData(e);
            this._gl.useProgram(t.program)
        }
        _getProgramData(e) {
            return this._programDataHash[e._key] || this._createProgramData(e)
        }
        _createProgramData(e) {
            let t = e._key;
            return this._programDataHash[t] = _8(this._gl, e),
            this._programDataHash[t]
        }
        destroy() {
            for (let e of Object.keys(this._programDataHash))
                this._programDataHash[e].destroy(),
                this._programDataHash[e] = null;
            this._programDataHash = null,
            this._shaderSyncFunctions = null,
            this._activeProgram = null,
            this._renderer = null,
            this._gl = null
        }
        _generateShaderSync(e, t) {
            return u8(e, t)
        }
        resetState() {
            this._activeProgram = null
        }
    }
    ;
    Ga.extension = {
        type: [O.WebGLSystem],
        name: "shader"
    };
    var x8 = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
    }
      , y8 = {
        f32: "gl.uniform1fv(location, v);",
        "vec2<f32>": "gl.uniform2fv(location, v);",
        "vec3<f32>": "gl.uniform3fv(location, v);",
        "vec4<f32>": "gl.uniform4fv(location, v);",
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
        i32: "gl.uniform1iv(location, v);",
        "vec2<i32>": "gl.uniform2iv(location, v);",
        "vec3<i32>": "gl.uniform3iv(location, v);",
        "vec4<i32>": "gl.uniform4iv(location, v);",
        u32: "gl.uniform1iv(location, v);",
        "vec2<u32>": "gl.uniform2iv(location, v);",
        "vec3<u32>": "gl.uniform3iv(location, v);",
        "vec4<u32>": "gl.uniform4iv(location, v);",
        bool: "gl.uniform1iv(location, v);",
        "vec2<bool>": "gl.uniform2iv(location, v);",
        "vec3<bool>": "gl.uniform3iv(location, v);",
        "vec4<bool>": "gl.uniform4iv(location, v);"
    };
    function v8(i, e) {
        let t = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
        for (let r in i.uniforms) {
            if (!e[r]) {
                i.uniforms[r]instanceof ot ? i.uniforms[r].ubo ? t.push(`
                        renderer.shader.bindUniformBlock(uv.${r}, "${r}");
                    `) : t.push(`
                        renderer.shader.updateUniformGroup(uv.${r});
                    `) : i.uniforms[r]instanceof ws && t.push(`
                        renderer.shader.bindBufferResource(uv.${r}, "${r}");
                    `);
                continue
            }
            let s = i.uniformStructures[r]
              , n = !1;
            for (let a = 0; a < Ki.length; a++) {
                let o = Ki[a];
                if (s.type === o.type && o.test(s)) {
                    t.push(`name = "${r}";`, Ki[a].uniform),
                    n = !0;
                    break
                }
            }
            if (!n) {
                let a = (s.size === 1 ? x8 : y8)[s.type].replace("location", `ud["${r}"].location`);
                t.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${a};`)
            }
        }
        return new Function("ud","uv","renderer","syncData",t.join(`
`))
    }
    var Ba = class {
        constructor(e) {
            this._cache = {},
            this._uniformGroupSyncHash = {},
            this._renderer = e,
            this.gl = null,
            this._cache = {}
        }
        contextChange(e) {
            this.gl = e
        }
        updateUniformGroup(e, t, r) {
            let s = this._renderer.shader._getProgramData(t);
            (!e.isStatic || e._dirtyId !== s.uniformDirtyGroups[e.uid]) && (s.uniformDirtyGroups[e.uid] = e._dirtyId,
            this._getUniformSyncFunction(e, t)(s.uniformData, e.uniforms, this._renderer, r))
        }
        _getUniformSyncFunction(e, t) {
            var r;
            return ((r = this._uniformGroupSyncHash[e._signature]) == null ? void 0 : r[t._key]) || this._createUniformSyncFunction(e, t)
        }
        _createUniformSyncFunction(e, t) {
            let r = this._uniformGroupSyncHash[e._signature] || (this._uniformGroupSyncHash[e._signature] = {})
              , s = this._getSignature(e, t._uniformData, "u");
            return this._cache[s] || (this._cache[s] = this._generateUniformsSync(e, t._uniformData)),
            r[t._key] = this._cache[s],
            r[t._key]
        }
        _generateUniformsSync(e, t) {
            return v8(e, t)
        }
        _getSignature(e, t, r) {
            let s = e.uniforms
              , n = [`${r}-`];
            for (let a in s)
                n.push(a),
                t[a] && n.push(t[a].type);
            return n.join("-")
        }
        destroy() {
            this._renderer = null,
            this._cache = null
        }
    }
    ;
    Ba.extension = {
        type: [O.WebGLSystem],
        name: "uniformGroup"
    };
    function T8(i) {
        let e = {};
        if (e.normal = [i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e.add = [i.ONE, i.ONE],
        e.multiply = [i.DST_COLOR, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e.screen = [i.ONE, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e.none = [0, 0],
        e["normal-npm"] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e["add-npm"] = [i.SRC_ALPHA, i.ONE, i.ONE, i.ONE],
        e["screen-npm"] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA],
        e.erase = [i.ZERO, i.ONE_MINUS_SRC_ALPHA],
        !(i instanceof ye.get().getWebGLRenderingContext()))
            e.min = [i.ONE, i.ONE, i.ONE, i.ONE, i.MIN, i.MIN],
            e.max = [i.ONE, i.ONE, i.ONE, i.ONE, i.MAX, i.MAX];
        else {
            let t = i.getExtension("EXT_blend_minmax");
            t && (e.min = [i.ONE, i.ONE, i.ONE, i.ONE, t.MIN_EXT, t.MIN_EXT],
            e.max = [i.ONE, i.ONE, i.ONE, i.ONE, t.MAX_EXT, t.MAX_EXT])
        }
        return e
    }
    var S8 = 0
      , w8 = 1
      , A8 = 2
      , E8 = 3
      , P8 = 4
      , R8 = 5
      , dg = class nh {
        constructor(e) {
            this._invertFrontFace = !1,
            this.gl = null,
            this.stateId = 0,
            this.polygonOffset = 0,
            this.blendMode = "none",
            this._blendEq = !1,
            this.map = [],
            this.map[S8] = this.setBlend,
            this.map[w8] = this.setOffset,
            this.map[A8] = this.setCullFace,
            this.map[E8] = this.setDepthTest,
            this.map[P8] = this.setFrontFace,
            this.map[R8] = this.setDepthMask,
            this.checks = [],
            this.defaultState = Ut.for2d(),
            e.renderTarget.onRenderTargetChange.add(this)
        }
        onRenderTargetChange(e) {
            this._invertFrontFace = !e.isRoot,
            this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0
        }
        contextChange(e) {
            this.gl = e,
            this.blendModesMap = T8(e),
            this.resetState()
        }
        set(e) {
            if (e || (e = this.defaultState),
            this.stateId !== e.data) {
                let t = this.stateId ^ e.data
                  , r = 0;
                for (; t; )
                    t & 1 && this.map[r].call(this, !!(e.data & 1 << r)),
                    t >>= 1,
                    r++;
                this.stateId = e.data
            }
            for (let t = 0; t < this.checks.length; t++)
                this.checks[t](this, e)
        }
        forceState(e) {
            e || (e = this.defaultState);
            for (let t = 0; t < this.map.length; t++)
                this.map[t].call(this, !!(e.data & 1 << t));
            for (let t = 0; t < this.checks.length; t++)
                this.checks[t](this, e);
            this.stateId = e.data
        }
        setBlend(e) {
            this._updateCheck(nh._checkBlendMode, e),
            this.gl[e ? "enable" : "disable"](this.gl.BLEND)
        }
        setOffset(e) {
            this._updateCheck(nh._checkPolygonOffset, e),
            this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
        }
        setDepthMask(e) {
            this.gl.depthMask(e)
        }
        setCullFace(e) {
            this._cullFace = e,
            this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE),
            this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace)
        }
        setFrontFace(e) {
            this._frontFace = e,
            this._frontFaceDirty = !1;
            let t = this._invertFrontFace ? !e : e;
            this._glFrontFace !== t && (this._glFrontFace = t,
            this.gl.frontFace(this.gl[t ? "CW" : "CCW"]))
        }
        setBlendMode(e) {
            if (this.blendModesMap[e] || (e = "normal"),
            e === this.blendMode)
                return;
            this.blendMode = e;
            let t = this.blendModesMap[e]
              , r = this.gl;
            t.length === 2 ? r.blendFunc(t[0], t[1]) : r.blendFuncSeparate(t[0], t[1], t[2], t[3]),
            t.length === 6 ? (this._blendEq = !0,
            r.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1,
            r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
        }
        setPolygonOffset(e, t) {
            this.gl.polygonOffset(e, t)
        }
        resetState() {
            this._glFrontFace = !1,
            this._frontFace = !1,
            this._cullFace = !1,
            this._frontFaceDirty = !1,
            this._invertFrontFace = !1,
            this.gl.frontFace(this.gl.CCW),
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
            this.forceState(this.defaultState),
            this._blendEq = !0,
            this.blendMode = "",
            this.setBlendMode("normal")
        }
        _updateCheck(e, t) {
            let r = this.checks.indexOf(e);
            t && r === -1 ? this.checks.push(e) : !t && r !== -1 && this.checks.splice(r, 1)
        }
        static _checkBlendMode(e, t) {
            e.setBlendMode(t.blendMode)
        }
        static _checkPolygonOffset(e, t) {
            e.setPolygonOffset(1, t.polygonOffset)
        }
        destroy() {
            this.gl = null,
            this.checks.length = 0
        }
    }
    ;
    dg.extension = {
        type: [O.WebGLSystem],
        name: "state"
    };
    var M8 = dg
      , ah = class {
        constructor(e) {
            this.target = ig.TEXTURE_2D,
            this.texture = e,
            this.width = -1,
            this.height = -1,
            this.type = Ce.UNSIGNED_BYTE,
            this.internalFormat = Jl.RGBA,
            this.format = Jl.RGBA,
            this.samplerType = 0
        }
    }
      , C8 = {
        id: "buffer",
        upload(i, e, t) {
            e.width === i.width || e.height === i.height ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, i.width, i.height, e.format, e.type, i.resource) : t.texImage2D(e.target, 0, e.internalFormat, i.width, i.height, 0, e.format, e.type, i.resource),
            e.width = i.width,
            e.height = i.height
        }
    }
      , O8 = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0
    }
      , I8 = {
        id: "compressed",
        upload(i, e, t) {
            t.pixelStorei(t.UNPACK_ALIGNMENT, 4);
            let r = i.pixelWidth
              , s = i.pixelHeight
              , n = !!O8[i.format];
            for (let a = 0; a < i.resource.length; a++) {
                let o = i.resource[a];
                n ? t.compressedTexImage2D(t.TEXTURE_2D, a, e.internalFormat, r, s, 0, o) : t.texImage2D(t.TEXTURE_2D, a, e.internalFormat, r, s, 0, e.format, e.type, o),
                r = Math.max(r >> 1, 1),
                s = Math.max(s >> 1, 1)
            }
        }
    }
      , fg = {
        id: "image",
        upload(i, e, t, r) {
            let s = e.width
              , n = e.height
              , a = i.pixelWidth
              , o = i.pixelHeight
              , l = i.resourceWidth
              , u = i.resourceHeight;
            l < a || u < o ? ((s !== a || n !== o) && t.texImage2D(e.target, 0, e.internalFormat, a, o, 0, e.format, e.type, null),
            r === 2 ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, l, u, e.format, e.type, i.resource) : t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource)) : s === a && n === o ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource) : r === 2 ? t.texImage2D(e.target, 0, e.internalFormat, a, o, 0, e.format, e.type, i.resource) : t.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, i.resource),
            e.width = a,
            e.height = o
        }
    }
      , G8 = {
        id: "video",
        upload(i, e, t, r) {
            if (!i.isValid) {
                t.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null);
                return
            }
            fg.upload(i, e, t, r)
        }
    }
      , Wp = {
        linear: 9729,
        nearest: 9728
    }
      , B8 = {
        linear: {
            linear: 9987,
            nearest: 9985
        },
        nearest: {
            linear: 9986,
            nearest: 9984
        }
    }
      , wc = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
    }
      , F8 = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
    };
    function Yp(i, e, t, r, s, n, a, o) {
        let l = n;
        if (!o || i.addressModeU !== "repeat" || i.addressModeV !== "repeat" || i.addressModeW !== "repeat") {
            let u = wc[a ? "clamp-to-edge" : i.addressModeU]
              , d = wc[a ? "clamp-to-edge" : i.addressModeV]
              , f = wc[a ? "clamp-to-edge" : i.addressModeW];
            e[s](l, e.TEXTURE_WRAP_S, u),
            e[s](l, e.TEXTURE_WRAP_T, d),
            e.TEXTURE_WRAP_R && e[s](l, e.TEXTURE_WRAP_R, f)
        }
        if ((!o || i.magFilter !== "linear") && e[s](l, e.TEXTURE_MAG_FILTER, Wp[i.magFilter]),
        t) {
            if (!o || i.mipmapFilter !== "linear") {
                let u = B8[i.minFilter][i.mipmapFilter];
                e[s](l, e.TEXTURE_MIN_FILTER, u)
            }
        } else
            e[s](l, e.TEXTURE_MIN_FILTER, Wp[i.minFilter]);
        if (r && i.maxAnisotropy > 1) {
            let u = Math.min(i.maxAnisotropy, e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            e[s](l, r.TEXTURE_MAX_ANISOTROPY_EXT, u)
        }
        i.compare && e[s](l, e.TEXTURE_COMPARE_FUNC, F8[i.compare])
    }
    function D8(i) {
        return {
            r8unorm: i.RED,
            r8snorm: i.RED,
            r8uint: i.RED,
            r8sint: i.RED,
            r16uint: i.RED,
            r16sint: i.RED,
            r16float: i.RED,
            rg8unorm: i.RG,
            rg8snorm: i.RG,
            rg8uint: i.RG,
            rg8sint: i.RG,
            r32uint: i.RED,
            r32sint: i.RED,
            r32float: i.RED,
            rg16uint: i.RG,
            rg16sint: i.RG,
            rg16float: i.RG,
            rgba8unorm: i.RGBA,
            "rgba8unorm-srgb": i.RGBA,
            rgba8snorm: i.RGBA,
            rgba8uint: i.RGBA,
            rgba8sint: i.RGBA,
            bgra8unorm: i.RGBA,
            "bgra8unorm-srgb": i.RGBA,
            rgb9e5ufloat: i.RGB,
            rgb10a2unorm: i.RGBA,
            rg11b10ufloat: i.RGB,
            rg32uint: i.RG,
            rg32sint: i.RG,
            rg32float: i.RG,
            rgba16uint: i.RGBA,
            rgba16sint: i.RGBA,
            rgba16float: i.RGBA,
            rgba32uint: i.RGBA,
            rgba32sint: i.RGBA,
            rgba32float: i.RGBA,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT,
            depth24plus: i.DEPTH_COMPONENT,
            "depth24plus-stencil8": i.DEPTH_STENCIL,
            depth32float: i.DEPTH_COMPONENT,
            "depth32float-stencil8": i.DEPTH_STENCIL
        }
    }
    var k8 = Object.defineProperty
      , U8 = Object.defineProperties
      , L8 = Object.getOwnPropertyDescriptors
      , $p = Object.getOwnPropertySymbols
      , N8 = Object.prototype.hasOwnProperty
      , X8 = Object.prototype.propertyIsEnumerable
      , Kp = (i, e, t) => e in i ? k8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Xi = (i, e) => {
        for (var t in e || (e = {}))
            N8.call(e, t) && Kp(i, t, e[t]);
        if ($p)
            for (var t of $p(e))
                X8.call(e, t) && Kp(i, t, e[t]);
        return i
    }
      , j8 = (i, e) => U8(i, L8(e));
    function H8(i, e) {
        let t = {}
          , r = i.RGBA;
        return i instanceof ye.get().getWebGLRenderingContext() ? e.srgb && (t = {
            "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
            "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT
        }) : (t = {
            "rgba8unorm-srgb": i.SRGB8_ALPHA8,
            "bgra8unorm-srgb": i.SRGB8_ALPHA8
        },
        r = i.RGBA8),
        Xi(Xi(Xi(Xi(Xi(Xi(j8(Xi({
            r8unorm: i.R8,
            r8snorm: i.R8_SNORM,
            r8uint: i.R8UI,
            r8sint: i.R8I,
            r16uint: i.R16UI,
            r16sint: i.R16I,
            r16float: i.R16F,
            rg8unorm: i.RG8,
            rg8snorm: i.RG8_SNORM,
            rg8uint: i.RG8UI,
            rg8sint: i.RG8I,
            r32uint: i.R32UI,
            r32sint: i.R32I,
            r32float: i.R32F,
            rg16uint: i.RG16UI,
            rg16sint: i.RG16I,
            rg16float: i.RG16F,
            rgba8unorm: i.RGBA
        }, t), {
            rgba8snorm: i.RGBA8_SNORM,
            rgba8uint: i.RGBA8UI,
            rgba8sint: i.RGBA8I,
            bgra8unorm: r,
            rgb9e5ufloat: i.RGB9_E5,
            rgb10a2unorm: i.RGB10_A2,
            rg11b10ufloat: i.R11F_G11F_B10F,
            rg32uint: i.RG32UI,
            rg32sint: i.RG32I,
            rg32float: i.RG32F,
            rgba16uint: i.RGBA16UI,
            rgba16sint: i.RGBA16I,
            rgba16float: i.RGBA16F,
            rgba32uint: i.RGBA32UI,
            rgba32sint: i.RGBA32I,
            rgba32float: i.RGBA32F,
            stencil8: i.STENCIL_INDEX8,
            depth16unorm: i.DEPTH_COMPONENT16,
            depth24plus: i.DEPTH_COMPONENT24,
            "depth24plus-stencil8": i.DEPTH24_STENCIL8,
            depth32float: i.DEPTH_COMPONENT32F,
            "depth32float-stencil8": i.DEPTH32F_STENCIL8
        }), e.s3tc ? {
            "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } : {}), e.s3tc_sRGB ? {
            "bc1-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } : {}), e.rgtc ? {
            "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
            "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
            "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
            "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
        } : {}), e.bptc ? {
            "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
            "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
            "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
            "bc7-rgba-unorm-srgb": e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
        } : {}), e.etc ? {
            "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
            "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
            "etc2-rgb8a1unorm": e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgb8a1unorm-srgb": e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
            "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
            "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
            "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC
        } : {}), e.astc ? {
            "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
            "astc-4x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
            "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
            "astc-5x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
            "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
            "astc-5x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
            "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
            "astc-6x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
            "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
            "astc-6x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
            "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
            "astc-8x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
            "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
            "astc-8x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
            "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
            "astc-8x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
            "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
            "astc-10x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
            "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
            "astc-10x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
            "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
            "astc-10x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
            "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
            "astc-10x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
            "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
            "astc-12x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
            "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
            "astc-12x12-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
        } : {})
    }
    function z8(i) {
        return {
            r8unorm: i.UNSIGNED_BYTE,
            r8snorm: i.BYTE,
            r8uint: i.UNSIGNED_BYTE,
            r8sint: i.BYTE,
            r16uint: i.UNSIGNED_SHORT,
            r16sint: i.SHORT,
            r16float: i.HALF_FLOAT,
            rg8unorm: i.UNSIGNED_BYTE,
            rg8snorm: i.BYTE,
            rg8uint: i.UNSIGNED_BYTE,
            rg8sint: i.BYTE,
            r32uint: i.UNSIGNED_INT,
            r32sint: i.INT,
            r32float: i.FLOAT,
            rg16uint: i.UNSIGNED_SHORT,
            rg16sint: i.SHORT,
            rg16float: i.HALF_FLOAT,
            rgba8unorm: i.UNSIGNED_BYTE,
            "rgba8unorm-srgb": i.UNSIGNED_BYTE,
            rgba8snorm: i.BYTE,
            rgba8uint: i.UNSIGNED_BYTE,
            rgba8sint: i.BYTE,
            bgra8unorm: i.UNSIGNED_BYTE,
            "bgra8unorm-srgb": i.UNSIGNED_BYTE,
            rgb9e5ufloat: i.UNSIGNED_INT_5_9_9_9_REV,
            rgb10a2unorm: i.UNSIGNED_INT_2_10_10_10_REV,
            rg11b10ufloat: i.UNSIGNED_INT_10F_11F_11F_REV,
            rg32uint: i.UNSIGNED_INT,
            rg32sint: i.INT,
            rg32float: i.FLOAT,
            rgba16uint: i.UNSIGNED_SHORT,
            rgba16sint: i.SHORT,
            rgba16float: i.HALF_FLOAT,
            rgba32uint: i.UNSIGNED_INT,
            rgba32sint: i.INT,
            rgba32float: i.FLOAT,
            stencil8: i.UNSIGNED_BYTE,
            depth16unorm: i.UNSIGNED_SHORT,
            depth24plus: i.UNSIGNED_INT,
            "depth24plus-stencil8": i.UNSIGNED_INT_24_8,
            depth32float: i.FLOAT,
            "depth32float-stencil8": i.FLOAT_32_UNSIGNED_INT_24_8_REV
        }
    }
    var V8 = 4
      , Fa = class {
        constructor(e) {
            this.managedTextures = [],
            this._glTextures = Object.create(null),
            this._glSamplers = Object.create(null),
            this._boundTextures = [],
            this._activeTextureLocation = -1,
            this._boundSamplers = Object.create(null),
            this._uploads = {
                image: fg,
                buffer: C8,
                video: G8,
                compressed: I8
            },
            this._premultiplyAlpha = !1,
            this._useSeparateSamplers = !1,
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_glTextures"),
            this._renderer.renderableGC.addManagedHash(this, "_glSamplers")
        }
        contextChange(e) {
            this._gl = e,
            this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = H8(e, this._renderer.context.extensions),
            this._mapFormatToType = z8(e),
            this._mapFormatToFormat = D8(e)),
            this._glTextures = Object.create(null),
            this._glSamplers = Object.create(null),
            this._boundSamplers = Object.create(null),
            this._premultiplyAlpha = !1;
            for (let t = 0; t < 16; t++)
                this.bind(Z.EMPTY, t)
        }
        initSource(e) {
            this.bind(e)
        }
        bind(e, t=0) {
            let r = e.source;
            e ? (this.bindSource(r, t),
            this._useSeparateSamplers && this._bindSampler(r.style, t)) : (this.bindSource(null, t),
            this._useSeparateSamplers && this._bindSampler(null, t))
        }
        bindSource(e, t=0) {
            let r = this._gl;
            if (e._touched = this._renderer.textureGC.count,
            this._boundTextures[t] !== e) {
                this._boundTextures[t] = e,
                this._activateLocation(t),
                e || (e = Z.EMPTY.source);
                let s = this.getGlSource(e);
                r.bindTexture(s.target, s.texture)
            }
        }
        _bindSampler(e, t=0) {
            let r = this._gl;
            if (!e) {
                this._boundSamplers[t] = null,
                r.bindSampler(t, null);
                return
            }
            let s = this._getGlSampler(e);
            this._boundSamplers[t] !== s && (this._boundSamplers[t] = s,
            r.bindSampler(t, s))
        }
        unbind(e) {
            let t = e.source
              , r = this._boundTextures
              , s = this._gl;
            for (let n = 0; n < r.length; n++)
                if (r[n] === t) {
                    this._activateLocation(n);
                    let a = this.getGlSource(t);
                    s.bindTexture(a.target, null),
                    r[n] = null
                }
        }
        _activateLocation(e) {
            this._activeTextureLocation !== e && (this._activeTextureLocation = e,
            this._gl.activeTexture(this._gl.TEXTURE0 + e))
        }
        _initSource(e) {
            let t = this._gl
              , r = new ah(t.createTexture());
            if (r.type = this._mapFormatToType[e.format],
            r.internalFormat = this._mapFormatToInternalFormat[e.format],
            r.format = this._mapFormatToFormat[e.format],
            e.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo)) {
                let s = Math.max(e.width, e.height);
                e.mipLevelCount = Math.floor(Math.log2(s)) + 1
            }
            return this._glTextures[e.uid] = r,
            this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this),
            e.on("resize", this.onSourceUpdate, this),
            e.on("styleChange", this.onStyleChange, this),
            e.on("destroy", this.onSourceDestroy, this),
            e.on("unload", this.onSourceUnload, this),
            e.on("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.push(e)),
            this.onSourceUpdate(e),
            this.updateStyle(e, !1),
            r
        }
        onStyleChange(e) {
            this.updateStyle(e, !1)
        }
        updateStyle(e, t) {
            let r = this._gl
              , s = this.getGlSource(e);
            r.bindTexture(r.TEXTURE_2D, s.texture),
            this._boundTextures[this._activeTextureLocation] = e,
            Yp(e.style, r, e.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", r.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo, t)
        }
        onSourceUnload(e) {
            let t = this._glTextures[e.uid];
            t && (this.unbind(e),
            this._glTextures[e.uid] = null,
            this._gl.deleteTexture(t.texture))
        }
        onSourceUpdate(e) {
            let t = this._gl
              , r = this.getGlSource(e);
            t.bindTexture(t.TEXTURE_2D, r.texture),
            this._boundTextures[this._activeTextureLocation] = e;
            let s = e.alphaMode === "premultiply-alpha-on-upload";
            this._premultiplyAlpha !== s && (this._premultiplyAlpha = s,
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s)),
            this._uploads[e.uploadMethodId] ? this._uploads[e.uploadMethodId].upload(e, r, t, this._renderer.context.webGLVersion) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.pixelWidth, e.pixelHeight, 0, t.RGBA, t.UNSIGNED_BYTE, null),
            e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1)
        }
        onUpdateMipmaps(e, t=!0) {
            t && this.bindSource(e, 0);
            let r = this.getGlSource(e);
            this._gl.generateMipmap(r.target)
        }
        onSourceDestroy(e) {
            e.off("destroy", this.onSourceDestroy, this),
            e.off("update", this.onSourceUpdate, this),
            e.off("resize", this.onSourceUpdate, this),
            e.off("unload", this.onSourceUnload, this),
            e.off("styleChange", this.onStyleChange, this),
            e.off("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
            this.onSourceUnload(e)
        }
        _initSampler(e) {
            let t = this._gl
              , r = this._gl.createSampler();
            return this._glSamplers[e._resourceId] = r,
            Yp(e, t, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", r, !1, !0),
            this._glSamplers[e._resourceId]
        }
        _getGlSampler(e) {
            return this._glSamplers[e._resourceId] || this._initSampler(e)
        }
        getGlSource(e) {
            return this._glTextures[e.uid] || this._initSource(e)
        }
        generateCanvas(e) {
            let {pixels: t, width: r, height: s} = this.getPixels(e)
              , n = ye.get().createCanvas();
            n.width = r,
            n.height = s;
            let a = n.getContext("2d");
            if (a) {
                let o = a.createImageData(r, s);
                o.data.set(t),
                a.putImageData(o, 0, 0)
            }
            return n
        }
        getPixels(e) {
            let t = e.source.resolution
              , r = e.frame
              , s = Math.max(Math.round(r.width * t), 1)
              , n = Math.max(Math.round(r.height * t), 1)
              , a = new Uint8Array(V8 * s * n)
              , o = this._renderer
              , l = o.renderTarget.getRenderTarget(e)
              , u = o.renderTarget.getGpuRenderTarget(l)
              , d = o.gl;
            return d.bindFramebuffer(d.FRAMEBUFFER, u.resolveTargetFramebuffer),
            d.readPixels(Math.round(r.x * t), Math.round(r.y * t), s, n, d.RGBA, d.UNSIGNED_BYTE, a),
            {
                pixels: new Uint8ClampedArray(a.buffer),
                width: s,
                height: n
            }
        }
        destroy() {
            this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)),
            this.managedTextures = null,
            this._glTextures = null,
            this._glSamplers = null,
            this._boundTextures = null,
            this._boundSamplers = null,
            this._mapFormatToInternalFormat = null,
            this._mapFormatToType = null,
            this._mapFormatToFormat = null,
            this._uploads = null,
            this._renderer = null
        }
        resetState() {
            this._activeTextureLocation = -1,
            this._boundTextures.fill(Z.EMPTY.source),
            this._boundSamplers = Object.create(null);
            let e = this._gl;
            this._premultiplyAlpha = !1,
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha)
        }
    }
    ;
    Fa.extension = {
        type: [O.WebGLSystem],
        name: "texture"
    };
    var Da = class {
        contextChange(e) {
            let t = new ot({
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            })
              , r = e.limits.maxBatchableTextures
              , s = Rs({
                name: "graphics",
                bits: [Ch, Ih(r), kh, Cs]
            });
            this.shader = new vt({
                glProgram: s,
                resources: {
                    localUniforms: t,
                    batchSamplers: Gh(r)
                }
            })
        }
        execute(e, t) {
            let r = t.context
              , s = r.customShader || this.shader
              , n = e.renderer
              , a = n.graphicsContext
              , {batcher: o, instructions: l} = a.getContextRenderData(r);
            s.groups[0] = n.globalUniforms.bindGroup,
            n.state.set(e.state),
            n.shader.bind(s),
            n.geometry.bind(o.geometry, s.glProgram);
            let u = l.instructions;
            for (let d = 0; d < l.instructionSize; d++) {
                let f = u[d];
                if (f.size) {
                    for (let b = 0; b < f.textures.count; b++)
                        n.texture.bind(f.textures.textures[b], b);
                    n.geometry.draw(f.topology, f.size, f.start)
                }
            }
        }
        destroy() {
            this.shader.destroy(!0),
            this.shader = null
        }
    }
    ;
    Da.extension = {
        type: [O.WebGLPipesAdaptor],
        name: "graphics"
    };
    var ka = class {
        init() {
            let e = Rs({
                name: "mesh",
                bits: [kh, P5, Cs]
            });
            this._shader = new vt({
                glProgram: e,
                resources: {
                    uTexture: Z.EMPTY.source,
                    textureUniforms: {
                        uTextureMatrix: {
                            type: "mat3x3<f32>",
                            value: new ce
                        }
                    }
                }
            })
        }
        execute(e, t) {
            let r = e.renderer
              , s = t._shader;
            if (s) {
                if (!s.glProgram)
                    return
            } else {
                s = this._shader;
                let n = t.texture
                  , a = n.source;
                s.resources.uTexture = a,
                s.resources.uSampler = a.style,
                s.resources.textureUniforms.uniforms.uTextureMatrix = n.textureMatrix.mapCoord
            }
            s.groups[100] = r.globalUniforms.bindGroup,
            s.groups[101] = e.localUniformsBindGroup,
            r.encoder.draw({
                geometry: t._geometry,
                shader: s,
                state: t.state
            })
        }
        destroy() {
            this._shader.destroy(!0),
            this._shader = null
        }
    }
    ;
    ka.extension = {
        type: [O.WebGLPipesAdaptor],
        name: "mesh"
    };
    var Ua = class {
        constructor(e) {
            this._renderer = e
        }
        updateRenderable() {}
        destroyRenderable() {}
        validateRenderable() {
            return !1
        }
        addRenderable(e, t) {
            this._renderer.renderPipes.batch.break(t),
            t.add(e)
        }
        execute(e) {
            e.isRenderable && e.render(this._renderer)
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Ua.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "customRender"
    };
    function oh(i, e) {
        let t = i.instructionSet
          , r = t.instructions;
        for (let s = 0; s < t.instructionSize; s++) {
            let n = r[s];
            e[n.renderPipeId].execute(n)
        }
    }
    var W8 = new ce
      , La = class {
        constructor(e) {
            this._renderer = e
        }
        addRenderGroup(e, t) {
            e.isCachedAsTexture ? this._addRenderableCacheAsTexture(e, t) : this._addRenderableDirect(e, t)
        }
        execute(e) {
            e.isRenderable && (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e))
        }
        destroy() {
            this._renderer = null
        }
        _addRenderableDirect(e, t) {
            this._renderer.renderPipes.batch.break(t),
            e._batchableRenderGroup && (Je.return(e._batchableRenderGroup),
            e._batchableRenderGroup = null),
            t.add(e)
        }
        _addRenderableCacheAsTexture(e, t) {
            var r;
            let s = (r = e._batchableRenderGroup) != null ? r : e._batchableRenderGroup = Je.get(wr);
            s.renderable = e.root,
            s.transform = e.root.relativeGroupTransform,
            s.texture = e.texture,
            s.bounds = e._textureBounds,
            t.add(e),
            this._renderer.renderPipes.blendMode.pushBlendMode(e, e.root.groupBlendMode, t),
            this._renderer.renderPipes.batch.addToBatch(s, t),
            this._renderer.renderPipes.blendMode.popBlendMode(t)
        }
        _executeCacheAsTexture(e) {
            if (e.textureNeedsUpdate) {
                e.textureNeedsUpdate = !1;
                let t = W8.identity().translate(-e._textureBounds.x, -e._textureBounds.y);
                this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame),
                this._renderer.globalUniforms.push({
                    worldTransformMatrix: t,
                    worldColor: 4294967295,
                    offset: {
                        x: 0,
                        y: 0
                    }
                }),
                oh(e, this._renderer.renderPipes),
                this._renderer.renderTarget.finishRenderPass(),
                this._renderer.renderTarget.pop(),
                this._renderer.globalUniforms.pop()
            }
            e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup),
            e._batchableRenderGroup._batcher.geometry.buffers[0].update()
        }
        _executeDirect(e) {
            this._renderer.globalUniforms.push({
                worldTransformMatrix: e.inverseParentTextureTransform,
                worldColor: e.worldColorAlpha
            }),
            oh(e, this._renderer.renderPipes),
            this._renderer.globalUniforms.pop()
        }
    }
    ;
    La.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "renderGroup"
    };
    function ch(i, e) {
        e || (e = 0);
        for (let t = e; t < i.length && i[t]; t++)
            i[t] = null
    }
    var Y8 = new Te
      , qp = is | _n | Ph;
    function pg(i, e=!1) {
        $8(i);
        let t = i.childrenToUpdate
          , r = i.updateTick++;
        for (let s in t) {
            let n = Number(s)
              , a = t[s]
              , o = a.list
              , l = a.index;
            for (let u = 0; u < l; u++) {
                let d = o[u];
                d.parentRenderGroup === i && d.relativeRenderGroupDepth === n && bg(d, r, 0)
            }
            ch(o, l),
            a.index = 0
        }
        if (e)
            for (let s = 0; s < i.renderGroupChildren.length; s++)
                pg(i.renderGroupChildren[s], e)
    }
    function $8(i) {
        let e = i.root, t;
        if (i.renderGroupParent) {
            let r = i.renderGroupParent;
            i.worldTransform.appendFrom(e.relativeGroupTransform, r.worldTransform),
            i.worldColor = bn(e.groupColor, r.worldColor),
            t = e.groupAlpha * r.worldAlpha
        } else
            i.worldTransform.copyFrom(e.localTransform),
            i.worldColor = e.localColor,
            t = e.localAlpha;
        t = t < 0 ? 0 : t > 1 ? 1 : t,
        i.worldAlpha = t,
        i.worldColorAlpha = i.worldColor + ((t * 255 | 0) << 24)
    }
    function bg(i, e, t) {
        if (e === i.updateTick)
            return;
        i.updateTick = e,
        i.didChange = !1;
        let r = i.localTransform;
        i.updateLocalTransform();
        let s = i.parent;
        if (s && !s.renderGroup ? (t |= i._updateFlags,
        i.relativeGroupTransform.appendFrom(r, s.relativeGroupTransform),
        t & qp && Zp(i, s, t)) : (t = i._updateFlags,
        i.relativeGroupTransform.copyFrom(r),
        t & qp && Zp(i, Y8, t)),
        !i.renderGroup) {
            let n = i.children
              , a = n.length;
            for (let u = 0; u < a; u++)
                bg(n[u], e, t);
            let o = i.parentRenderGroup
              , l = i;
            l.renderPipeId && !o.structureDidChange && o.updateRenderable(l)
        }
    }
    function Zp(i, e, t) {
        if (t & _n) {
            i.groupColor = bn(i.localColor, e.groupColor);
            let r = i.localAlpha * e.groupAlpha;
            r = r < 0 ? 0 : r > 1 ? 1 : r,
            i.groupAlpha = r,
            i.groupColorAlpha = i.groupColor + ((r * 255 | 0) << 24)
        }
        t & Ph && (i.groupBlendMode = i.localBlendMode === "inherit" ? e.groupBlendMode : i.localBlendMode),
        t & is && (i.globalDisplayStatus = i.localDisplayStatus & e.globalDisplayStatus),
        i._updateFlags = 0
    }
    function K8(i, e) {
        let {list: t, index: r} = i.childrenRenderablesToUpdate
          , s = !1;
        for (let n = 0; n < r; n++) {
            let a = t[n];
            if (s = e[a.renderPipeId].validateRenderable(a),
            s)
                break
        }
        return i.structureDidChange = s,
        s
    }
    var q8 = new ce
      , Na = class {
        constructor(e) {
            this._renderer = e
        }
        render({container: e, transform: t}) {
            let r = e.parent
              , s = e.renderGroup.renderGroupParent;
            e.parent = null,
            e.renderGroup.renderGroupParent = null;
            let n = this._renderer
              , a = q8;
            t && (a.copyFrom(e.renderGroup.localTransform),
            e.renderGroup.localTransform.copyFrom(t));
            let o = n.renderPipes;
            this._updateCachedRenderGroups(e.renderGroup, null),
            this._updateRenderGroups(e.renderGroup),
            n.globalUniforms.start({
                worldTransformMatrix: t ? e.renderGroup.localTransform : e.renderGroup.worldTransform,
                worldColor: e.renderGroup.worldColorAlpha
            }),
            oh(e.renderGroup, o),
            o.uniformBatch && o.uniformBatch.renderEnd(),
            t && e.renderGroup.localTransform.copyFrom(a),
            e.parent = r,
            e.renderGroup.renderGroupParent = s
        }
        destroy() {
            this._renderer = null
        }
        _updateCachedRenderGroups(e, t) {
            var r, s;
            if (e._parentCacheAsTextureRenderGroup = t,
            e.isCachedAsTexture) {
                if (!e.textureNeedsUpdate)
                    return;
                t = e
            }
            for (let n = e.renderGroupChildren.length - 1; n >= 0; n--)
                this._updateCachedRenderGroups(e.renderGroupChildren[n], t);
            if (e.invalidateMatrices(),
            e.isCachedAsTexture) {
                if (e.textureNeedsUpdate) {
                    let n = e.root.getLocalBounds();
                    n.ceil();
                    let a = e.texture;
                    e.texture && Ke.returnTexture(e.texture, !0);
                    let o = this._renderer
                      , l = e.textureOptions.resolution || o.view.resolution
                      , u = (r = e.textureOptions.antialias) != null ? r : o.view.antialias
                      , d = (s = e.textureOptions.scaleMode) != null ? s : "linear"
                      , f = Ke.getOptimalTexture(n.width, n.height, l, u);
                    f._source.style = new kt({
                        scaleMode: d
                    }),
                    e.texture = f,
                    e._textureBounds || (e._textureBounds = new at),
                    e._textureBounds.copyFrom(n),
                    a !== e.texture && e.renderGroupParent && (e.renderGroupParent.structureDidChange = !0)
                }
            } else
                e.texture && (Ke.returnTexture(e.texture, !0),
                e.texture = null)
        }
        _updateRenderGroups(e) {
            let t = this._renderer
              , r = t.renderPipes;
            if (e.runOnRender(t),
            e.instructionSet.renderPipes = r,
            e.structureDidChange ? ch(e.childrenRenderablesToUpdate.list, 0) : K8(e, r),
            pg(e),
            e.structureDidChange ? (e.structureDidChange = !1,
            this._buildInstructions(e, t)) : this._updateRenderables(e),
            e.childrenRenderablesToUpdate.index = 0,
            t.renderPipes.batch.upload(e.instructionSet),
            !(e.isCachedAsTexture && !e.textureNeedsUpdate))
                for (let s = 0; s < e.renderGroupChildren.length; s++)
                    this._updateRenderGroups(e.renderGroupChildren[s])
        }
        _updateRenderables(e) {
            let {list: t, index: r} = e.childrenRenderablesToUpdate;
            for (let s = 0; s < r; s++) {
                let n = t[s];
                n.didViewUpdate && e.updateRenderable(n)
            }
            ch(t, r)
        }
        _buildInstructions(e, t) {
            let r = e.root
              , s = e.instructionSet;
            s.reset();
            let n = t.renderPipes ? t : t.batch.renderer
              , a = n.renderPipes;
            a.batch.buildStart(s),
            a.blendMode.buildStart(),
            a.colorMask.buildStart(),
            r.sortableChildren && r.sortChildren(),
            r.collectRenderablesWithEffects(s, n, null),
            a.batch.buildEnd(s),
            a.blendMode.buildEnd(s)
        }
    }
    ;
    Na.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "renderGroup"
    };
    var Xa = class {
        constructor(e) {
            this._renderer = e
        }
        addRenderable(e, t) {
            let r = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, r),
            this._renderer.renderPipes.batch.addToBatch(r, t)
        }
        updateRenderable(e) {
            let t = this._getGpuSprite(e);
            e.didViewUpdate && this._updateBatchableSprite(e, t),
            t._batcher.updateElement(t)
        }
        validateRenderable(e) {
            let t = this._getGpuSprite(e);
            return !t._batcher.checkAndUpdateTexture(t, e._texture)
        }
        _updateBatchableSprite(e, t) {
            t.bounds = e.visualBounds,
            t.texture = e._texture
        }
        _getGpuSprite(e) {
            return e._gpuData[this._renderer.uid] || this._initGPUSprite(e)
        }
        _initGPUSprite(e) {
            let t = new wr;
            return t.renderable = e,
            t.transform = e.groupTransform,
            t.texture = e._texture,
            t.bounds = e.visualBounds,
            t.roundPixels = this._renderer._roundPixels | e._roundPixels,
            e._gpuData[this._renderer.uid] = t,
            t
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Xa.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "sprite"
    };
    var Z8 = Object.defineProperty
      , Qp = Object.getOwnPropertySymbols
      , Q8 = Object.prototype.hasOwnProperty
      , J8 = Object.prototype.propertyIsEnumerable
      , Jp = (i, e, t) => e in i ? Z8(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , e0 = (i, e) => {
        for (var t in e || (e = {}))
            Q8.call(e, t) && Jp(i, t, e[t]);
        if (Qp)
            for (var t of Qp(e))
                J8.call(e, t) && Jp(i, t, e[t]);
        return i
    }
      , lh = class mg {
        constructor() {
            this.clearBeforeRender = !0,
            this._backgroundColor = new Be(0),
            this.color = this._backgroundColor,
            this.alpha = 1
        }
        init(e) {
            e = e0(e0({}, mg.defaultOptions), e),
            this.clearBeforeRender = e.clearBeforeRender,
            this.color = e.background || e.backgroundColor || this._backgroundColor,
            this.alpha = e.backgroundAlpha,
            this._backgroundColor.setAlpha(e.backgroundAlpha)
        }
        get color() {
            return this._backgroundColor
        }
        set color(e) {
            this._backgroundColor.setValue(e)
        }
        get alpha() {
            return this._backgroundColor.alpha
        }
        set alpha(e) {
            this._backgroundColor.setAlpha(e)
        }
        get colorRgba() {
            return this._backgroundColor.toArray()
        }
        destroy() {}
    }
    ;
    lh.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "background",
        priority: 0
    },
    lh.defaultOptions = {
        backgroundAlpha: 1,
        backgroundColor: 0,
        clearBeforeRender: !0
    };
    var e6 = lh
      , hs = {};
    be.handle(O.BlendMode, i => {
        if (!i.name)
            throw new Error("BlendMode extension must have a name property");
        hs[i.name] = i.ref
    }
    , i => {
        delete hs[i.name]
    }
    );
    var ja = class {
        constructor(e) {
            this._blendModeStack = [],
            this._isAdvanced = !1,
            this._filterHash = Object.create(null),
            this._renderer = e,
            this._renderer.runners.prerender.add(this)
        }
        prerender() {
            this._activeBlendMode = "normal",
            this._isAdvanced = !1
        }
        pushBlendMode(e, t, r) {
            this._blendModeStack.push(t),
            this.setBlendMode(e, t, r)
        }
        popBlendMode(e) {
            var t;
            this._blendModeStack.pop();
            let r = (t = this._blendModeStack[this._activeBlendMode.length - 1]) != null ? t : "normal";
            this.setBlendMode(null, r, e)
        }
        setBlendMode(e, t, r) {
            var s;
            let n = e instanceof ds;
            if (this._activeBlendMode === t) {
                this._isAdvanced && e && !n && ((s = this._renderableList) == null || s.push(e));
                return
            }
            this._isAdvanced && this._endAdvancedBlendMode(r),
            this._activeBlendMode = t,
            e && (this._isAdvanced = !!hs[t],
            this._isAdvanced && this._beginAdvancedBlendMode(e, r))
        }
        _beginAdvancedBlendMode(e, t) {
            this._renderer.renderPipes.batch.break(t);
            let r = this._activeBlendMode;
            if (!hs[r])
                return;
            let s = this._ensureFilterEffect(r)
              , n = e instanceof ds
              , a = {
                renderPipeId: "filter",
                action: "pushFilter",
                filterEffect: s,
                renderables: n ? null : [e],
                container: n ? e.root : null,
                canBundle: !1
            };
            this._renderableList = a.renderables,
            t.add(a)
        }
        _ensureFilterEffect(e) {
            let t = this._filterHash[e];
            return t || (t = this._filterHash[e] = new xr,
            t.filters = [new hs[e]]),
            t
        }
        _endAdvancedBlendMode(e) {
            this._isAdvanced = !1,
            this._renderableList = null,
            this._renderer.renderPipes.batch.break(e),
            e.add({
                renderPipeId: "filter",
                action: "popFilter",
                canBundle: !1
            })
        }
        buildStart() {
            this._isAdvanced = !1
        }
        buildEnd(e) {
            this._isAdvanced && this._endAdvancedBlendMode(e)
        }
        destroy() {
            this._renderer = null,
            this._renderableList = null;
            for (let e in this._filterHash)
                this._filterHash[e].destroy();
            this._filterHash = null
        }
    }
    ;
    ja.extension = {
        type: [O.WebGLPipes, O.WebGPUPipes, O.CanvasPipes],
        name: "blendMode"
    };
    var t6 = Object.defineProperty
      , t0 = Object.getOwnPropertySymbols
      , i6 = Object.prototype.hasOwnProperty
      , r6 = Object.prototype.propertyIsEnumerable
      , i0 = (i, e, t) => e in i ? t6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Ac = (i, e) => {
        for (var t in e || (e = {}))
            i6.call(e, t) && i0(i, t, e[t]);
        if (t0)
            for (var t of t0(e))
                r6.call(e, t) && i0(i, t, e[t]);
        return i
    }
      , Ec = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
    }
      , hh = class gg {
        constructor(e) {
            this._renderer = e
        }
        _normalizeOptions(e, t={}) {
            return e instanceof Te || e instanceof Z ? Ac({
                target: e
            }, t) : Ac(Ac({}, t), e)
        }
        async image(e) {
            let t = ye.get().createImage();
            return t.src = await this.base64(e),
            t
        }
        async base64(e) {
            e = this._normalizeOptions(e, gg.defaultImageOptions);
            let {format: t, quality: r} = e
              , s = this.canvas(e);
            if (s.toBlob !== void 0)
                return new Promise( (n, a) => {
                    s.toBlob(o => {
                        if (!o) {
                            a(new Error("ICanvas.toBlob failed!"));
                            return
                        }
                        let l = new FileReader;
                        l.onload = () => n(l.result),
                        l.onerror = a,
                        l.readAsDataURL(o)
                    }
                    , Ec[t], r)
                }
                );
            if (s.toDataURL !== void 0)
                return s.toDataURL(Ec[t], r);
            if (s.convertToBlob !== void 0) {
                let n = await s.convertToBlob({
                    type: Ec[t],
                    quality: r
                });
                return new Promise( (a, o) => {
                    let l = new FileReader;
                    l.onload = () => a(l.result),
                    l.onerror = o,
                    l.readAsDataURL(n)
                }
                )
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
        }
        canvas(e) {
            e = this._normalizeOptions(e);
            let t = e.target
              , r = this._renderer;
            if (t instanceof Z)
                return r.texture.generateCanvas(t);
            let s = r.textureGenerator.generateTexture(e)
              , n = r.texture.generateCanvas(s);
            return s.destroy(!0),
            n
        }
        pixels(e) {
            e = this._normalizeOptions(e);
            let t = e.target
              , r = this._renderer
              , s = t instanceof Z ? t : r.textureGenerator.generateTexture(e)
              , n = r.texture.getPixels(s);
            return t instanceof Te && s.destroy(!0),
            n
        }
        texture(e) {
            return e = this._normalizeOptions(e),
            e.target instanceof Z ? e.target : this._renderer.textureGenerator.generateTexture(e)
        }
        download(e) {
            var t;
            e = this._normalizeOptions(e);
            let r = this.canvas(e)
              , s = document.createElement("a");
            s.download = (t = e.filename) != null ? t : "image.png",
            s.href = r.toDataURL("image/png"),
            document.body.appendChild(s),
            s.click(),
            document.body.removeChild(s)
        }
        log(e) {
            var t;
            let r = (t = e.width) != null ? t : 200;
            e = this._normalizeOptions(e);
            let s = this.canvas(e)
              , n = s.toDataURL()
              , a = ["font-size: 1px;", `padding: ${r}px 300px;`, `background: url(${n}) no-repeat;`, "background-size: contain;"].join(" ")
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    hh.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem],
        name: "extract"
    },
    hh.defaultImageOptions = {
        format: "png",
        quality: 1
    };
    var s6 = hh
      , uh = class i extends Z {
        static create(e) {
            return new i({
                source: new Xe(e)
            })
        }
        resize(e, t, r) {
            return this.source.resize(e, t, r),
            this
        }
    }
      , n6 = Object.defineProperty
      , a6 = Object.defineProperties
      , o6 = Object.getOwnPropertyDescriptors
      , r0 = Object.getOwnPropertySymbols
      , c6 = Object.prototype.hasOwnProperty
      , l6 = Object.prototype.propertyIsEnumerable
      , s0 = (i, e, t) => e in i ? n6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , h6 = (i, e) => {
        for (var t in e || (e = {}))
            c6.call(e, t) && s0(i, t, e[t]);
        if (r0)
            for (var t of r0(e))
                l6.call(e, t) && s0(i, t, e[t]);
        return i
    }
      , u6 = (i, e) => a6(i, o6(e))
      , d6 = new Oe
      , f6 = new at
      , p6 = [0, 0, 0, 0]
      , Ha = class {
        constructor(e) {
            this._renderer = e
        }
        generateTexture(e) {
            var t;
            e instanceof Te && (e = {
                target: e,
                frame: void 0,
                textureSourceOptions: {},
                resolution: void 0
            });
            let r = e.resolution || this._renderer.resolution
              , s = e.antialias || this._renderer.view.antialias
              , n = e.target
              , a = e.clearColor;
            a ? a = Array.isArray(a) && a.length === 4 ? a : Be.shared.setValue(a).toArray() : a = p6;
            let o = ((t = e.frame) == null ? void 0 : t.copyTo(d6)) || Eh(n, f6).rectangle;
            o.width = Math.max(o.width, 1 / r) | 0,
            o.height = Math.max(o.height, 1 / r) | 0;
            let l = uh.create(u6(h6({}, e.textureSourceOptions), {
                width: o.width,
                height: o.height,
                resolution: r,
                antialias: s
            }))
              , u = ce.shared.translate(-o.x, -o.y);
            return this._renderer.render({
                container: n,
                transform: u,
                target: l,
                clearColor: a
            }),
            l.source.updateMipmaps(),
            l
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    Ha.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem],
        name: "textureGenerator"
    };
    var za = class {
        constructor(e) {
            this._stackIndex = 0,
            this._globalUniformDataStack = [],
            this._uniformsPool = [],
            this._activeUniforms = [],
            this._bindGroupPool = [],
            this._activeBindGroups = [],
            this._renderer = e
        }
        reset() {
            this._stackIndex = 0;
            for (let e = 0; e < this._activeUniforms.length; e++)
                this._uniformsPool.push(this._activeUniforms[e]);
            for (let e = 0; e < this._activeBindGroups.length; e++)
                this._bindGroupPool.push(this._activeBindGroups[e]);
            this._activeUniforms.length = 0,
            this._activeBindGroups.length = 0
        }
        start(e) {
            this.reset(),
            this.push(e)
        }
        bind({size: e, projectionMatrix: t, worldTransformMatrix: r, worldColor: s, offset: n}) {
            let a = this._renderer.renderTarget.renderTarget
              , o = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
                projectionData: a,
                worldTransformMatrix: new ce,
                worldColor: 4294967295,
                offset: new Ue
            }
              , l = {
                projectionMatrix: t || this._renderer.renderTarget.projectionMatrix,
                resolution: e || a.size,
                worldTransformMatrix: r || o.worldTransformMatrix,
                worldColor: s || o.worldColor,
                offset: n || o.offset,
                bindGroup: null
            }
              , u = this._uniformsPool.pop() || this._createUniforms();
            this._activeUniforms.push(u);
            let d = u.uniforms;
            d.uProjectionMatrix = l.projectionMatrix,
            d.uResolution = l.resolution,
            d.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix),
            d.uWorldTransformMatrix.tx -= l.offset.x,
            d.uWorldTransformMatrix.ty -= l.offset.y,
            Os(l.worldColor, d.uWorldColorAlpha, 0),
            u.update();
            let f;
            this._renderer.renderPipes.uniformBatch ? f = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(u, !1) : (f = this._bindGroupPool.pop() || new Yt,
            this._activeBindGroups.push(f),
            f.setResource(u, 0)),
            l.bindGroup = f,
            this._currentGlobalUniformData = l
        }
        push(e) {
            this.bind(e),
            this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData
        }
        pop() {
            this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1],
            this._renderer.type === Ct.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update()
        }
        get bindGroup() {
            return this._currentGlobalUniformData.bindGroup
        }
        get globalUniformData() {
            return this._currentGlobalUniformData
        }
        get uniformGroup() {
            return this._currentGlobalUniformData.bindGroup.resources[0]
        }
        _createUniforms() {
            return new ot({
                uProjectionMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uWorldTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uWorldColorAlpha: {
                    value: new Float32Array(4),
                    type: "vec4<f32>"
                },
                uResolution: {
                    value: [0, 0],
                    type: "vec2<f32>"
                }
            },{
                isStatic: !0
            })
        }
        destroy() {
            this._renderer = null,
            this._globalUniformDataStack.length = 0,
            this._uniformsPool.length = 0,
            this._activeUniforms.length = 0,
            this._bindGroupPool.length = 0,
            this._activeBindGroups.length = 0,
            this._currentGlobalUniformData = null
        }
    }
    ;
    za.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "globalUniforms"
    };
    var b6 = 1
      , Va = class {
        constructor() {
            this._tasks = [],
            this._offset = 0
        }
        init() {
            nt.system.add(this._update, this)
        }
        repeat(e, t, r=!0) {
            let s = b6++
              , n = 0;
            return r && (this._offset += 1e3,
            n = this._offset),
            this._tasks.push({
                func: e,
                duration: t,
                start: performance.now(),
                offset: n,
                last: performance.now(),
                repeat: !0,
                id: s
            }),
            s
        }
        cancel(e) {
            for (let t = 0; t < this._tasks.length; t++)
                if (this._tasks[t].id === e) {
                    this._tasks.splice(t, 1);
                    return
                }
        }
        _update() {
            let e = performance.now();
            for (let t = 0; t < this._tasks.length; t++) {
                let r = this._tasks[t];
                if (e - r.offset - r.last >= r.duration) {
                    let s = e - r.start;
                    r.func(s),
                    r.last = e
                }
            }
        }
        destroy() {
            nt.system.remove(this._update, this),
            this._tasks.length = 0
        }
    }
    ;
    Va.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "scheduler",
        priority: 0
    };
    var n0 = !1;
    function m6(i) {
        if (!n0) {
            if (ye.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
                let e = [`%c  %c  %c  %c  %c PixiJS %c v${ia} (${i}) http://www.pixijs.com/

`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"];
                globalThis.console.log(...e)
            } else
                globalThis.console && globalThis.console.log(`PixiJS ${ia} - ${i} - http://www.pixijs.com/`);
            n0 = !0
        }
    }
    var As = class {
        constructor(e) {
            this._renderer = e
        }
        init(e) {
            if (e.hello) {
                let t = this._renderer.name;
                this._renderer.type === Ct.WEBGL && (t += ` ${this._renderer.context.webGLVersion}`),
                m6(t)
            }
        }
    }
    ;
    As.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "hello",
        priority: -2
    },
    As.defaultOptions = {
        hello: !1
    };
    function g6(i) {
        let e = !1;
        for (let r in i)
            if (i[r] == null) {
                e = !0;
                break
            }
        if (!e)
            return i;
        let t = Object.create(null);
        for (let r in i) {
            let s = i[r];
            s && (t[r] = s)
        }
        return t
    }
    function _6(i) {
        let e = 0;
        for (let t = 0; t < i.length; t++)
            i[t] == null ? e++ : i[t - e] = i[t];
        return i.length -= e,
        i
    }
    var x6 = Object.defineProperty
      , a0 = Object.getOwnPropertySymbols
      , y6 = Object.prototype.hasOwnProperty
      , v6 = Object.prototype.propertyIsEnumerable
      , o0 = (i, e, t) => e in i ? x6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , c0 = (i, e) => {
        for (var t in e || (e = {}))
            y6.call(e, t) && o0(i, t, e[t]);
        if (a0)
            for (var t of a0(e))
                v6.call(e, t) && o0(i, t, e[t]);
        return i
    }
      , T6 = 0
      , dh = class _g {
        constructor(e) {
            this._managedRenderables = [],
            this._managedHashes = [],
            this._managedArrays = [],
            this._renderer = e
        }
        init(e) {
            e = c0(c0({}, _g.defaultOptions), e),
            this.maxUnusedTime = e.renderableGCMaxUnusedTime,
            this._frequency = e.renderableGCFrequency,
            this.enabled = e.renderableGCActive
        }
        get enabled() {
            return !!this._handler
        }
        set enabled(e) {
            this.enabled !== e && (e ? (this._handler = this._renderer.scheduler.repeat( () => this.run(), this._frequency, !1),
            this._hashHandler = this._renderer.scheduler.repeat( () => {
                for (let t of this._managedHashes)
                    t.context[t.hash] = g6(t.context[t.hash])
            }
            , this._frequency),
            this._arrayHandler = this._renderer.scheduler.repeat( () => {
                for (let t of this._managedArrays)
                    _6(t.context[t.hash])
            }
            , this._frequency)) : (this._renderer.scheduler.cancel(this._handler),
            this._renderer.scheduler.cancel(this._hashHandler),
            this._renderer.scheduler.cancel(this._arrayHandler)))
        }
        addManagedHash(e, t) {
            this._managedHashes.push({
                context: e,
                hash: t
            })
        }
        addManagedArray(e, t) {
            this._managedArrays.push({
                context: e,
                hash: t
            })
        }
        prerender({container: e}) {
            this._now = performance.now(),
            e.renderGroup.gcTick = T6++,
            this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick)
        }
        addRenderable(e) {
            this.enabled && (e._lastUsed === -1 && (this._managedRenderables.push(e),
            e.once("destroyed", this._removeRenderable, this)),
            e._lastUsed = this._now)
        }
        run() {
            var e, t, r, s;
            let n = this._now
              , a = this._managedRenderables
              , o = this._renderer.renderPipes
              , l = 0;
            for (let u = 0; u < a.length; u++) {
                let d = a[u];
                if (d === null) {
                    l++;
                    continue
                }
                let f = (e = d.renderGroup) != null ? e : d.parentRenderGroup
                  , b = (r = (t = f?.instructionSet) == null ? void 0 : t.gcTick) != null ? r : -1;
                if (((s = f?.gcTick) != null ? s : 0) === b && (d._lastUsed = n),
                n - d._lastUsed > this.maxUnusedTime) {
                    if (!d.destroyed) {
                        let m = o;
                        f && (f.structureDidChange = !0),
                        m[d.renderPipeId].destroyRenderable(d)
                    }
                    d._lastUsed = -1,
                    l++,
                    d.off("destroyed", this._removeRenderable, this)
                } else
                    a[u - l] = d
            }
            a.length -= l
        }
        destroy() {
            this.enabled = !1,
            this._renderer = null,
            this._managedRenderables.length = 0,
            this._managedHashes.length = 0,
            this._managedArrays.length = 0
        }
        _removeRenderable(e) {
            let t = this._managedRenderables.indexOf(e);
            t >= 0 && (e.off("destroyed", this._removeRenderable, this),
            this._managedRenderables[t] = null)
        }
        _updateInstructionGCTick(e, t) {
            e.instructionSet.gcTick = t;
            for (let r of e.renderGroupChildren)
                this._updateInstructionGCTick(r, t)
        }
    }
    ;
    dh.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem],
        name: "renderableGC",
        priority: 0
    },
    dh.defaultOptions = {
        renderableGCActive: !0,
        renderableGCMaxUnusedTime: 6e4,
        renderableGCFrequency: 3e4
    };
    var S6 = dh
      , w6 = Object.defineProperty
      , l0 = Object.getOwnPropertySymbols
      , A6 = Object.prototype.hasOwnProperty
      , E6 = Object.prototype.propertyIsEnumerable
      , h0 = (i, e, t) => e in i ? w6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , u0 = (i, e) => {
        for (var t in e || (e = {}))
            A6.call(e, t) && h0(i, t, e[t]);
        if (l0)
            for (var t of l0(e))
                E6.call(e, t) && h0(i, t, e[t]);
        return i
    }
      , fh = class xg {
        constructor(e) {
            this._renderer = e,
            this.count = 0,
            this.checkCount = 0
        }
        init(e) {
            var t;
            e = u0(u0({}, xg.defaultOptions), e),
            this.checkCountMax = e.textureGCCheckCountMax,
            this.maxIdle = (t = e.textureGCAMaxIdle) != null ? t : e.textureGCMaxIdle,
            this.active = e.textureGCActive
        }
        postrender() {
            this._renderer.renderingToScreen && (this.count++,
            this.active && (this.checkCount++,
            this.checkCount > this.checkCountMax && (this.checkCount = 0,
            this.run())))
        }
        run() {
            let e = this._renderer.texture.managedTextures;
            for (let t = 0; t < e.length; t++) {
                let r = e[t];
                r.autoGarbageCollect && r.resource && r._touched > -1 && this.count - r._touched > this.maxIdle && (r._touched = -1,
                r.unload())
            }
        }
        destroy() {
            this._renderer = null
        }
    }
    ;
    fh.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem],
        name: "textureGC"
    },
    fh.defaultOptions = {
        textureGCActive: !0,
        textureGCAMaxIdle: null,
        textureGCMaxIdle: 3600,
        textureGCCheckCountMax: 600
    };
    var P6 = fh
      , R6 = Object.defineProperty
      , d0 = Object.getOwnPropertySymbols
      , M6 = Object.prototype.hasOwnProperty
      , C6 = Object.prototype.propertyIsEnumerable
      , f0 = (i, e, t) => e in i ? R6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , p0 = (i, e) => {
        for (var t in e || (e = {}))
            M6.call(e, t) && f0(i, t, e[t]);
        if (d0)
            for (var t of d0(e))
                C6.call(e, t) && f0(i, t, e[t]);
        return i
    }
      , ph = class yg {
        get autoDensity() {
            return this.texture.source.autoDensity
        }
        set autoDensity(e) {
            this.texture.source.autoDensity = e
        }
        get resolution() {
            return this.texture.source._resolution
        }
        set resolution(e) {
            this.texture.source.resize(this.texture.source.width, this.texture.source.height, e)
        }
        init(e) {
            e = p0(p0({}, yg.defaultOptions), e),
            e.view && (e.canvas = e.view),
            this.screen = new Oe(0,0,e.width,e.height),
            this.canvas = e.canvas || ye.get().createCanvas(),
            this.antialias = !!e.antialias,
            this.texture = og(this.canvas, e),
            this.renderTarget = new rh({
                colorTextures: [this.texture],
                depth: !!e.depth,
                isRoot: !0
            }),
            this.texture.source.transparent = e.backgroundAlpha < 1,
            this.resolution = e.resolution
        }
        resize(e, t, r) {
            this.texture.source.resize(e, t, r),
            this.screen.width = this.texture.frame.width,
            this.screen.height = this.texture.frame.height
        }
        destroy(e=!1) {
            (typeof e == "boolean" ? e : e != null && e.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas),
            this.texture.destroy()
        }
    }
    ;
    ph.extension = {
        type: [O.WebGLSystem, O.WebGPUSystem, O.CanvasSystem],
        name: "view",
        priority: 0
    },
    ph.defaultOptions = {
        width: 800,
        height: 600,
        autoDensity: !1,
        antialias: !1
    };
    var O6 = ph
      , vg = [e6, za, As, O6, Na, P6, Ha, s6, sa, S6, Va]
      , Tg = [ja, Jm, Xa, La, ya, Ta, va, Ua]
      , I6 = [...vg, Ca, z5, F5, Pa, Sa, Fa, Ia, wa, Ba, Ga, Ea, M8, Ra, Aa]
      , G6 = [...Tg]
      , B6 = [_a, ka, Da]
      , Sg = []
      , wg = []
      , Ag = [];
    be.handleByNamedList(O.WebGLSystem, Sg),
    be.handleByNamedList(O.WebGLPipes, wg),
    be.handleByNamedList(O.WebGLPipesAdaptor, Ag),
    be.add(...I6, ...G6, ...B6);
    var bh = class extends bo {
        constructor() {
            let e = {
                name: "webgl",
                type: Ct.WEBGL,
                systems: Sg,
                renderPipes: wg,
                renderPipeAdaptors: Ag
            };
            super(e)
        }
    }
      , F6 = {
        __proto__: null,
        WebGLRenderer: bh
    }
      , Wa = class {
        constructor(e) {
            this._hash = Object.create(null),
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_hash")
        }
        contextChange(e) {
            this._gpu = e
        }
        getBindGroup(e, t, r) {
            return e._updateKey(),
            this._hash[e._key] || this._createBindGroup(e, t, r)
        }
        _createBindGroup(e, t, r) {
            var s;
            let n = this._gpu.device
              , a = t.layout[r]
              , o = []
              , l = this._renderer;
            for (let f in a) {
                let b = (s = e.resources[f]) != null ? s : e.resources[a[f]], m;
                if (b._resourceType === "uniformGroup") {
                    let x = b;
                    l.ubo.updateUniformGroup(x);
                    let v = x.buffer;
                    m = {
                        buffer: l.buffer.getGPUBuffer(v),
                        offset: 0,
                        size: v.descriptor.size
                    }
                } else if (b._resourceType === "buffer") {
                    let x = b;
                    m = {
                        buffer: l.buffer.getGPUBuffer(x),
                        offset: 0,
                        size: x.descriptor.size
                    }
                } else if (b._resourceType === "bufferResource") {
                    let x = b;
                    m = {
                        buffer: l.buffer.getGPUBuffer(x.buffer),
                        offset: x.offset,
                        size: x.size
                    }
                } else if (b._resourceType === "textureSampler") {
                    let x = b;
                    m = l.texture.getGpuSampler(x)
                } else if (b._resourceType === "textureSource") {
                    let x = b;
                    m = l.texture.getGpuSource(x).createView({})
                }
                o.push({
                    binding: a[f],
                    resource: m
                })
            }
            let u = l.shader.getProgramData(t).bindGroups[r]
              , d = n.createBindGroup({
                layout: u,
                entries: o
            });
            return this._hash[e._key] = d,
            d
        }
        destroy() {
            for (let e of Object.keys(this._hash))
                this._hash[e] = null;
            this._hash = null,
            this._renderer = null
        }
    }
    ;
    Wa.extension = {
        type: [O.WebGPUSystem],
        name: "bindGroup"
    };
    var Ya = class {
        constructor(e) {
            this._gpuBuffers = Object.create(null),
            this._managedBuffers = [],
            e.renderableGC.addManagedHash(this, "_gpuBuffers")
        }
        contextChange(e) {
            this._gpu = e
        }
        getGPUBuffer(e) {
            return this._gpuBuffers[e.uid] || this.createGPUBuffer(e)
        }
        updateBuffer(e) {
            let t = this._gpuBuffers[e.uid] || this.createGPUBuffer(e)
              , r = e.data;
            return e._updateID && r && (e._updateID = 0,
            this._gpu.device.queue.writeBuffer(t, 0, r.buffer, 0, (e._updateSize || r.byteLength) + 3 & -4)),
            t
        }
        destroyAll() {
            for (let e in this._gpuBuffers)
                this._gpuBuffers[e].destroy();
            this._gpuBuffers = {}
        }
        createGPUBuffer(e) {
            this._gpuBuffers[e.uid] || (e.on("update", this.updateBuffer, this),
            e.on("change", this.onBufferChange, this),
            e.on("destroy", this.onBufferDestroy, this),
            this._managedBuffers.push(e));
            let t = this._gpu.device.createBuffer(e.descriptor);
            return e._updateID = 0,
            e.data && (Wc(e.data.buffer, t.getMappedRange()),
            t.unmap()),
            this._gpuBuffers[e.uid] = t,
            t
        }
        onBufferChange(e) {
            this._gpuBuffers[e.uid].destroy(),
            e._updateID = 0,
            this._gpuBuffers[e.uid] = this.createGPUBuffer(e)
        }
        onBufferDestroy(e) {
            this._managedBuffers.splice(this._managedBuffers.indexOf(e), 1),
            this._destroyBuffer(e)
        }
        destroy() {
            this._managedBuffers.forEach(e => this._destroyBuffer(e)),
            this._managedBuffers = null,
            this._gpuBuffers = null
        }
        _destroyBuffer(e) {
            this._gpuBuffers[e.uid].destroy(),
            e.off("update", this.updateBuffer, this),
            e.off("change", this.onBufferChange, this),
            e.off("destroy", this.onBufferDestroy, this),
            this._gpuBuffers[e.uid] = null
        }
    }
    ;
    Ya.extension = {
        type: [O.WebGPUSystem],
        name: "buffer"
    };
    var mh = class {
        constructor({minUniformOffsetAlignment: e}) {
            this._minUniformOffsetAlignment = 256,
            this.byteIndex = 0,
            this._minUniformOffsetAlignment = e,
            this.data = new Float32Array(65535)
        }
        clear() {
            this.byteIndex = 0
        }
        addEmptyGroup(e) {
            if (e > this._minUniformOffsetAlignment / 4)
                throw new Error(`UniformBufferBatch: array is too large: ${e * 4}`);
            let t = this.byteIndex
              , r = t + e * 4;
            if (r = Math.ceil(r / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment,
            r > this.data.length * 4)
                throw new Error("UniformBufferBatch: ubo batch got too big");
            return this.byteIndex = r,
            t
        }
        addGroup(e) {
            let t = this.addEmptyGroup(e.length);
            for (let r = 0; r < e.length; r++)
                this.data[t / 4 + r] = e[r];
            return t
        }
        destroy() {
            this.data = null
        }
    }
      , $a = class {
        constructor(e) {
            this._colorMaskCache = 15,
            this._renderer = e
        }
        setMask(e) {
            this._colorMaskCache !== e && (this._colorMaskCache = e,
            this._renderer.pipeline.setColorMask(e))
        }
        destroy() {
            this._renderer = null,
            this._colorMaskCache = null
        }
    }
    ;
    $a.extension = {
        type: [O.WebGPUSystem],
        name: "colorMask"
    };
    var Es = class {
        constructor(e) {
            this._renderer = e
        }
        async init(e) {
            return this._initPromise ? this._initPromise : (this._initPromise = (e.gpu ? Promise.resolve(e.gpu) : this._createDeviceAndAdaptor(e)).then(t => {
                this.gpu = t,
                this._renderer.runners.contextChange.emit(this.gpu)
            }
            ),
            this._initPromise)
        }
        contextChange(e) {
            this._renderer.gpu = e
        }
        async _createDeviceAndAdaptor(e) {
            let t = await ye.get().getNavigator().gpu.requestAdapter({
                powerPreference: e.powerPreference,
                forceFallbackAdapter: e.forceFallbackAdapter
            })
              , r = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter(n => t.features.has(n))
              , s = await t.requestDevice({
                requiredFeatures: r
            });
            return {
                adapter: t,
                device: s
            }
        }
        destroy() {
            this.gpu = null,
            this._renderer = null
        }
    }
    ;
    Es.extension = {
        type: [O.WebGPUSystem],
        name: "device"
    },
    Es.defaultOptions = {
        powerPreference: void 0,
        forceFallbackAdapter: !1
    };
    var D6 = Object.defineProperty
      , b0 = Object.getOwnPropertySymbols
      , k6 = Object.prototype.hasOwnProperty
      , U6 = Object.prototype.propertyIsEnumerable
      , m0 = (i, e, t) => e in i ? D6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , g0 = (i, e) => {
        for (var t in e || (e = {}))
            k6.call(e, t) && m0(i, t, e[t]);
        if (b0)
            for (var t of b0(e))
                U6.call(e, t) && m0(i, t, e[t]);
        return i
    }
      , Ka = class {
        constructor(e) {
            this._boundBindGroup = Object.create(null),
            this._boundVertexBuffer = Object.create(null),
            this._renderer = e
        }
        renderStart() {
            this.commandFinished = new Promise(e => {
                this._resolveCommandFinished = e
            }
            ),
            this.commandEncoder = this._renderer.gpu.device.createCommandEncoder()
        }
        beginRenderPass(e) {
            this.endRenderPass(),
            this._clearCache(),
            this.renderPassEncoder = this.commandEncoder.beginRenderPass(e.descriptor)
        }
        endRenderPass() {
            this.renderPassEncoder && this.renderPassEncoder.end(),
            this.renderPassEncoder = null
        }
        setViewport(e) {
            this.renderPassEncoder.setViewport(e.x, e.y, e.width, e.height, 0, 1)
        }
        setPipelineFromGeometryProgramAndState(e, t, r, s) {
            let n = this._renderer.pipeline.getPipeline(e, t, r, s);
            this.setPipeline(n)
        }
        setPipeline(e) {
            this._boundPipeline !== e && (this._boundPipeline = e,
            this.renderPassEncoder.setPipeline(e))
        }
        _setVertexBuffer(e, t) {
            this._boundVertexBuffer[e] !== t && (this._boundVertexBuffer[e] = t,
            this.renderPassEncoder.setVertexBuffer(e, this._renderer.buffer.updateBuffer(t)))
        }
        _setIndexBuffer(e) {
            if (this._boundIndexBuffer === e)
                return;
            this._boundIndexBuffer = e;
            let t = e.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
            this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e), t)
        }
        resetBindGroup(e) {
            this._boundBindGroup[e] = null
        }
        setBindGroup(e, t, r) {
            if (this._boundBindGroup[e] === t)
                return;
            this._boundBindGroup[e] = t,
            t._touch(this._renderer.textureGC.count);
            let s = this._renderer.bindGroup.getBindGroup(t, r, e);
            this.renderPassEncoder.setBindGroup(e, s)
        }
        setGeometry(e, t) {
            let r = this._renderer.pipeline.getBufferNamesToBind(e, t);
            for (let s in r)
                this._setVertexBuffer(parseInt(s, 10), e.attributes[r[s]].buffer);
            e.indexBuffer && this._setIndexBuffer(e.indexBuffer)
        }
        _setShaderBindGroups(e, t) {
            for (let r in e.groups) {
                let s = e.groups[r];
                t || this._syncBindGroup(s),
                this.setBindGroup(r, s, e.gpuProgram)
            }
        }
        _syncBindGroup(e) {
            for (let t in e.resources) {
                let r = e.resources[t];
                r.isUniformGroup && this._renderer.ubo.updateUniformGroup(r)
            }
        }
        draw(e) {
            let {geometry: t, shader: r, state: s, topology: n, size: a, start: o, instanceCount: l, skipSync: u} = e;
            this.setPipelineFromGeometryProgramAndState(t, r.gpuProgram, s, n),
            this.setGeometry(t, r.gpuProgram),
            this._setShaderBindGroups(r, u),
            t.indexBuffer ? this.renderPassEncoder.drawIndexed(a || t.indexBuffer.data.length, l ?? t.instanceCount, o || 0) : this.renderPassEncoder.draw(a || t.getSize(), l ?? t.instanceCount, o || 0)
        }
        finishRenderPass() {
            this.renderPassEncoder && (this.renderPassEncoder.end(),
            this.renderPassEncoder = null)
        }
        postrender() {
            this.finishRenderPass(),
            this._gpu.device.queue.submit([this.commandEncoder.finish()]),
            this._resolveCommandFinished(),
            this.commandEncoder = null
        }
        restoreRenderPass() {
            let e = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, !1, [0, 0, 0, 1]);
            this.renderPassEncoder = this.commandEncoder.beginRenderPass(e);
            let t = this._boundPipeline
              , r = g0({}, this._boundVertexBuffer)
              , s = this._boundIndexBuffer
              , n = g0({}, this._boundBindGroup);
            this._clearCache();
            let a = this._renderer.renderTarget.viewport;
            this.renderPassEncoder.setViewport(a.x, a.y, a.width, a.height, 0, 1),
            this.setPipeline(t);
            for (let o in r)
                this._setVertexBuffer(o, r[o]);
            for (let o in n)
                this.setBindGroup(o, n[o], null);
            this._setIndexBuffer(s)
        }
        _clearCache() {
            for (let e = 0; e < 16; e++)
                this._boundBindGroup[e] = null,
                this._boundVertexBuffer[e] = null;
            this._boundIndexBuffer = null,
            this._boundPipeline = null
        }
        destroy() {
            this._renderer = null,
            this._gpu = null,
            this._boundBindGroup = null,
            this._boundVertexBuffer = null,
            this._boundIndexBuffer = null,
            this._boundPipeline = null
        }
        contextChange(e) {
            this._gpu = e
        }
    }
    ;
    Ka.extension = {
        type: [O.WebGPUSystem],
        name: "encoder",
        priority: 1
    };
    var qa = class {
        constructor(e) {
            this._renderer = e
        }
        contextChange() {
            this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage,
            this.maxBatchableTextures = this.maxTextures
        }
        destroy() {}
    }
    ;
    qa.extension = {
        type: [O.WebGPUSystem],
        name: "limits"
    };
    var Za = class {
        constructor(e) {
            this._renderTargetStencilState = Object.create(null),
            this._renderer = e,
            e.renderTarget.onRenderTargetChange.add(this)
        }
        onRenderTargetChange(e) {
            let t = this._renderTargetStencilState[e.uid];
            t || (t = this._renderTargetStencilState[e.uid] = {
                stencilMode: qe.DISABLED,
                stencilReference: 0
            }),
            this._activeRenderTarget = e,
            this.setStencilMode(t.stencilMode, t.stencilReference)
        }
        setStencilMode(e, t) {
            let r = this._renderTargetStencilState[this._activeRenderTarget.uid];
            r.stencilMode = e,
            r.stencilReference = t;
            let s = this._renderer;
            s.pipeline.setStencilMode(e),
            s.encoder.renderPassEncoder.setStencilReference(t)
        }
        destroy() {
            this._renderer.renderTarget.onRenderTargetChange.remove(this),
            this._renderer = null,
            this._activeRenderTarget = null,
            this._renderTargetStencilState = null
        }
    }
    ;
    Za.extension = {
        type: [O.WebGPUSystem],
        name: "stencil"
    };
    var dn = {
        i32: {
            align: 4,
            size: 4
        },
        u32: {
            align: 4,
            size: 4
        },
        f32: {
            align: 4,
            size: 4
        },
        f16: {
            align: 2,
            size: 2
        },
        "vec2<i32>": {
            align: 8,
            size: 8
        },
        "vec2<u32>": {
            align: 8,
            size: 8
        },
        "vec2<f32>": {
            align: 8,
            size: 8
        },
        "vec2<f16>": {
            align: 4,
            size: 4
        },
        "vec3<i32>": {
            align: 16,
            size: 12
        },
        "vec3<u32>": {
            align: 16,
            size: 12
        },
        "vec3<f32>": {
            align: 16,
            size: 12
        },
        "vec3<f16>": {
            align: 8,
            size: 6
        },
        "vec4<i32>": {
            align: 16,
            size: 16
        },
        "vec4<u32>": {
            align: 16,
            size: 16
        },
        "vec4<f32>": {
            align: 16,
            size: 16
        },
        "vec4<f16>": {
            align: 8,
            size: 8
        },
        "mat2x2<f32>": {
            align: 8,
            size: 16
        },
        "mat2x2<f16>": {
            align: 4,
            size: 8
        },
        "mat3x2<f32>": {
            align: 8,
            size: 24
        },
        "mat3x2<f16>": {
            align: 4,
            size: 12
        },
        "mat4x2<f32>": {
            align: 8,
            size: 32
        },
        "mat4x2<f16>": {
            align: 4,
            size: 16
        },
        "mat2x3<f32>": {
            align: 16,
            size: 32
        },
        "mat2x3<f16>": {
            align: 8,
            size: 16
        },
        "mat3x3<f32>": {
            align: 16,
            size: 48
        },
        "mat3x3<f16>": {
            align: 8,
            size: 24
        },
        "mat4x3<f32>": {
            align: 16,
            size: 64
        },
        "mat4x3<f16>": {
            align: 8,
            size: 32
        },
        "mat2x4<f32>": {
            align: 16,
            size: 32
        },
        "mat2x4<f16>": {
            align: 8,
            size: 16
        },
        "mat3x4<f32>": {
            align: 16,
            size: 48
        },
        "mat3x4<f16>": {
            align: 8,
            size: 24
        },
        "mat4x4<f32>": {
            align: 16,
            size: 64
        },
        "mat4x4<f16>": {
            align: 8,
            size: 32
        }
    };
    function L6(i) {
        let e = i.map(r => ({
            data: r,
            offset: 0,
            size: 0
        }))
          , t = 0;
        for (let r = 0; r < e.length; r++) {
            let s = e[r]
              , n = dn[s.data.type].size
              , a = dn[s.data.type].align;
            if (!dn[s.data.type])
                throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${s.data.type}`);
            s.data.size > 1 && (n = Math.max(n, a) * s.data.size),
            t = Math.ceil(t / a) * a,
            s.size = n,
            s.offset = t,
            t += n
        }
        return t = Math.ceil(t / 16) * 16,
        {
            uboElements: e,
            size: t
        }
    }
    function N6(i, e) {
        let {size: t, align: r} = dn[i.data.type]
          , s = (r - t) / 4
          , n = i.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
        return `
         v = uv.${i.data.name};
         ${e !== 0 ? `offset += ${e};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${i.data.size * (t / 4)}; i++)
         {
             for(var j = 0; j < ${t / 4}; j++)
             {
                 ${n}[arrayOffset++] = v[t++];
             }
             ${s !== 0 ? `arrayOffset += ${s};` : ""}
         }
     `
    }
    function X6(i) {
        return ng(i, "uboWgsl", N6, J5)
    }
    var Qa = class extends Ma {
        constructor() {
            super({
                createUboElements: L6,
                generateUboSync: X6
            })
        }
    }
    ;
    Qa.extension = {
        type: [O.WebGPUSystem],
        name: "ubo"
    };
    var Ai = 128
      , Ja = class {
        constructor(e) {
            this._bindGroupHash = Object.create(null),
            this._buffers = [],
            this._bindGroups = [],
            this._bufferResources = [],
            this._renderer = e,
            this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"),
            this._batchBuffer = new mh({
                minUniformOffsetAlignment: Ai
            });
            let t = 256 / Ai;
            for (let r = 0; r < t; r++) {
                let s = Pe.UNIFORM | Pe.COPY_DST;
                r === 0 && (s |= Pe.COPY_SRC),
                this._buffers.push(new bt({
                    data: this._batchBuffer.data,
                    usage: s
                }))
            }
        }
        renderEnd() {
            this._uploadBindGroups(),
            this._resetBindGroups()
        }
        _resetBindGroups() {
            for (let e in this._bindGroupHash)
                this._bindGroupHash[e] = null;
            this._batchBuffer.clear()
        }
        getUniformBindGroup(e, t) {
            if (!t && this._bindGroupHash[e.uid])
                return this._bindGroupHash[e.uid];
            this._renderer.ubo.ensureUniformGroup(e);
            let r = e.buffer.data
              , s = this._batchBuffer.addEmptyGroup(r.length);
            return this._renderer.ubo.syncUniformGroup(e, this._batchBuffer.data, s / 4),
            this._bindGroupHash[e.uid] = this._getBindGroup(s / Ai),
            this._bindGroupHash[e.uid]
        }
        getUboResource(e) {
            this._renderer.ubo.updateUniformGroup(e);
            let t = e.buffer.data
              , r = this._batchBuffer.addGroup(t);
            return this._getBufferResource(r / Ai)
        }
        getArrayBindGroup(e) {
            let t = this._batchBuffer.addGroup(e);
            return this._getBindGroup(t / Ai)
        }
        getArrayBufferResource(e) {
            let t = this._batchBuffer.addGroup(e) / Ai;
            return this._getBufferResource(t)
        }
        _getBufferResource(e) {
            if (!this._bufferResources[e]) {
                let t = this._buffers[e % 2];
                this._bufferResources[e] = new ws({
                    buffer: t,
                    offset: (e / 2 | 0) * 256,
                    size: Ai
                })
            }
            return this._bufferResources[e]
        }
        _getBindGroup(e) {
            if (!this._bindGroups[e]) {
                let t = new Yt({
                    0: this._getBufferResource(e)
                });
                this._bindGroups[e] = t
            }
            return this._bindGroups[e]
        }
        _uploadBindGroups() {
            let e = this._renderer.buffer
              , t = this._buffers[0];
            t.update(this._batchBuffer.byteIndex),
            e.updateBuffer(t);
            let r = this._renderer.gpu.device.createCommandEncoder();
            for (let s = 1; s < this._buffers.length; s++) {
                let n = this._buffers[s];
                r.copyBufferToBuffer(e.getGPUBuffer(t), Ai, e.getGPUBuffer(n), 0, this._batchBuffer.byteIndex)
            }
            this._renderer.gpu.device.queue.submit([r.finish()])
        }
        destroy() {
            var e;
            for (let t = 0; t < this._bindGroups.length; t++)
                (e = this._bindGroups[t]) == null || e.destroy();
            this._bindGroups = null,
            this._bindGroupHash = null;
            for (let t = 0; t < this._buffers.length; t++)
                this._buffers[t].destroy();
            this._buffers = null;
            for (let t = 0; t < this._bufferResources.length; t++)
                this._bufferResources[t].destroy();
            this._bufferResources = null,
            this._batchBuffer.destroy(),
            this._bindGroupHash = null,
            this._renderer = null
        }
    }
    ;
    Ja.extension = {
        type: [O.WebGPUPipes],
        name: "uniformBatch"
    };
    var j6 = Object.defineProperty
      , H6 = Object.defineProperties
      , z6 = Object.getOwnPropertyDescriptors
      , _0 = Object.getOwnPropertySymbols
      , V6 = Object.prototype.hasOwnProperty
      , W6 = Object.prototype.propertyIsEnumerable
      , x0 = (i, e, t) => e in i ? j6(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Y6 = (i, e) => {
        for (var t in e || (e = {}))
            V6.call(e, t) && x0(i, t, e[t]);
        if (_0)
            for (var t of _0(e))
                W6.call(e, t) && x0(i, t, e[t]);
        return i
    }
      , $6 = (i, e) => H6(i, z6(e))
      , K6 = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4
    };
    function q6(i, e, t, r, s) {
        return i << 24 | e << 16 | t << 10 | r << 5 | s
    }
    function Z6(i, e, t, r) {
        return t << 6 | i << 3 | r << 1 | e
    }
    var eo = class {
        constructor(e) {
            this._moduleCache = Object.create(null),
            this._bufferLayoutsCache = Object.create(null),
            this._bindingNamesCache = Object.create(null),
            this._pipeCache = Object.create(null),
            this._pipeStateCaches = Object.create(null),
            this._colorMask = 15,
            this._multisampleCount = 1,
            this._renderer = e
        }
        contextChange(e) {
            this._gpu = e,
            this.setStencilMode(qe.DISABLED),
            this._updatePipeHash()
        }
        setMultisampleCount(e) {
            this._multisampleCount !== e && (this._multisampleCount = e,
            this._updatePipeHash())
        }
        setRenderTarget(e) {
            this._multisampleCount = e.msaaSamples,
            this._depthStencilAttachment = e.descriptor.depthStencilAttachment ? 1 : 0,
            this._updatePipeHash()
        }
        setColorMask(e) {
            this._colorMask !== e && (this._colorMask = e,
            this._updatePipeHash())
        }
        setStencilMode(e) {
            this._stencilMode !== e && (this._stencilMode = e,
            this._stencilState = Ei[e],
            this._updatePipeHash())
        }
        setPipeline(e, t, r, s) {
            let n = this.getPipeline(e, t, r);
            s.setPipeline(n)
        }
        getPipeline(e, t, r, s) {
            e._layoutKey || (tg(e, t.attributeData),
            this._generateBufferKey(e)),
            s || (s = e.topology);
            let n = q6(e._layoutKey, t._layoutKey, r.data, r._blendModeId, K6[s]);
            return this._pipeCache[n] ? this._pipeCache[n] : (this._pipeCache[n] = this._createPipeline(e, t, r, s),
            this._pipeCache[n])
        }
        _createPipeline(e, t, r, s) {
            let n = this._gpu.device
              , a = this._createVertexBufferLayouts(e, t)
              , o = this._renderer.state.getColorTargets(r);
            o[0].writeMask = this._stencilMode === qe.RENDERING_MASK_ADD ? 0 : this._colorMask;
            let l = this._renderer.shader.getProgramData(t).pipeline
              , u = {
                vertex: {
                    module: this._getModule(t.vertex.source),
                    entryPoint: t.vertex.entryPoint,
                    buffers: a
                },
                fragment: {
                    module: this._getModule(t.fragment.source),
                    entryPoint: t.fragment.entryPoint,
                    targets: o
                },
                primitive: {
                    topology: s,
                    cullMode: r.cullMode
                },
                layout: l,
                multisample: {
                    count: this._multisampleCount
                },
                label: "PIXI Pipeline"
            };
            return this._depthStencilAttachment && (u.depthStencil = $6(Y6({}, this._stencilState), {
                format: "depth24plus-stencil8",
                depthWriteEnabled: r.depthTest,
                depthCompare: r.depthTest ? "less" : "always"
            })),
            n.createRenderPipeline(u)
        }
        _getModule(e) {
            return this._moduleCache[e] || this._createModule(e)
        }
        _createModule(e) {
            let t = this._gpu.device;
            return this._moduleCache[e] = t.createShaderModule({
                code: e
            }),
            this._moduleCache[e]
        }
        _generateBufferKey(e) {
            let t = []
              , r = 0
              , s = Object.keys(e.attributes).sort();
            for (let a = 0; a < s.length; a++) {
                let o = e.attributes[s[a]];
                t[r++] = o.offset,
                t[r++] = o.format,
                t[r++] = o.stride,
                t[r++] = o.instance
            }
            let n = t.join("|");
            return e._layoutKey = bs(n, "geometry"),
            e._layoutKey
        }
        _generateAttributeLocationsKey(e) {
            let t = []
              , r = 0
              , s = Object.keys(e.attributeData).sort();
            for (let a = 0; a < s.length; a++) {
                let o = e.attributeData[s[a]];
                t[r++] = o.location
            }
            let n = t.join("|");
            return e._attributeLocationsKey = bs(n, "programAttributes"),
            e._attributeLocationsKey
        }
        getBufferNamesToBind(e, t) {
            let r = e._layoutKey << 16 | t._attributeLocationsKey;
            if (this._bindingNamesCache[r])
                return this._bindingNamesCache[r];
            let s = this._createVertexBufferLayouts(e, t)
              , n = Object.create(null)
              , a = t.attributeData;
            for (let o = 0; o < s.length; o++) {
                let l = Object.values(s[o].attributes)[0].shaderLocation;
                for (let u in a)
                    if (a[u].location === l) {
                        n[o] = u;
                        break
                    }
            }
            return this._bindingNamesCache[r] = n,
            n
        }
        _createVertexBufferLayouts(e, t) {
            t._attributeLocationsKey || this._generateAttributeLocationsKey(t);
            let r = e._layoutKey << 16 | t._attributeLocationsKey;
            if (this._bufferLayoutsCache[r])
                return this._bufferLayoutsCache[r];
            let s = [];
            return e.buffers.forEach(n => {
                var a;
                let o = {
                    arrayStride: 0,
                    stepMode: "vertex",
                    attributes: []
                }
                  , l = o.attributes;
                for (let u in t.attributeData) {
                    let d = e.attributes[u];
                    ((a = d.divisor) != null ? a : 1) !== 1 && _i(`Attribute ${u} has an invalid divisor value of '${d.divisor}'. WebGPU only supports a divisor value of 1`),
                    d.buffer === n && (o.arrayStride = d.stride,
                    o.stepMode = d.instance ? "instance" : "vertex",
                    l.push({
                        shaderLocation: t.attributeData[u].location,
                        offset: d.offset,
                        format: d.format
                    }))
                }
                l.length && s.push(o)
            }
            ),
            this._bufferLayoutsCache[r] = s,
            s
        }
        _updatePipeHash() {
            let e = Z6(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
            this._pipeStateCaches[e] || (this._pipeStateCaches[e] = Object.create(null)),
            this._pipeCache = this._pipeStateCaches[e]
        }
        destroy() {
            this._renderer = null,
            this._bufferLayoutsCache = null
        }
    }
    ;
    eo.extension = {
        type: [O.WebGPUSystem],
        name: "pipeline"
    };
    var gh = class {
        constructor() {
            this.contexts = [],
            this.msaaTextures = [],
            this.msaaSamples = 1
        }
    }
      , _h = class {
        init(e, t) {
            this._renderer = e,
            this._renderTargetSystem = t
        }
        copyToTexture(e, t, r, s, n) {
            let a = this._renderer
              , o = this._getGpuColorTexture(e)
              , l = a.texture.getGpuSource(t.source);
            return a.encoder.commandEncoder.copyTextureToTexture({
                texture: o,
                origin: r
            }, {
                texture: l,
                origin: n
            }, s),
            t
        }
        startRenderPass(e, t=!0, r, s) {
            let n = this._renderTargetSystem.getGpuRenderTarget(e)
              , a = this.getDescriptor(e, t, r);
            n.descriptor = a,
            this._renderer.pipeline.setRenderTarget(n),
            this._renderer.encoder.beginRenderPass(n),
            this._renderer.encoder.setViewport(s)
        }
        finishRenderPass() {
            this._renderer.encoder.endRenderPass()
        }
        _getGpuColorTexture(e) {
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            return t.contexts[0] ? t.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(e.colorTextures[0].source)
        }
        getDescriptor(e, t, r) {
            typeof t == "boolean" && (t = t ? Rt.ALL : Rt.NONE);
            let s = this._renderTargetSystem, n = s.getGpuRenderTarget(e), a = e.colorTextures.map( (l, u) => {
                let d = n.contexts[u], f, b;
                d ? f = d.getCurrentTexture().createView() : f = this._renderer.texture.getGpuSource(l).createView({
                    mipLevelCount: 1
                }),
                n.msaaTextures[u] && (b = f,
                f = this._renderer.texture.getTextureView(n.msaaTextures[u]));
                let m = t & Rt.COLOR ? "clear" : "load";
                return r != null || (r = s.defaultClearColor),
                {
                    view: f,
                    resolveTarget: b,
                    clearValue: r,
                    storeOp: "store",
                    loadOp: m
                }
            }
            ), o;
            if ((e.stencil || e.depth) && !e.depthStencilTexture && (e.ensureDepthStencilTexture(),
            e.depthStencilTexture.source.sampleCount = n.msaa ? 4 : 1),
            e.depthStencilTexture) {
                let l = t & Rt.STENCIL ? "clear" : "load"
                  , u = t & Rt.DEPTH ? "clear" : "load";
                o = {
                    view: this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),
                    stencilStoreOp: "store",
                    stencilLoadOp: l,
                    depthClearValue: 1,
                    depthLoadOp: u,
                    depthStoreOp: "store"
                }
            }
            return {
                colorAttachments: a,
                depthStencilAttachment: o
            }
        }
        clear(e, t=!0, r, s) {
            if (!t)
                return;
            let {gpu: n, encoder: a} = this._renderer
              , o = n.device;
            if (a.commandEncoder === null) {
                let l = o.createCommandEncoder()
                  , u = this.getDescriptor(e, t, r)
                  , d = l.beginRenderPass(u);
                d.setViewport(s.x, s.y, s.width, s.height, 0, 1),
                d.end();
                let f = l.finish();
                o.queue.submit([f])
            } else
                this.startRenderPass(e, t, r, s)
        }
        initGpuRenderTarget(e) {
            e.isRoot = !0;
            let t = new gh;
            return e.colorTextures.forEach( (r, s) => {
                if (r instanceof Wt) {
                    let n = r.resource.getContext("webgpu")
                      , a = r.transparent ? "premultiplied" : "opaque";
                    try {
                        n.configure({
                            device: this._renderer.gpu.device,
                            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                            format: "bgra8unorm",
                            alphaMode: a
                        })
                    } catch {}
                    t.contexts[s] = n
                }
                if (t.msaa = r.source.antialias,
                r.source.antialias) {
                    let n = new Xe({
                        width: 0,
                        height: 0,
                        sampleCount: 4
                    });
                    t.msaaTextures[s] = n
                }
            }
            ),
            t.msaa && (t.msaaSamples = 4,
            e.depthStencilTexture && (e.depthStencilTexture.source.sampleCount = 4)),
            t
        }
        destroyGpuRenderTarget(e) {
            e.contexts.forEach(t => {
                t.unconfigure()
            }
            ),
            e.msaaTextures.forEach(t => {
                t.destroy()
            }
            ),
            e.msaaTextures.length = 0,
            e.contexts.length = 0
        }
        ensureDepthStencilTexture(e) {
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            e.depthStencilTexture && t.msaa && (e.depthStencilTexture.source.sampleCount = 4)
        }
        resizeGpuRenderTarget(e) {
            let t = this._renderTargetSystem.getGpuRenderTarget(e);
            t.width = e.width,
            t.height = e.height,
            t.msaa && e.colorTextures.forEach( (r, s) => {
                let n = t.msaaTextures[s];
                n?.resize(r.source.width, r.source.height, r.source._resolution)
            }
            )
        }
    }
      , to = class extends Oa {
        constructor(e) {
            super(e),
            this.adaptor = new _h,
            this.adaptor.init(e, this)
        }
    }
    ;
    to.extension = {
        type: [O.WebGPUSystem],
        name: "renderTarget"
    };
    var io = class {
        constructor() {
            this._gpuProgramData = Object.create(null)
        }
        contextChange(e) {
            this._gpu = e
        }
        getProgramData(e) {
            return this._gpuProgramData[e._layoutKey] || this._createGPUProgramData(e)
        }
        _createGPUProgramData(e) {
            let t = this._gpu.device
              , r = e.gpuLayout.map(n => t.createBindGroupLayout({
                entries: n
            }))
              , s = {
                bindGroupLayouts: r
            };
            return this._gpuProgramData[e._layoutKey] = {
                bindGroups: r,
                pipeline: t.createPipelineLayout(s)
            },
            this._gpuProgramData[e._layoutKey]
        }
        destroy() {
            this._gpu = null,
            this._gpuProgramData = null
        }
    }
    ;
    io.extension = {
        type: [O.WebGPUSystem],
        name: "shader"
    };
    var xt = {};
    xt.normal = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        }
    },
    xt.add = {
        alpha: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "add"
        }
    },
    xt.multiply = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "dst",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        }
    },
    xt.screen = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one-minus-src",
            operation: "add"
        }
    },
    xt.overlay = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one-minus-src",
            operation: "add"
        }
    },
    xt.none = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "zero",
            dstFactor: "zero",
            operation: "add"
        }
    },
    xt["normal-npm"] = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        }
    },
    xt["add-npm"] = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "add"
        },
        color: {
            srcFactor: "src-alpha",
            dstFactor: "one",
            operation: "add"
        }
    },
    xt["screen-npm"] = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src",
            operation: "add"
        }
    },
    xt.erase = {
        alpha: {
            srcFactor: "zero",
            dstFactor: "one-minus-src-alpha",
            operation: "add"
        },
        color: {
            srcFactor: "zero",
            dstFactor: "one-minus-src",
            operation: "add"
        }
    },
    xt.min = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "min"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "min"
        }
    },
    xt.max = {
        alpha: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "max"
        },
        color: {
            srcFactor: "one",
            dstFactor: "one",
            operation: "max"
        }
    };
    var ro = class {
        constructor() {
            this.defaultState = new Ut,
            this.defaultState.blend = !0
        }
        contextChange(e) {
            this.gpu = e
        }
        getColorTargets(e) {
            return [{
                format: "bgra8unorm",
                writeMask: 0,
                blend: xt[e.blendMode] || xt.normal
            }]
        }
        destroy() {
            this.gpu = null
        }
    }
    ;
    ro.extension = {
        type: [O.WebGPUSystem],
        name: "state"
    };
    var Q6 = {
        type: "image",
        upload(i, e, t) {
            let r = i.resource
              , s = (i.pixelWidth | 0) * (i.pixelHeight | 0)
              , n = r.byteLength / s;
            t.device.queue.writeTexture({
                texture: e
            }, r, {
                offset: 0,
                rowsPerImage: i.pixelHeight,
                bytesPerRow: i.pixelHeight * n
            }, {
                width: i.pixelWidth,
                height: i.pixelHeight,
                depthOrArrayLayers: 1
            })
        }
    }
      , Eg = {
        "bc1-rgba-unorm": {
            blockBytes: 8,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc2-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc3-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc7-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "etc1-rgb-unorm": {
            blockBytes: 8,
            blockWidth: 4,
            blockHeight: 4
        },
        "etc2-rgba8unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "astc-4x4-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        }
    }
      , J6 = {
        blockBytes: 4,
        blockWidth: 1,
        blockHeight: 1
    }
      , eS = {
        type: "compressed",
        upload(i, e, t) {
            let r = i.pixelWidth
              , s = i.pixelHeight
              , n = Eg[i.format] || J6;
            for (let a = 0; a < i.resource.length; a++) {
                let o = i.resource[a]
                  , l = Math.ceil(r / n.blockWidth) * n.blockBytes;
                t.device.queue.writeTexture({
                    texture: e,
                    mipLevel: a
                }, o, {
                    offset: 0,
                    bytesPerRow: l
                }, {
                    width: Math.ceil(r / n.blockWidth) * n.blockWidth,
                    height: Math.ceil(s / n.blockHeight) * n.blockHeight,
                    depthOrArrayLayers: 1
                }),
                r = Math.max(r >> 1, 1),
                s = Math.max(s >> 1, 1)
            }
        }
    }
      , Pg = {
        type: "image",
        upload(i, e, t) {
            let r = i.resource;
            if (!r)
                return;
            if (globalThis.HTMLImageElement && r instanceof HTMLImageElement) {
                let o = ye.get().createCanvas(r.width, r.height);
                o.getContext("2d").drawImage(r, 0, 0, r.width, r.height),
                i.resource = o
            }
            let s = Math.min(e.width, i.resourceWidth || i.pixelWidth)
              , n = Math.min(e.height, i.resourceHeight || i.pixelHeight)
              , a = i.alphaMode === "premultiply-alpha-on-upload";
            t.device.queue.copyExternalImageToTexture({
                source: r
            }, {
                texture: e,
                premultipliedAlpha: a
            }, {
                width: s,
                height: n
            })
        }
    }
      , tS = {
        type: "video",
        upload(i, e, t) {
            Pg.upload(i, e, t)
        }
    }
      , xh = class {
        constructor(e) {
            this.device = e,
            this.sampler = e.createSampler({
                minFilter: "linear"
            }),
            this.pipelines = {}
        }
        _getMipmapPipeline(e) {
            let t = this.pipelines[e];
            return t || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
                code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
            })),
            t = this.device.createRenderPipeline({
                layout: "auto",
                vertex: {
                    module: this.mipmapShaderModule,
                    entryPoint: "vertexMain"
                },
                fragment: {
                    module: this.mipmapShaderModule,
                    entryPoint: "fragmentMain",
                    targets: [{
                        format: e
                    }]
                }
            }),
            this.pipelines[e] = t),
            t
        }
        generateMipmap(e) {
            let t = this._getMipmapPipeline(e.format);
            if (e.dimension === "3d" || e.dimension === "1d")
                throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
            let r = e
              , s = e.depthOrArrayLayers || 1
              , n = e.usage & GPUTextureUsage.RENDER_ATTACHMENT;
            if (!n) {
                let l = {
                    size: {
                        width: Math.ceil(e.width / 2),
                        height: Math.ceil(e.height / 2),
                        depthOrArrayLayers: s
                    },
                    format: e.format,
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
                    mipLevelCount: e.mipLevelCount - 1
                };
                r = this.device.createTexture(l)
            }
            let a = this.device.createCommandEncoder({})
              , o = t.getBindGroupLayout(0);
            for (let l = 0; l < s; ++l) {
                let u = e.createView({
                    baseMipLevel: 0,
                    mipLevelCount: 1,
                    dimension: "2d",
                    baseArrayLayer: l,
                    arrayLayerCount: 1
                })
                  , d = n ? 1 : 0;
                for (let f = 1; f < e.mipLevelCount; ++f) {
                    let b = r.createView({
                        baseMipLevel: d++,
                        mipLevelCount: 1,
                        dimension: "2d",
                        baseArrayLayer: l,
                        arrayLayerCount: 1
                    })
                      , m = a.beginRenderPass({
                        colorAttachments: [{
                            view: b,
                            storeOp: "store",
                            loadOp: "clear",
                            clearValue: {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            }
                        }]
                    })
                      , x = this.device.createBindGroup({
                        layout: o,
                        entries: [{
                            binding: 0,
                            resource: this.sampler
                        }, {
                            binding: 1,
                            resource: u
                        }]
                    });
                    m.setPipeline(t),
                    m.setBindGroup(0, x),
                    m.draw(3, 1, 0, 0),
                    m.end(),
                    u = b
                }
            }
            if (!n) {
                let l = {
                    width: Math.ceil(e.width / 2),
                    height: Math.ceil(e.height / 2),
                    depthOrArrayLayers: s
                };
                for (let u = 1; u < e.mipLevelCount; ++u)
                    a.copyTextureToTexture({
                        texture: r,
                        mipLevel: u - 1
                    }, {
                        texture: e,
                        mipLevel: u
                    }, l),
                    l.width = Math.ceil(l.width / 2),
                    l.height = Math.ceil(l.height / 2)
            }
            return this.device.queue.submit([a.finish()]),
            n || r.destroy(),
            e
        }
    }
      , so = class {
        constructor(e) {
            this.managedTextures = [],
            this._gpuSources = Object.create(null),
            this._gpuSamplers = Object.create(null),
            this._bindGroupHash = Object.create(null),
            this._textureViewHash = Object.create(null),
            this._uploads = {
                image: Pg,
                buffer: Q6,
                video: tS,
                compressed: eS
            },
            this._renderer = e,
            e.renderableGC.addManagedHash(this, "_gpuSources"),
            e.renderableGC.addManagedHash(this, "_gpuSamplers"),
            e.renderableGC.addManagedHash(this, "_bindGroupHash"),
            e.renderableGC.addManagedHash(this, "_textureViewHash")
        }
        contextChange(e) {
            this._gpu = e
        }
        initSource(e) {
            return this._gpuSources[e.uid] ? this._gpuSources[e.uid] : this._initSource(e)
        }
        _initSource(e) {
            if (e.autoGenerateMipmaps) {
                let l = Math.max(e.pixelWidth, e.pixelHeight);
                e.mipLevelCount = Math.floor(Math.log2(l)) + 1
            }
            let t = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
            e.uploadMethodId !== "compressed" && (t |= GPUTextureUsage.RENDER_ATTACHMENT,
            t |= GPUTextureUsage.COPY_SRC);
            let r = Eg[e.format] || {
                blockBytes: 4,
                blockWidth: 1,
                blockHeight: 1
            }
              , s = Math.ceil(e.pixelWidth / r.blockWidth) * r.blockWidth
              , n = Math.ceil(e.pixelHeight / r.blockHeight) * r.blockHeight
              , a = {
                label: e.label,
                size: {
                    width: s,
                    height: n
                },
                format: e.format,
                sampleCount: e.sampleCount,
                mipLevelCount: e.mipLevelCount,
                dimension: e.dimension,
                usage: t
            }
              , o = this._gpuSources[e.uid] = this._gpu.device.createTexture(a);
            return this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this),
            e.on("resize", this.onSourceResize, this),
            e.on("destroy", this.onSourceDestroy, this),
            e.on("unload", this.onSourceUnload, this),
            e.on("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.push(e)),
            this.onSourceUpdate(e),
            o
        }
        onSourceUpdate(e) {
            let t = this.getGpuSource(e);
            t && (this._uploads[e.uploadMethodId] && this._uploads[e.uploadMethodId].upload(e, t, this._gpu),
            e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e))
        }
        onSourceUnload(e) {
            let t = this._gpuSources[e.uid];
            t && (this._gpuSources[e.uid] = null,
            t.destroy())
        }
        onUpdateMipmaps(e) {
            this._mipmapGenerator || (this._mipmapGenerator = new xh(this._gpu.device));
            let t = this.getGpuSource(e);
            this._mipmapGenerator.generateMipmap(t)
        }
        onSourceDestroy(e) {
            e.off("update", this.onSourceUpdate, this),
            e.off("unload", this.onSourceUnload, this),
            e.off("destroy", this.onSourceDestroy, this),
            e.off("resize", this.onSourceResize, this),
            e.off("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
            this.onSourceUnload(e)
        }
        onSourceResize(e) {
            let t = this._gpuSources[e.uid];
            t ? (t.width !== e.pixelWidth || t.height !== e.pixelHeight) && (this._textureViewHash[e.uid] = null,
            this._bindGroupHash[e.uid] = null,
            this.onSourceUnload(e),
            this.initSource(e)) : this.initSource(e)
        }
        _initSampler(e) {
            return this._gpuSamplers[e._resourceId] = this._gpu.device.createSampler(e),
            this._gpuSamplers[e._resourceId]
        }
        getGpuSampler(e) {
            return this._gpuSamplers[e._resourceId] || this._initSampler(e)
        }
        getGpuSource(e) {
            return this._gpuSources[e.uid] || this.initSource(e)
        }
        getTextureBindGroup(e) {
            var t;
            return (t = this._bindGroupHash[e.uid]) != null ? t : this._createTextureBindGroup(e)
        }
        _createTextureBindGroup(e) {
            let t = e.source;
            return this._bindGroupHash[e.uid] = new Yt({
                0: t,
                1: t.style,
                2: new ot({
                    uTextureMatrix: {
                        type: "mat3x3<f32>",
                        value: e.textureMatrix.mapCoord
                    }
                })
            }),
            this._bindGroupHash[e.uid]
        }
        getTextureView(e) {
            var t;
            let r = e.source;
            return (t = this._textureViewHash[r.uid]) != null ? t : this._createTextureView(r)
        }
        _createTextureView(e) {
            return this._textureViewHash[e.uid] = this.getGpuSource(e).createView(),
            this._textureViewHash[e.uid]
        }
        generateCanvas(e) {
            let t = this._renderer
              , r = t.gpu.device.createCommandEncoder()
              , s = ye.get().createCanvas();
            s.width = e.source.pixelWidth,
            s.height = e.source.pixelHeight;
            let n = s.getContext("webgpu");
            return n.configure({
                device: t.gpu.device,
                usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
                format: ye.get().getNavigator().gpu.getPreferredCanvasFormat(),
                alphaMode: "premultiplied"
            }),
            r.copyTextureToTexture({
                texture: t.texture.getGpuSource(e.source),
                origin: {
                    x: 0,
                    y: 0
                }
            }, {
                texture: n.getCurrentTexture()
            }, {
                width: s.width,
                height: s.height
            }),
            t.gpu.device.queue.submit([r.finish()]),
            s
        }
        getPixels(e) {
            let t = this.generateCanvas(e)
              , r = xi.getOptimalCanvasAndContext(t.width, t.height)
              , s = r.context;
            s.drawImage(t, 0, 0);
            let {width: n, height: a} = t
              , o = s.getImageData(0, 0, n, a)
              , l = new Uint8ClampedArray(o.data.buffer);
            return xi.returnCanvasAndContext(r),
            {
                pixels: l,
                width: n,
                height: a
            }
        }
        destroy() {
            this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)),
            this.managedTextures = null;
            for (let e of Object.keys(this._bindGroupHash)) {
                let t = Number(e)
                  , r = this._bindGroupHash[t];
                r?.destroy(),
                this._bindGroupHash[t] = null
            }
            this._gpu = null,
            this._mipmapGenerator = null,
            this._gpuSources = null,
            this._bindGroupHash = null,
            this._textureViewHash = null,
            this._gpuSamplers = null
        }
    }
    ;
    so.extension = {
        type: [O.WebGPUSystem],
        name: "texture"
    };
    var no = class {
        constructor() {
            this._maxTextures = 0
        }
        contextChange(e) {
            let t = new ot({
                uTransformMatrix: {
                    value: new ce,
                    type: "mat3x3<f32>"
                },
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            });
            this._maxTextures = e.limits.maxBatchableTextures;
            let r = Ps({
                name: "graphics",
                bits: [Mh, Oh(this._maxTextures), i3, Ms]
            });
            this.shader = new vt({
                gpuProgram: r,
                resources: {
                    localUniforms: t
                }
            })
        }
        execute(e, t) {
            let r = t.context
              , s = r.customShader || this.shader
              , n = e.renderer
              , a = n.graphicsContext
              , {batcher: o, instructions: l} = a.getContextRenderData(r)
              , u = n.encoder;
            u.setGeometry(o.geometry, s.gpuProgram);
            let d = n.globalUniforms.bindGroup;
            u.setBindGroup(0, d, s.gpuProgram);
            let f = n.renderPipes.uniformBatch.getUniformBindGroup(s.resources.localUniforms, !0);
            u.setBindGroup(2, f, s.gpuProgram);
            let b = l.instructions
              , m = null;
            for (let x = 0; x < l.instructionSize; x++) {
                let v = b[x];
                if (v.topology !== m && (m = v.topology,
                u.setPipelineFromGeometryProgramAndState(o.geometry, s.gpuProgram, e.state, v.topology)),
                s.groups[1] = v.bindGroup,
                !v.gpuBindGroup) {
                    let S = v.textures;
                    v.bindGroup = Rh(S.textures, S.count, this._maxTextures),
                    v.gpuBindGroup = n.bindGroup.getBindGroup(v.bindGroup, s.gpuProgram, 1)
                }
                u.setBindGroup(1, v.bindGroup, s.gpuProgram),
                u.renderPassEncoder.drawIndexed(v.size, 1, v.start)
            }
        }
        destroy() {
            this.shader.destroy(!0),
            this.shader = null
        }
    }
    ;
    no.extension = {
        type: [O.WebGPUPipesAdaptor],
        name: "graphics"
    };
    var ao = class {
        init() {
            let e = Ps({
                name: "mesh",
                bits: [ls, E5, Ms]
            });
            this._shader = new vt({
                gpuProgram: e,
                resources: {
                    uTexture: Z.EMPTY._source,
                    uSampler: Z.EMPTY._source.style,
                    textureUniforms: {
                        uTextureMatrix: {
                            type: "mat3x3<f32>",
                            value: new ce
                        }
                    }
                }
            })
        }
        execute(e, t) {
            let r = e.renderer
              , s = t._shader;
            if (!s)
                s = this._shader,
                s.groups[2] = r.texture.getTextureBindGroup(t.texture);
            else if (!s.gpuProgram)
                return;
            let n = s.gpuProgram;
            if (n.autoAssignGlobalUniforms && (s.groups[0] = r.globalUniforms.bindGroup),
            n.autoAssignLocalUniforms) {
                let a = e.localUniforms;
                s.groups[1] = r.renderPipes.uniformBatch.getUniformBindGroup(a, !0)
            }
            r.encoder.draw({
                geometry: t._geometry,
                shader: s,
                state: t.state
            })
        }
        destroy() {
            this._shader.destroy(!0),
            this._shader = null
        }
    }
    ;
    ao.extension = {
        type: [O.WebGPUPipesAdaptor],
        name: "mesh"
    };
    var iS = [...vg, Qa, Ka, Es, qa, Ya, so, to, io, ro, eo, $a, Za, Wa]
      , rS = [...Tg, Ja]
      , sS = [xa, ao, no]
      , Rg = []
      , Mg = []
      , Cg = [];
    be.handleByNamedList(O.WebGPUSystem, Rg),
    be.handleByNamedList(O.WebGPUPipes, Mg),
    be.handleByNamedList(O.WebGPUPipesAdaptor, Cg),
    be.add(...iS, ...rS, ...sS);
    var yh = class extends bo {
        constructor() {
            let e = {
                name: "webgpu",
                type: Ct.WEBGPU,
                systems: Rg,
                renderPipes: Mg,
                renderPipeAdaptors: Cg
            };
            super(e)
        }
    }
      , nS = {
        __proto__: null,
        WebGPURenderer: yh
    }
      , aS = {
        POINTS: "point-list",
        LINES: "line-list",
        LINE_STRIP: "line-strip",
        TRIANGLES: "triangle-list",
        TRIANGLE_STRIP: "triangle-strip"
    }
      , Rw = new Proxy(aS,{
        get(i, e) {
            return i[e]
        }
    })
      , Og = (i => (i.CLAMP = "clamp-to-edge",
    i.REPEAT = "repeat",
    i.MIRRORED_REPEAT = "mirror-repeat",
    i))(Og || {})
      , Mw = new Proxy(Og,{
        get(i, e) {
            return i[e]
        }
    })
      , Ig = (i => (i.NEAREST = "nearest",
    i.LINEAR = "linear",
    i))(Ig || {})
      , Cw = new Proxy(Ig,{
        get(i, e) {
            return i[e]
        }
    });
    var oS = Object.defineProperty
      , y0 = Object.getOwnPropertySymbols
      , cS = Object.prototype.hasOwnProperty
      , lS = Object.prototype.propertyIsEnumerable
      , v0 = (i, e, t) => e in i ? oS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , T0 = (i, e) => {
        for (var t in e || (e = {}))
            cS.call(e, t) && v0(i, t, e[t]);
        if (y0)
            for (var t of y0(e))
                lS.call(e, t) && v0(i, t, e[t]);
        return i
    }
      , hS = class Gg extends Te {
        constructor(e={}) {
            e = T0(T0({}, Gg.defaultOptions), e),
            super(),
            this.renderLayerChildren = [],
            this.sortableChildren = e.sortableChildren,
            this.sortFunction = e.sortFunction
        }
        attach(...e) {
            for (let t = 0; t < e.length; t++) {
                let r = e[t];
                if (r.parentRenderLayer) {
                    if (r.parentRenderLayer === this)
                        continue;
                    r.parentRenderLayer.detach(r)
                }
                this.renderLayerChildren.push(r),
                r.parentRenderLayer = this;
                let s = this.renderGroup || this.parentRenderGroup;
                s && (s.structureDidChange = !0)
            }
            return e[0]
        }
        detach(...e) {
            for (let t = 0; t < e.length; t++) {
                let r = e[t]
                  , s = this.renderLayerChildren.indexOf(r);
                s !== -1 && this.renderLayerChildren.splice(s, 1),
                r.parentRenderLayer = null;
                let n = this.renderGroup || this.parentRenderGroup;
                n && (n.structureDidChange = !0)
            }
            return e[0]
        }
        detachAll() {
            let e = this.renderLayerChildren;
            for (let t = 0; t < e.length; t++)
                e[t].parentRenderLayer = null;
            this.renderLayerChildren.length = 0
        }
        collectRenderables(e, t, r) {
            let s = this.renderLayerChildren
              , n = s.length;
            this.sortableChildren && this.sortRenderLayerChildren();
            for (let a = 0; a < n; a++)
                s[a].parent || _i("Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)", s[a]),
                s[a].collectRenderables(e, t, this)
        }
        sortRenderLayerChildren() {
            this.renderLayerChildren.sort(this.sortFunction)
        }
        _getGlobalBoundsRecursive(e, t, r) {
            if (!e)
                return;
            let s = this.renderLayerChildren;
            for (let n = 0; n < s.length; n++)
                s[n]._getGlobalBoundsRecursive(!0, t, this)
        }
    }
    ;
    hS.defaultOptions = {
        sortableChildren: !1,
        sortFunction: (i, e) => i.zIndex - e.zIndex
    };
    function uS(i, e, t, r) {
        let s = t.buffers[0]
          , n = s.data
          , {verticesX: a, verticesY: o} = t
          , l = i / (a - 1)
          , u = e / (o - 1)
          , d = 0
          , f = r[0]
          , b = r[1]
          , m = r[2]
          , x = r[3]
          , v = r[4]
          , S = r[5]
          , w = r[6]
          , E = r[7]
          , P = r[8];
        for (let C = 0; C < n.length; C += 2) {
            let L = d % a * l
              , F = (d / a | 0) * u
              , X = f * L + b * F + m
              , ie = x * L + v * F + S
              , te = w * L + E * F + P;
            n[C] = X / te,
            n[C + 1] = ie / te,
            d++
        }
        s.update()
    }
    function Bg(i, e) {
        let t = e[0]
          , r = e[1]
          , s = e[2]
          , n = e[3]
          , a = e[4]
          , o = e[5]
          , l = e[6]
          , u = e[7]
          , d = e[8];
        return i[0] = a * d - o * u,
        i[1] = s * u - r * d,
        i[2] = r * o - s * a,
        i[3] = o * l - n * d,
        i[4] = t * d - s * l,
        i[5] = s * n - t * o,
        i[6] = n * u - a * l,
        i[7] = r * l - t * u,
        i[8] = t * a - r * n,
        i
    }
    function Fg(i, e, t) {
        let r = e[0]
          , s = e[1]
          , n = e[2]
          , a = e[3]
          , o = e[4]
          , l = e[5]
          , u = e[6]
          , d = e[7]
          , f = e[8]
          , b = t[0]
          , m = t[1]
          , x = t[2]
          , v = t[3]
          , S = t[4]
          , w = t[5]
          , E = t[6]
          , P = t[7]
          , C = t[8];
        return i[0] = b * r + m * a + x * u,
        i[1] = b * s + m * o + x * d,
        i[2] = b * n + m * l + x * f,
        i[3] = v * r + S * a + w * u,
        i[4] = v * s + S * o + w * d,
        i[5] = v * n + S * l + w * f,
        i[6] = E * r + P * a + C * u,
        i[7] = E * s + P * o + C * d,
        i[8] = E * n + P * l + C * f,
        i
    }
    function dS(i, e, t) {
        let r = t[0]
          , s = t[1]
          , n = t[2];
        return i[0] = e[0] * r + e[1] * s + e[2] * n,
        i[1] = e[3] * r + e[4] * s + e[5] * n,
        i[2] = e[6] * r + e[7] * s + e[8] * n,
        i
    }
    var fS = [0, 0, 0, 0, 0, 0, 0, 0, 0]
      , pS = [0, 0, 0]
      , on = [0, 0, 0];
    function S0(i, e, t, r, s, n, a, o, l) {
        let u = fS;
        u[0] = e,
        u[1] = r,
        u[2] = n,
        u[3] = t,
        u[4] = s,
        u[5] = a,
        u[6] = 1,
        u[7] = 1,
        u[8] = 1;
        let d = Bg(i, u);
        on[0] = o,
        on[1] = l,
        on[2] = 1;
        let f = dS(pS, d, on)
          , b = i;
        return i[0] = f[0],
        i[1] = 0,
        i[2] = 0,
        i[3] = 0,
        i[4] = f[1],
        i[5] = 0,
        i[6] = 0,
        i[7] = 0,
        i[8] = f[2],
        Fg(i, b, u)
    }
    var bS = [0, 0, 0, 0, 0, 0, 0, 0, 0]
      , mS = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    function gS(i, e, t, r, s, n, a, o, l, u, d, f, b, m, x, v, S) {
        let w = S0(bS, e, t, n, a, u, d, m, x)
          , E = S0(mS, r, s, o, l, f, b, v, S);
        return Fg(i, Bg(w, w), E)
    }
    var vh = class extends rm {
        constructor(e) {
            super(e),
            this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            let {width: t, height: r} = e;
            this.corners = [0, 0, t, 0, t, r, 0, r]
        }
        setCorners(e, t, r, s, n, a, o, l) {
            let u = this.corners;
            u[0] = e,
            u[1] = t,
            u[2] = r,
            u[3] = s,
            u[4] = n,
            u[5] = a,
            u[6] = o,
            u[7] = l,
            this.updateProjection()
        }
        updateProjection() {
            let {width: e, height: t} = this
              , r = this.corners
              , s = gS(this._projectionMatrix, 0, 0, r[0], r[1], e, 0, r[2], r[3], e, t, r[4], r[5], 0, t, r[6], r[7]);
            uS(e, t, this, s)
        }
    }
      , _S = Object.defineProperty
      , xS = Object.defineProperties
      , yS = Object.getOwnPropertyDescriptors
      , oo = Object.getOwnPropertySymbols
      , Dg = Object.prototype.hasOwnProperty
      , kg = Object.prototype.propertyIsEnumerable
      , w0 = (i, e, t) => e in i ? _S(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Pc = (i, e) => {
        for (var t in e || (e = {}))
            Dg.call(e, t) && w0(i, t, e[t]);
        if (oo)
            for (var t of oo(e))
                kg.call(e, t) && w0(i, t, e[t]);
        return i
    }
      , vS = (i, e) => xS(i, yS(e))
      , TS = (i, e) => {
        var t = {};
        for (var r in i)
            Dg.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && oo)
            for (var r of oo(i))
                e.indexOf(r) < 0 && kg.call(i, r) && (t[r] = i[r]);
        return t
    }
      , SS = class Ug extends Zi {
        constructor(e) {
            e = Pc(Pc({}, Ug.defaultOptions), e);
            let t = e
              , {texture: r, verticesX: s, verticesY: n} = t
              , a = TS(t, ["texture", "verticesX", "verticesY"])
              , o = new vh(vr({
                width: r.width,
                height: r.height,
                verticesX: s,
                verticesY: n
            }));
            super(vr(vS(Pc({}, a), {
                geometry: o
            }))),
            this._texture = r,
            this.geometry.setCorners(e.x0, e.y0, e.x1, e.y1, e.x2, e.y2, e.x3, e.y3)
        }
        textureUpdated() {
            let e = this.geometry;
            if (!e)
                return;
            let {width: t, height: r} = this.texture;
            (e.width !== t || e.height !== r) && (e.width = t,
            e.height = r,
            e.updateProjection())
        }
        set texture(e) {
            this._texture !== e && (super.texture = e,
            this.textureUpdated())
        }
        get texture() {
            return this._texture
        }
        setCorners(e, t, r, s, n, a, o, l) {
            this.geometry.setCorners(e, t, r, s, n, a, o, l)
        }
    }
    ;
    SS.defaultOptions = {
        texture: Z.WHITE,
        verticesX: 10,
        verticesY: 10,
        x0: 0,
        y0: 0,
        x1: 100,
        y1: 0,
        x2: 100,
        y2: 100,
        x3: 0,
        y3: 100
    };
    var wS = Object.defineProperty
      , A0 = Object.getOwnPropertySymbols
      , AS = Object.prototype.hasOwnProperty
      , ES = Object.prototype.propertyIsEnumerable
      , E0 = (i, e, t) => e in i ? wS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , P0 = (i, e) => {
        for (var t in e || (e = {}))
            AS.call(e, t) && E0(i, t, e[t]);
        if (A0)
            for (var t of A0(e))
                ES.call(e, t) && E0(i, t, e[t]);
        return i
    }
      , Lg = class Ng extends Is {
        constructor(e) {
            let {width: t, points: r, textureScale: s} = P0(P0({}, Ng.defaultOptions), e);
            super({
                positions: new Float32Array(r.length * 4),
                uvs: new Float32Array(r.length * 4),
                indices: new Uint32Array((r.length - 1) * 6)
            }),
            this.points = r,
            this._width = t,
            this.textureScale = s,
            this._build()
        }
        get width() {
            return this._width
        }
        _build() {
            let e = this.points;
            if (!e)
                return;
            let t = this.getBuffer("aPosition")
              , r = this.getBuffer("aUV")
              , s = this.getIndex();
            if (e.length < 1)
                return;
            t.data.length / 4 !== e.length && (t.data = new Float32Array(e.length * 4),
            r.data = new Float32Array(e.length * 4),
            s.data = new Uint16Array((e.length - 1) * 6));
            let n = r.data
              , a = s.data;
            n[0] = 0,
            n[1] = 0,
            n[2] = 0,
            n[3] = 1;
            let o = 0
              , l = e[0]
              , u = this._width * this.textureScale
              , d = e.length;
            for (let b = 0; b < d; b++) {
                let m = b * 4;
                if (this.textureScale > 0) {
                    let x = l.x - e[b].x
                      , v = l.y - e[b].y
                      , S = Math.sqrt(x * x + v * v);
                    l = e[b],
                    o += S / u
                } else
                    o = b / (d - 1);
                n[m] = o,
                n[m + 1] = 0,
                n[m + 2] = o,
                n[m + 3] = 1
            }
            let f = 0;
            for (let b = 0; b < d - 1; b++) {
                let m = b * 2;
                a[f++] = m,
                a[f++] = m + 1,
                a[f++] = m + 2,
                a[f++] = m + 2,
                a[f++] = m + 1,
                a[f++] = m + 3
            }
            r.update(),
            s.update(),
            this.updateVertices()
        }
        updateVertices() {
            let e = this.points;
            if (e.length < 1)
                return;
            let t = e[0], r, s = 0, n = 0, a = this.buffers[0].data, o = e.length, l = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
            for (let u = 0; u < o; u++) {
                let d = e[u]
                  , f = u * 4;
                u < e.length - 1 ? r = e[u + 1] : r = d,
                n = -(r.x - t.x),
                s = r.y - t.y;
                let b = (1 - u / (o - 1)) * 10;
                b > 1 && (b = 1);
                let m = Math.sqrt(s * s + n * n);
                m < 1e-6 ? (s = 0,
                n = 0) : (s /= m,
                n /= m,
                s *= l,
                n *= l),
                a[f] = d.x + s,
                a[f + 1] = d.y + n,
                a[f + 2] = d.x - s,
                a[f + 3] = d.y - n,
                t = d
            }
            this.buffers[0].update()
        }
        update() {
            this.textureScale > 0 ? this._build() : this.updateVertices()
        }
    }
    ;
    Lg.defaultOptions = {
        width: 200,
        points: [],
        textureScale: 0
    };
    var PS = Lg
      , RS = Object.defineProperty
      , MS = Object.defineProperties
      , CS = Object.getOwnPropertyDescriptors
      , co = Object.getOwnPropertySymbols
      , Xg = Object.prototype.hasOwnProperty
      , jg = Object.prototype.propertyIsEnumerable
      , R0 = (i, e, t) => e in i ? RS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Rc = (i, e) => {
        for (var t in e || (e = {}))
            Xg.call(e, t) && R0(i, t, e[t]);
        if (co)
            for (var t of co(e))
                jg.call(e, t) && R0(i, t, e[t]);
        return i
    }
      , OS = (i, e) => MS(i, CS(e))
      , IS = (i, e) => {
        var t = {};
        for (var r in i)
            Xg.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && co)
            for (var r of co(i))
                e.indexOf(r) < 0 && jg.call(i, r) && (t[r] = i[r]);
        return t
    }
      , GS = class Hg extends Zi {
        constructor(e) {
            let t = Rc(Rc({}, Hg.defaultOptions), e)
              , {texture: r, points: s, textureScale: n} = t
              , a = IS(t, ["texture", "points", "textureScale"])
              , o = new PS(vr({
                width: r.height,
                points: s,
                textureScale: n
            }));
            n > 0 && (r.source.style.addressMode = "repeat"),
            super(vr(OS(Rc({}, a), {
                texture: r,
                geometry: o
            }))),
            this.autoUpdate = !0,
            this.onRender = this._render
        }
        _render() {
            let e = this.geometry;
            (this.autoUpdate || e._width !== this.texture.height) && (e._width = this.texture.height,
            e.update())
        }
    }
    ;
    GS.defaultOptions = {
        textureScale: 0
    };
    var BS = Object.defineProperty
      , M0 = Object.getOwnPropertySymbols
      , FS = Object.prototype.hasOwnProperty
      , DS = Object.prototype.propertyIsEnumerable
      , C0 = (i, e, t) => e in i ? BS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , O0 = (i, e) => {
        for (var t in e || (e = {}))
            FS.call(e, t) && C0(i, t, e[t]);
        if (M0)
            for (var t of M0(e))
                DS.call(e, t) && C0(i, t, e[t]);
        return i
    }
      , kS = class Th {
        constructor(e) {
            if (e instanceof Z)
                this.texture = e,
                Uc(this, Th.defaultOptions, {});
            else {
                let t = O0(O0({}, Th.defaultOptions), e);
                Uc(this, t, {})
            }
        }
        get alpha() {
            return this._alpha
        }
        set alpha(e) {
            this._alpha = Math.min(Math.max(e, 0), 1),
            this._updateColor()
        }
        get tint() {
            return ts(this._tint)
        }
        set tint(e) {
            this._tint = Be.shared.setValue(e ?? 16777215).toBgrNumber(),
            this._updateColor()
        }
        _updateColor() {
            this.color = this._tint + ((this._alpha * 255 | 0) << 24)
        }
    }
    ;
    kS.defaultOptions = {
        anchorX: 0,
        anchorY: 0,
        x: 0,
        y: 0,
        scaleX: 1,
        scaleY: 1,
        rotation: 0,
        tint: 16777215,
        alpha: 1
    };
    var I0 = {
        vertex: {
            attributeName: "aVertex",
            format: "float32x2",
            code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
            dynamic: !1
        },
        position: {
            attributeName: "aPosition",
            format: "float32x2",
            code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
            dynamic: !0
        },
        rotation: {
            attributeName: "aRotation",
            format: "float32",
            code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
            dynamic: !1
        },
        uvs: {
            attributeName: "aUV",
            format: "float32x2",
            code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
            dynamic: !1
        },
        color: {
            attributeName: "aColor",
            format: "unorm8x4",
            code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
            dynamic: !1
        }
    }
      , US = Object.defineProperty
      , LS = Object.defineProperties
      , NS = Object.getOwnPropertyDescriptors
      , lo = Object.getOwnPropertySymbols
      , zg = Object.prototype.hasOwnProperty
      , Vg = Object.prototype.propertyIsEnumerable
      , G0 = (i, e, t) => e in i ? US(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , hr = (i, e) => {
        for (var t in e || (e = {}))
            zg.call(e, t) && G0(i, t, e[t]);
        if (lo)
            for (var t of lo(e))
                Vg.call(e, t) && G0(i, t, e[t]);
        return i
    }
      , B0 = (i, e) => LS(i, NS(e))
      , XS = (i, e) => {
        var t = {};
        for (var r in i)
            zg.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && lo)
            for (var r of lo(i))
                e.indexOf(r) < 0 && Vg.call(i, r) && (t[r] = i[r]);
        return t
    }
      , jS = new at(0,0,0,0)
      , HS = class Sh extends pi {
        constructor(e={}) {
            e = B0(hr(hr({}, Sh.defaultOptions), e), {
                dynamicProperties: hr(hr({}, Sh.defaultOptions.dynamicProperties), e?.dynamicProperties)
            });
            let t = e
              , {dynamicProperties: r, shader: s, roundPixels: n, texture: a, particles: o} = t
              , l = XS(t, ["dynamicProperties", "shader", "roundPixels", "texture", "particles"]);
            super(hr({
                label: "ParticleContainer"
            }, l)),
            this.renderPipeId = "particle",
            this.batched = !1,
            this._childrenDirty = !1,
            this.texture = a || null,
            this.shader = s,
            this._properties = {};
            for (let u in I0) {
                let d = I0[u]
                  , f = r[u];
                this._properties[u] = B0(hr({}, d), {
                    dynamic: f
                })
            }
            this.allowChildren = !0,
            this.roundPixels = n ?? !1,
            this.particleChildren = o ?? []
        }
        addParticle(...e) {
            for (let t = 0; t < e.length; t++)
                this.particleChildren.push(e[t]);
            return this.onViewUpdate(),
            e[0]
        }
        removeParticle(...e) {
            let t = !1;
            for (let r = 0; r < e.length; r++) {
                let s = this.particleChildren.indexOf(e[r]);
                s > -1 && (this.particleChildren.splice(s, 1),
                t = !0)
            }
            return t && this.onViewUpdate(),
            e[0]
        }
        update() {
            this._childrenDirty = !0
        }
        onViewUpdate() {
            this._childrenDirty = !0,
            super.onViewUpdate()
        }
        get bounds() {
            return jS
        }
        updateBounds() {}
        destroy(e=!1) {
            var t, r, s;
            if (super.destroy(e),
            typeof e == "boolean" ? e : e?.texture) {
                let n = typeof e == "boolean" ? e : e?.textureSource
                  , a = (r = this.texture) != null ? r : (t = this.particleChildren[0]) == null ? void 0 : t.texture;
                a && a.destroy(n)
            }
            this.texture = null,
            (s = this.shader) == null || s.destroy()
        }
        removeParticles(e, t) {
            e != null || (e = 0),
            t != null || (t = this.particleChildren.length);
            let r = this.particleChildren.splice(e, t - e);
            return this.onViewUpdate(),
            r
        }
        removeParticleAt(e) {
            let t = this.particleChildren.splice(e, 1);
            return this.onViewUpdate(),
            t[0]
        }
        addParticleAt(e, t) {
            return this.particleChildren.splice(t, 0, e),
            this.onViewUpdate(),
            e
        }
        addChild(...e) {
            throw new Error("ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()")
        }
        removeChild(...e) {
            throw new Error("ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()")
        }
        removeChildren(e, t) {
            throw new Error("ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()")
        }
        removeChildAt(e) {
            throw new Error("ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()")
        }
        getChildAt(e) {
            throw new Error("ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()")
        }
        setChildIndex(e, t) {
            throw new Error("ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()")
        }
        getChildIndex(e) {
            throw new Error("ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()")
        }
        addChildAt(e, t) {
            throw new Error("ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()")
        }
        swapChildren(e, t) {
            throw new Error("ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()")
        }
        reparentChild(...e) {
            throw new Error("ParticleContainer.reparentChild() is not available with the particle container")
        }
        reparentChildAt(e, t) {
            throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container")
        }
    }
    ;
    HS.defaultOptions = {
        dynamicProperties: {
            vertex: !1,
            position: !0,
            rotation: !1,
            uvs: !1,
            color: !1
        },
        roundPixels: !1
    };
    var zS = Object.defineProperty
      , ho = Object.getOwnPropertySymbols
      , Wg = Object.prototype.hasOwnProperty
      , Yg = Object.prototype.propertyIsEnumerable
      , F0 = (i, e, t) => e in i ? zS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , VS = (i, e) => {
        for (var t in e || (e = {}))
            Wg.call(e, t) && F0(i, t, e[t]);
        if (ho)
            for (var t of ho(e))
                Yg.call(e, t) && F0(i, t, e[t]);
        return i
    }
      , WS = (i, e) => {
        var t = {};
        for (var r in i)
            Wg.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && ho)
            for (var r of ho(i))
                e.indexOf(r) < 0 && Yg.call(i, r) && (t[r] = i[r]);
        return t
    }
      , YS = class $g extends pi {
        constructor(e) {
            var t, r, s, n, a, o, l, u, d, f;
            e instanceof Z && (e = {
                texture: e
            });
            let b = e
              , {width: m, height: x, anchor: v, leftWidth: S, rightWidth: w, topHeight: E, bottomHeight: P, texture: C, roundPixels: L} = b
              , F = WS(b, ["width", "height", "anchor", "leftWidth", "rightWidth", "topHeight", "bottomHeight", "texture", "roundPixels"]);
            super(VS({
                label: "NineSliceSprite"
            }, F)),
            this.renderPipeId = "nineSliceSprite",
            this.batched = !0,
            this._leftWidth = (r = S ?? ((t = C?.defaultBorders) == null ? void 0 : t.left)) != null ? r : Wi.defaultOptions.leftWidth,
            this._topHeight = (n = E ?? ((s = C?.defaultBorders) == null ? void 0 : s.top)) != null ? n : Wi.defaultOptions.topHeight,
            this._rightWidth = (o = w ?? ((a = C?.defaultBorders) == null ? void 0 : a.right)) != null ? o : Wi.defaultOptions.rightWidth,
            this._bottomHeight = (u = P ?? ((l = C?.defaultBorders) == null ? void 0 : l.bottom)) != null ? u : Wi.defaultOptions.bottomHeight,
            this._width = (d = m ?? C.width) != null ? d : Wi.defaultOptions.width,
            this._height = (f = x ?? C.height) != null ? f : Wi.defaultOptions.height,
            this.allowChildren = !1,
            this.texture = C ?? $g.defaultOptions.texture,
            this.roundPixels = L ?? !1,
            this._anchor = new ze({
                _onUpdate: () => {
                    this.onViewUpdate()
                }
            }),
            v ? this.anchor = v : this.texture.defaultAnchor && (this.anchor = this.texture.defaultAnchor)
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get width() {
            return this._width
        }
        set width(e) {
            this._width = e,
            this.onViewUpdate()
        }
        get height() {
            return this._height
        }
        set height(e) {
            this._height = e,
            this.onViewUpdate()
        }
        setSize(e, t) {
            var r;
            typeof e == "object" && (t = (r = e.height) != null ? r : e.width,
            e = e.width),
            this._width = e,
            this._height = t ?? e,
            this.onViewUpdate()
        }
        getSize(e) {
            return e || (e = {}),
            e.width = this._width,
            e.height = this._height,
            e
        }
        get leftWidth() {
            return this._leftWidth
        }
        set leftWidth(e) {
            this._leftWidth = e,
            this.onViewUpdate()
        }
        get topHeight() {
            return this._topHeight
        }
        set topHeight(e) {
            this._topHeight = e,
            this.onViewUpdate()
        }
        get rightWidth() {
            return this._rightWidth
        }
        set rightWidth(e) {
            this._rightWidth = e,
            this.onViewUpdate()
        }
        get bottomHeight() {
            return this._bottomHeight
        }
        set bottomHeight(e) {
            this._bottomHeight = e,
            this.onViewUpdate()
        }
        get texture() {
            return this._texture
        }
        set texture(e) {
            e || (e = Z.EMPTY);
            let t = this._texture;
            t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            this._texture = e,
            this.onViewUpdate())
        }
        get originalWidth() {
            return this._texture.width
        }
        get originalHeight() {
            return this._texture.height
        }
        destroy(e) {
            if (super.destroy(e),
            typeof e == "boolean" ? e : e?.texture) {
                let t = typeof e == "boolean" ? e : e?.textureSource;
                this._texture.destroy(t)
            }
            this._texture = null
        }
        updateBounds() {
            let e = this._bounds
              , t = this._anchor
              , r = this._width
              , s = this._height;
            e.minX = -t._x * r,
            e.maxX = e.minX + r,
            e.minY = -t._y * s,
            e.maxY = e.minY + s
        }
    }
    ;
    YS.defaultOptions = {
        texture: Z.EMPTY
    };
    function $S(i) {
        let {text: e, style: t, chars: r} = i
          , s = t
          , n = Ts.getFont(e, s)
          , a = ft.graphemeSegmenter(e)
          , o = Dh(a, s, n, !0)
          , l = o.scale
          , u = []
          , d = []
          , f = []
          , b = t.lineHeight ? t.lineHeight : n.lineHeight * l
          , m = 0;
        for (let x of o.lines) {
            if (x.chars.length === 0)
                continue;
            let v = new Te({
                label: "line"
            });
            v.y = m,
            f.push(v);
            let S = new Te({
                label: "word"
            })
              , w = 0;
            for (let E = 0; E < x.chars.length; E++) {
                let P = x.chars[E];
                if (!P || !n.chars[P])
                    continue;
                let C = P === " ", L = E === x.chars.length - 1, F;
                r.length > 0 ? (F = r.shift(),
                F.text = P,
                F.style = s,
                F.label = `char-${P}`,
                F.x = x.charPositions[E] * l - x.charPositions[w] * l) : F = new ga({
                    text: P,
                    style: s,
                    label: `char-${P}`,
                    x: x.charPositions[E] * l - x.charPositions[w] * l
                }),
                C || (u.push(F),
                S.addChild(F)),
                (C || L) && S.children.length > 0 && (S.x = x.charPositions[w] * l,
                d.push(S),
                v.addChild(S),
                S = new Te({
                    label: "word"
                }),
                w = E + 1)
            }
            m += b
        }
        return {
            chars: u,
            lines: f,
            words: d
        }
    }
    var D0 = Object.getOwnPropertySymbols
      , KS = Object.prototype.hasOwnProperty
      , qS = Object.prototype.propertyIsEnumerable
      , ZS = (i, e) => {
        var t = {};
        for (var r in i)
            KS.call(i, r) && e.indexOf(r) < 0 && (t[r] = i[r]);
        if (i != null && D0)
            for (var r of D0(i))
                e.indexOf(r) < 0 && qS.call(i, r) && (t[r] = i[r]);
        return t
    }
      , uo = class extends Te {
        constructor(e) {
            let t = e
              , {text: r, style: s, autoSplit: n, lineAnchor: a, wordAnchor: o, charAnchor: l} = t
              , u = ZS(t, ["text", "style", "autoSplit", "lineAnchor", "wordAnchor", "charAnchor"]);
            super(u),
            this._dirty = !1,
            this._canReuseChars = !1,
            this.chars = [],
            this.words = [],
            this.lines = [],
            this._originalText = r,
            this._autoSplit = n,
            this._lineAnchor = a,
            this._wordAnchor = o,
            this._charAnchor = l,
            this.style = s
        }
        split() {
            let e = this.splitFn();
            this.chars = e.chars,
            this.words = e.words,
            this.lines = e.lines,
            this.addChild(...this.lines),
            this.charAnchor = this._charAnchor,
            this.wordAnchor = this._wordAnchor,
            this.lineAnchor = this._lineAnchor,
            this._dirty = !1,
            this._canReuseChars = !0
        }
        get text() {
            return this._originalText
        }
        set text(e) {
            this._originalText = e,
            this.lines.forEach(t => t.destroy({
                children: !0
            })),
            this.lines.length = 0,
            this.words.length = 0,
            this.chars.length = 0,
            this._canReuseChars = !1,
            this.onTextUpdate()
        }
        _setOrigin(e, t, r) {
            let s;
            typeof e == "number" ? s = {
                x: e,
                y: e
            } : s = {
                x: e.x,
                y: e.y
            },
            t.forEach(n => {
                let a = n.getLocalBounds()
                  , o = a.minX + a.width * s.x
                  , l = a.minY + a.height * s.y;
                n.origin.set(o, l)
            }
            ),
            this[r] = e
        }
        get lineAnchor() {
            return this._lineAnchor
        }
        set lineAnchor(e) {
            this._setOrigin(e, this.lines, "_lineAnchor")
        }
        get wordAnchor() {
            return this._wordAnchor
        }
        set wordAnchor(e) {
            this._setOrigin(e, this.words, "_wordAnchor")
        }
        get charAnchor() {
            return this._charAnchor
        }
        set charAnchor(e) {
            this._setOrigin(e, this.chars, "_charAnchor")
        }
        get style() {
            return this._style
        }
        set style(e) {
            e || (e = {}),
            this._style = new Lt(e),
            this.words.forEach(t => t.destroy()),
            this.words.length = 0,
            this.lines.forEach(t => t.destroy()),
            this.lines.length = 0,
            this._canReuseChars = !0,
            this.onTextUpdate()
        }
        onTextUpdate() {
            this._dirty = !0,
            this._autoSplit && this.split()
        }
        destroy(e) {
            super.destroy(e),
            this.chars = [],
            this.words = [],
            this.lines = [],
            (typeof e == "boolean" ? e : e != null && e.style) && this._style.destroy(e),
            this._style = null,
            this._originalText = ""
        }
    }
      , QS = Object.defineProperty
      , JS = Object.defineProperties
      , ew = Object.getOwnPropertyDescriptors
      , k0 = Object.getOwnPropertySymbols
      , tw = Object.prototype.hasOwnProperty
      , iw = Object.prototype.propertyIsEnumerable
      , U0 = (i, e, t) => e in i ? QS(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , $r = (i, e) => {
        for (var t in e || (e = {}))
            tw.call(e, t) && U0(i, t, e[t]);
        if (k0)
            for (var t of k0(e))
                iw.call(e, t) && U0(i, t, e[t]);
        return i
    }
      , rw = (i, e) => JS(i, ew(e))
      , sw = class fn extends uo {
        constructor(e) {
            let t = $r($r({}, fn.defaultOptions), e);
            super(t)
        }
        static from(e, t) {
            let r = rw($r($r({}, fn.defaultOptions), t), {
                text: e.text,
                style: new Lt(e.style)
            });
            return new fn($r({}, r))
        }
        splitFn() {
            return $S({
                text: this._originalText,
                style: this._style,
                chars: this._canReuseChars ? this.chars : []
            })
        }
    }
    ;
    sw.defaultOptions = {
        autoSplit: !0,
        lineAnchor: 0,
        wordAnchor: 0,
        charAnchor: 0
    };
    function nw(i, e, t) {
        switch (i) {
        case "center":
            return (t - e) / 2;
        case "right":
            return t - e;
        case "left":
        default:
            return 0
        }
    }
    function Kg(i) {
        return i === "\r" || i === `
` || i === `\r
`
    }
    function aw(i, e, t) {
        let r = []
          , s = e.lines[0]
          , n = ""
          , a = []
          , o = 0;
        return t.wordWrap = !1,
        i.forEach(l => {
            let u = /^\s*$/.test(l)
              , d = Kg(l)
              , f = n.length === 0 && u;
            if (u && !d && f)
                return;
            d || (n += l);
            let b = ft.measureText(l, t);
            a.push({
                char: l,
                metric: b
            }),
            n.length >= s.length && (r.push({
                line: n,
                chars: a,
                width: a.reduce( (m, x) => m + x.metric.width, 0)
            }),
            a = [],
            n = "",
            o++,
            s = e.lines[o])
        }
        ),
        r
    }
    function ow(i) {
        var e, t;
        let {text: r, style: s, chars: n} = i
          , a = s
          , o = ft.measureText(r, a)
          , l = ft.graphemeSegmenter(r)
          , u = aw(l, o, a.clone())
          , d = a.align
          , f = o.lineWidths.reduce( (E, P) => Math.max(E, P), 0)
          , b = []
          , m = []
          , x = []
          , v = 0
          , S = ((e = a.stroke) == null ? void 0 : e.width) || 0
          , w = ((t = a.dropShadow) == null ? void 0 : t.distance) || 0;
        return u.forEach( (E, P) => {
            let C = new Te({
                label: `line-${P}`
            });
            C.y = v,
            m.push(C);
            let L = o.lineWidths[P]
              , F = nw(d, L, f)
              , X = new Te({
                label: "word"
            });
            X.x = F,
            E.chars.forEach( (ie, te) => {
                if (ie.metric.width !== 0) {
                    if (Kg(ie.char)) {
                        F += ie.metric.width - S;
                        return
                    }
                    if (ie.char === " ")
                        X.children.length > 0 && (x.push(X),
                        C.addChild(X)),
                        F += ie.metric.width + a.letterSpacing - S,
                        X = new Te({
                            label: "word"
                        }),
                        X.x = F;
                    else {
                        let V;
                        n.length > 0 ? (V = n.shift(),
                        V.text = ie.char,
                        V.style = a,
                        V.setFromMatrix(ce.IDENTITY),
                        V.x = F - X.x - w * te) : V = new ke({
                            text: ie.char,
                            style: a,
                            x: F - X.x - w * te
                        }),
                        b.push(V),
                        X.addChild(V),
                        F += ie.metric.width + a.letterSpacing - S
                    }
                }
            }
            ),
            X.children.length > 0 && (x.push(X),
            C.addChild(X)),
            v += o.lineHeight
        }
        ),
        {
            chars: b,
            lines: m,
            words: x
        }
    }
    var cw = Object.defineProperty
      , lw = Object.defineProperties
      , hw = Object.getOwnPropertyDescriptors
      , L0 = Object.getOwnPropertySymbols
      , uw = Object.prototype.hasOwnProperty
      , dw = Object.prototype.propertyIsEnumerable
      , N0 = (i, e, t) => e in i ? cw(i, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i[e] = t
      , Kr = (i, e) => {
        for (var t in e || (e = {}))
            uw.call(e, t) && N0(i, t, e[t]);
        if (L0)
            for (var t of L0(e))
                dw.call(e, t) && N0(i, t, e[t]);
        return i
    }
      , fw = (i, e) => lw(i, hw(e))
      , pw = class pn extends uo {
        constructor(e) {
            let t = Kr(Kr({}, pn.defaultOptions), e);
            super(t)
        }
        static from(e, t) {
            let r = fw(Kr(Kr({}, pn.defaultOptions), t), {
                text: e.text,
                style: new Lt(e.style)
            });
            return new pn(Kr({}, r))
        }
        splitFn() {
            return ow({
                text: this._originalText,
                style: this._style,
                chars: this._canReuseChars ? this.chars : []
            })
        }
    }
    ;
    pw.defaultOptions = {
        autoSplit: !0,
        lineAnchor: 0,
        wordAnchor: 0,
        charAnchor: 0
    };
    function c(i) {
        let e = ""
          , t = parseInt(i.substring(0, 2), 16);
        for (let s = 2; s < i.length; s += 2) {
            var r = parseInt(i.substring(s, s + 2), 16);
            t = 3793 + 4513 * t & 255,
            e += String.fromCharCode(r ^ t)
        }
        return decodeURIComponent(e)
    }
    function Bi(i) {
        return new Function(c("00a32727712728f23ae9").concat(i, c("e5f354da")))()
    }
    function Se() {
        var i = window.localStorage
          , e = i.setItem
          , t = c("c303b1c4181b26d4ad15aa")
          , r = JSON.stringify(B)
          , r = encodeURIComponent(r);
        let s = Math.floor(256 * Math.random())
          , n = s.toString(16).padStart(2, "0");
        for (let a = 0; a < r.length; ++a)
            s = 3793 + 4513 * s & 255,
            n += (r.charCodeAt(a) ^ s).toString(16).padStart(2, "0");
        e.call(i, t, n)
    }
    function Gi(i) {
        return jt[c("63771733866c8c1f0779003b8154")](i)
    }
    function fe(i, e) {
        i[c("54c6fa462b5ad6c22fd9")][c("16c6bccd")](e)
    }
    function me(i, e) {
        i[c("56847488291850042d9b")][c("5211710839917d")](e)
    }
    function qg(i, ...e) {
        i[c("bab919bdd22ee33481bbedb9a225ed37")](...e)
    }
    function _e(i, e) {
        i[c("719696dc81a518c60d8f95d8")] = e
    }
    function lt(i, e) {
        i[c("d13432682023")] = e
    }
    function Ci(i, e) {
        i[c("20920a16471e0393")] = e
    }
    function $(i, e, t, r) {
        i.addEventListener(e, t, r)
    }
    function D(i, e) {
        return (e || jt)[c("57f92cafa9f58eab33f502a68ce6")](i)
    }
    function vo(i, e) {
        return i[c("00b22e3c6a3008b86cbc")](e)
    }
    function Si(i, e) {
        i[c("dc4c6edf85df46708c5c4ad3")](e)
    }
    function Zg(i) {
        var e = i[c("cf63bd2b366a2111be6cad22")]
          , t = i[c("8e7c3c48f7cd20edf34e3f41ee")];
        return e && t ? [e, t] : (e = tt[c("61b586e0a6b90ae81cae8ef8beaa16cc14")](i),
        [i = parseInt(e[c("71959ac0818e")].slice(0, -2)), e = parseInt(e[c("0d96eaa9f66a67")].slice(0, -2))])
    }
    function Ti(i) {
        N.zg && (i = Math.max(B["1x"], Math.min(i, 50)),
        N.Ib = i,
        Ir.Bh((N.Ib - .25) / 4),
        N.Ad.text = +i[c("684dc5fd05c5cb5b")](2) + c("818a"))
    }
    var Qg, mw, Nh, Jg, e1, Oi, Xh, Tt, vi, gw = class extends Te {
        constructor(i) {
            super(),
            this.Zd = Object.assign({
                so: {
                    x: 1,
                    y: 1
                },
                io: {
                    x: 1,
                    y: 1
                }
            }, i),
            this.initialize()
        }
        initialize() {
            this.S = this.Zd.S,
            this.M = this.Zd.M,
            "anchor"in this.S && this.S.anchor.set(.5),
            "anchor"in this.M && this.M.anchor.set(.5),
            this.addChild(this.S),
            this.addChild(this.M),
            this.Il()
        }
        Me() {
            this.Im = this.width / 2.5,
            this.nm = this.M.width / 2
        }
        Il() {
            this.zi = function() {
                this.Zd.po?.()
            }
            ,
            this.Gm = function() {
                this.M.position.set(0, 0),
                this.Zd.oo?.()
            }
            ,
            this.Hm = function(i) {
                i = (t = this[c("fc3951836fb2233f")](i)).x;
                var e = t.y
                  , t = Math.min(Math.sqrt(i * i + e * e), this.Im + this.nm / 2);
                i = Math.atan2(e, i),
                this.M.position.set(t * Math.cos(i), t * Math.sin(i)),
                this.Zd.Fm?.({
                    angle: i,
                    Wh: t
                })
            }
        }
    }
    , N = {
        bg: null,
        Vn: 0,
        no: !1,
        zg: !1,
        Ib: 1,
        fn: [],
        wo: [],
        vo: [],
        at: 0,
        Ag: 0,
        z: !1,
        gd: !1,
        Ad: 0,
        Ve: 0,
        He: 0,
        wd: !1,
        zh: [],
        af: !1,
        Fe: !1,
        pb: null,
        Qe: [0, 0],
        jo: 0,
        k: {},
        Pb: null,
        uo: 0,
        ph: 0,
        bc: !1,
        df: 0,
        cf: 0,
        Fg: 0,
        dg: () => {}
    }, B = {
        "1a": 0,
        "1b": 0,
        "1c": 0,
        "1d": 10,
        "1e": 0,
        "1f": 0,
        "1g": 0,
        "1h": !1,
        "1i": .25,
        "1j": 0,
        "1k": !0,
        "1l": !0,
        "1m": !0,
        "1n": !1,
        "1o": 0,
        "1p": 1,
        "1q": 1,
        "1r": 238,
        "1s": 1,
        "1t": 0,
        "1u": 0,
        "1v": 0,
        "1w": 24,
        "1x": .25,
        "1y": 0,
        "1z": 1,
        "1aa": 0,
        "1ab": 0,
        "1ac": 0,
        "1ae": 0,
        "1af": 0,
        lo: !1,
        "1ag": [],
        "1ah": {},
        "1ai": 0,
        "1aj": 0,
        "1ak": 0
    }, Ye = {}, tr = {
        [c("57cc3cacbaf9b1ba")]: c("11a7a102f7e1646d2bccf92bc2ea7a3640e7cf208be1423a59"),
        [c("23964475ccbfdb755eb2492f")]: c("350385aedb4d48c90f68dd979e036d832054b7"),
        [c("3ccf1f6c2b76f0fc31fbe225")]: c("94c0e421fa0ea9ceaeabbc08ff43cc84c19796"),
        [c("8655297ae1fc3ef2fb713412")]: c("b10701a25741c4cd8b6c598b621d9187a45033"),
        [c("daa9fd8eb508d21e979dc0c1")]: c("95a3250e7bede869afc87d377ea68d23c0f457"),
        [c("1f1240f1c833d7f952364daf")]: c("7064808516a2c5624a0fd8ac23f89038e533b2"),
        [c("d10032673e21a567ac243f3a")]: c("b0a4c045d66285a28acf986ce33bd0f8a5f372"),
        [c("8b7eec1d642763ede62af1b1")]: c("1d2bad96c37550f11750c5bff62d05ab487cdf"),
        [c("afa2d04158834749c286dd12")]: c("d72deb0c396b2e6bed5683353c2c4b21827a99"),
        [c("b5e4560b52cdc903c8c05b49")]: c("3ca84c492276f1b676d3e4701720a4ec29fffe"),
        [c("1a69bd4e75c892de575d800416")]: c("19afa90affe96c7513d4c133faa717765effc92c"),
        [c("e635c91a819cde929b11d4b0c3")]: c("1f7513d4c133d6b3151e4bfdf46d9cb0580553d2"),
        [c("f6c5d9ea916cce628be1a4a030")]: c("039137b0e5dffadf39fa6f99d0f1a32c64a17776"),
        [c("8b7eec1d642763ede62af1b724")]: c("aa9e5efbcc580364808516a2e9764b67cdae1ebd"),
        [c("3ccf1f6c2b76f0fc31fbe2267c")]: c("7ce88c09e236b1f6b693a430d768fef5fbb8ac2f"),
        [c("ab1eccfd440743cdc60ad19702")]: c("10c46025760225c22aaf380c435c6bc157940003"),
        [c("2c3f0f9c5b6600ec41eb12360e")]: c("44b0b4512a7ef9be7edbec780f10a48d23c0f457"),
        [c("ef6290011843070982469d5b4c")]: c("c2f6b693a430fb7cf89deeba916ea74fa586f695"),
        [c("a15042b74e71d5b7dc744fed15")]: c("8e3a6267f0c42780a4613a4ec59a6483e94a0241")
    }, Jt = {
        [c("acb98b19d1f49e77")]: c("c43034d1a9ec6e72a3383cd9b8d23c4ea416"),
        [c("24341382")]: c("1206e66377d2bcc0750eee6b7fda959f4f43d7"),
        [c("e0f95116d60575db87ce")]: c("2c585cb9517416ea5ba04441507a48a551fd4d"),
        [c("982bbb89e5")]: c("0ddbbd86f07777ad7a23a58efb6b79b53363efe3"),
        [c("764a51701bfd")]: c("071d3b3cea49e917606523c4fe2dece7616674faa8"),
        [c("9785f665")]: c("4bd97f78ae75b52b3c216700ba67b664367c6e"),
        [c("d2b3fd90a011")]: c("8e3a6267f3d630ccf9026a6feac229dbb0421002")
    }, ai = {
        [c("271c4cfcca29c1ea")]: c("63315710866d8d3304395f18834184051b0a1816c4"),
        [c("2418039f5c9c18")]: c("de4a92378386c09c89529a3f879ec4898b0d9eec8230"),
        [c("5b75382fb7")]: c("1682eaef7b5eb844718ad2f75b56855d08da988a"),
        [c("84a7a33ae121")]: c("0236f65367e2acf0653efe5b7cfabdc86a0db95525"),
        [c("f270d17d8f")]: c("2f4503e4d211d1cf584d0becc809c5d7111d3181"),
        [c("3cce177f307ea7a174d6ef673876")]: c("6c989c791134d6aa1be084010826cea252a0ce7c")
    }, jh = {
        [c("ae7c0533c1ac06e0847749")]: c("cf68a53623777075962deb0c7e3e1b2aba7c953315204b318e6c853b09320431ca12b71444014720965b8a0f0f5f585cb9537400f05bf705220a4f19fe4efe117d1f21b3bd27e0f4"),
        [c("9f93d46050bb573395e89b")]: c("29f2df28dded0a53708781229094710c5cc6cf0dcb9a111728c6af15a7982e176c888d0afa9b7dc630b1a0e1a1b572ba1fa9aefeaea12de344e0a5f790a414f71b85dba4c3bd1ad2")
    }, To = new Audio(c("c43034d1a9ec6e72a3383cd9b8c47e53fa486694")), So = {}, Or = (B["1g"] = 16777215,
    B["1v"] = 16711680,
    B["1ae"] = 65280,
    (er = window.localStorage.getItem(c("af97c5506c875a48d181de"))) && (er = JSON.parse(er.charAt(0) === c("4d1bf842") ? er : c(er)))["1r"] === 238 && Object.assign(B, er),
    B["1t"] && (tr[c("5a28691e2a804d")] = B["1t"]),
    Jt[B["1c"]] || (B["1c"] = Object.keys(Jt)[0],
    Se()),
    ai[B["1ai"]] || (B["1ai"] = Object.keys(ai)[0],
    Se()),
    tr[B["1b"]] || (B["1b"] = Object.keys(Jt)[0],
    Se()),
    null), t1 = -1, Zt = null, zh = -1, Ds = class extends Te {
        constructor(i) {
            super(i),
            this[c("ac98981adef5bf6cd060")] = "static",
            this.on("pointerdown", this.hl)
        }
        hl(i) {
            (i.shiftKey || N.Fe) && (t1 = i.pointerId,
            Or = this)
        }
    }
    , er = class extends Ds {
        constructor(i) {
            super(i),
            i = new Ze().rect(0, 0, 4, 200).fill({
                color: 16777215
            }),
            this.Xb = new Ze().circle(0, 0, 8).fill({
                color: 16777215
            }),
            this.Xb[c("dbe9abab31e42cbd87f1")] = "static",
            this.Xb[c("64d6d3451b56d8")] = "pointer",
            this.Xb[c("5536b87bb03e326333")][c("08a1")] = 2,
            this.Xb.on("pointerdown", this.jk),
            this.addChild(i),
            this.addChild(this.Xb),
            this[c("9c85b71be1038792")] = new Oe(0,0,10,200)
        }
        jk(i) {
            Zt = this,
            zh = i.pointerId
        }
        Bh(i, e) {
            e && Ti(.25 + 3.75 * i),
            this.Xb.y = Math.max(this.Xb.height / 2, Math.min((1 - i) * this.height, this.height - this.Xb.height / 2))
        }
    }
    , Ao = class extends Ds {
        constructor(i) {
            super(i),
            (i = new ke({
                [c("e44143cf9c")]: i.Xe,
                [c("34f6027e546c")]: {
                    [c("f58018c60dac9ac1948206")]: c("7495e2141927c9"),
                    [c("dda830fe15818aee80")]: 12,
                    [c("a5f04e3445")]: 16777215
                }
            })).position.y = 5,
            i.position.x = 100,
            i.anchor.x = .5,
            this.Xe = i,
            this.addChild(i)
        }
        Me(i) {
            for (; this.children[1]; )
                this.removeChild(this.children[1]);
            let e = this.Xe.height + 15;
            for (let n = 0; n < i.length; ++n) {
                var t, r = i[n], s = new ke({
                    [c("1257b15d62")]: (n + 1).toString() + ". " + r[0],
                    [c("b8fa8e72d068")]: {
                        [c("487fe5f538dbef72394deb")]: c("6b4c390d8e4e82"),
                        [c("6fc61e8c87f79c9c12")]: 12,
                        [c("980fb387f0")]: 16777215
                    }
                });
                s.position.y = e,
                s.position.x = 5,
                r[2] && ((t = new ke({
                    [c("a5e242205d")]: (n + 1).toString() + ". " + c("7f95b4b075dd75d3b2fcacc83b"),
                    [c("0909ff45e11b")]: {
                        [c("0a7da3737ad9b1cc7b4fad")]: c("d59603db38a4a8"),
                        [c("7e692f7ff6c02defe3")]: 12,
                        [c("39ccd200d1")]: 16766720
                    }
                })).position.y = e,
                t.position.x = 5,
                s.position.x = 5 + t.width,
                s.text = r[0],
                this.addChild(t)),
                (r = new ke({
                    [c("d93e3e7429")]: r[1],
                    [c("0101f74de913")]: {
                        [c("8037adbdf093a73ae135b3")]: c("06c79cca6b75bf"),
                        [c("c47369f9bcca6361a9")]: 12,
                        [c("d0c77b4fb8")]: 16777215
                    }
                })).position.x = 195,
                r.position.y = e,
                r.anchor.x = 1,
                e = e + s.height + 5 + 5,
                this.addChild(s),
                this.addChild(r)
            }
            this[c("6b74042aae529403")] = new Oe(0,0,this.width,this.height)
        }
    }
    , Mr = new class extends Te {
        constructor(i) {
            super(i),
            this.alpha = 0,
            this.ng = new ke({
                [c("272c4ce2df")]: c("d40023e5aec06a0ee9693b9dd0"),
                [c("51b1a7fdb9a3")]: {
                    [c("dbeab2a02bd600bf8af89c")]: c("e0e17660855b55"),
                    [c("1baa7260eb83c86846")]: 12,
                    [c("65308e7485")]: 16766720
                }
            }),
            this.jh = new ke({
                [c("16d3bdd16e")]: c("9b"),
                [c("074b7d03e759")]: {
                    [c("b2a51babc2011924d3a705")]: c("71b2a7f7948804"),
                    [c("34e319694c5a13f159")]: 12,
                    [c("42356d392a")]: 65280
                }
            }),
            this.ck = new ke({
                [c("51b6b6fca1")]: c("21"),
                [c("0101f74de913")]: {
                    [c("766157670ecd5de0176339")]: c("6061f6e005dbd5"),
                    [c("7fd6ee9c77e76c8ce2")]: 12,
                    [c("72e55de91a")]: 16777215
                }
            }),
            this.wm = new ke({
                [c("36b39db14e")]: "",
                [c("5cdeea560c54")]: {
                    [c("64d3c9591c7fcbd605d1d7")]: c("cf508511326a26"),
                    [c("c1542c9a3165ae82ac")]: 12,
                    [c("9acd35c1f2")]: 16711680
                }
            }),
            this.ng.position.x = 0,
            this.jh.position.x = this.ng.width,
            this.uh = 0,
            this.addChild(this.jh),
            this.addChild(this.ck),
            this.addChild(this.ng),
            this.addChild(this.wm)
        }
        pk() {
            this.li = !1
        }
        Fk() {
            var i = performance.now();
            10 < i - this.uh && (this.uh = i,
            this.li && this.alpha < 1 && (this.alpha += .1),
            !this.li) && 0 < this.alpha && (this.alpha -= .1)
        }
    }
    , Qt = new ke({
        [c("ec4e5ac69ca4")]: {
            [c("ee19dfef8645d5689febc1")]: c("7374213596468a"),
            [c("4a3d63333a8c799b37")]: 17,
            [c("4550ae94a5")]: 16776960,
            [c("ec4a41cd9496402284")]: 1,
            [c("d77fb6383f5b2f2faf478836177c")]: 800
        }
    }), Bs = (Qt[c("4ea979923b017800")] = 0,
    Qt[c("f6e6d6ea9264ce")].x = .5,
    Qt.y = 30,
    new Ao({
        Xe: c("b7a0ea")
    })), Cr = new Ao({
        Xe: c("fa59f94eb1dd84")
    }), Ir = new er, tt = Bi(c("f3d39c8813c70e")), Hh = Bi(c("31c5dc0bd2ca52")), jt = Bi(c("ce3bff02a78ef18ba2")), _w = Bi(c("e5b806ee00bd8ae882ac")), qt = Bi(c("1f2344e6f73dc8f3482d5d")), wo = (jt[c("1bbd686beda9f2774fb14662c8aa")](c("7ca5ca22ec"))[c("5fe304a6a2e091a40efa1cae8e")](c("684dd8da02cec25e0424"), c("0f2e7e")),
    null), Fs = [], ht = new Ze;
    {
        let i = function(d, f) {
            return f.Eb !== d.Eb ? f.Eb - d.Eb : f.Hb !== d.Hb ? f.Hb - d.Hb : f.Jb !== d.Jb ? f.Jb - d.Jb : f.level - d.level
        }
          , e = function(d, f, b) {
            return `
            <div class="lb-rank">${f}</div>
            <div class="lb-player">
                ${!b && f <= 10 ? `<span class="lb-rank-icon">${a[(f - 1) % a.length]}</span>` : ""}
                ${`
            <div class="lb-name" title="${d.username}">
                ${d.username}
            </div>
        `}
            </div>
            <div class="lb-num">${d.Hb}</div>
            <div class="lb-num">${Math.floor(50 * d.Jb)}</div>
            <div class="lb-num">${d.Eb}</div>
            <div class="lb-num">${d.level}</div>
        `
        }
          , t = function() {
            m = o.key,
            f = o.dir,
            d = f === "desc";
            var d, f = m === "general" ? function(w, E) {
                return i(w, E) * (d ? 1 : -1)
            }
            : m === "kills" ? function(w, E) {
                return d ? E.Hb - w.Hb : w.Hb - E.Hb
            }
            : m === "point" ? function(w, E) {
                return d ? E.Jb - w.Jb : w.Jb - E.Jb
            }
            : m === "hs" ? function(w, E) {
                return d ? E.Eb - w.Eb : w.Eb - E.Eb
            }
            : m === "lvl" ? function(w, E) {
                return d ? E.level - w.level : w.level - E.level
            }
            : function(w, E) {
                return i(w, E) * (d ? 1 : -1)
            }
            , b = (f = (m = l).sort(f)).findIndex(function(w) {
                return w.id === u
            }), m = 0 <= b ? b + 1 : m.length + 1, x = D(c("28dc5848401f3c904772")), v = D(c("b8acc838d06fb3ea92fe75"));
            x.innerHTML = "";
            let S = document.createDocumentFragment();
            f.forEach(function(w, E) {
                var P = document.createElement("div");
                P.className = "lb-row",
                E < 10 && P.classList.add("top" + (E + 1)),
                P.innerHTML = e(w, E + 1, !1),
                S.appendChild(P)
            }),
            x.appendChild(S),
            f[b] && (v.innerHTML = e(f[b], m, !0),
            v.classList.add("lb-row", "lb-meRow"))
        }
          , r = D(c("8feefd6772a03864e3a6"))
          , s = D(c("023da8772bf5a9fa61"))
          , n = D(c("f381c7d51bca2e989adc"))
          , a = "\u{1F451} \u26A1 \u{1F525} \u{1F3AF} \u{1F680} \u{1F6E1}\uFE0F \u{1F48E} \u{1F3AE} \u{1F6E0}\uFE0F \u2B50".split(" ")
          , o = {
            key: "general",
            dir: "desc"
        }
          , l = []
          , u = 0;
        Array.prototype.slice.call(jt.querySelectorAll(".lb-thc")).forEach(function(d) {
            $(d, "click", function() {
                var f = d.getAttribute("data-sort");
                f && (f === "rank" ? (o.key = "general",
                o.dir = "desc") : o.key === f ? o.dir = o.dir === "desc" ? "asc" : "desc" : (o.key = f,
                o.dir = "desc"),
                Array.prototype.slice.call(jt.querySelectorAll(".lb-thc")).forEach(function(b) {
                    b.classList.remove("active", "asc")
                }),
                d.classList.add("active"),
                o.dir === "asc" && d.classList.add("asc"),
                t())
            })
        }),
        $(r, c("86742470e9f0"), async () => {
            fe(n, c("fc2c5dbb69a727"));
            try {
                var d, f = await (await fetch(c("483cb8dd2dede73a6267f5c620fafa42394dffd93ec2ff5d041490f5") + B["1ak"])).json(), b = f[c("b62b113ace")];
                l = [];
                for (d of b)
                    l.push({
                        id: d[c("a5ff43")],
                        username: d[c("4ff522a7a1eab4ab32")],
                        Hb: d[c("b0ea9b6fd876")],
                        Eb: d[c("a5fe42394de9c333d9ed")],
                        Jb: d[c("027ea56d59e4abf6787e")],
                        level: d[c("e61bcd0f8f97")]
                    });
                u = f[c("f3c990")],
                t()
            } catch {}
        }
        ),
        $(s, c("54c6fa4e3b42"), () => {
            me(n, c("7020d1b71db3d3"))
        }
        )
    }
    {
        let i = function() {
            var ee = 3 <= et.value.length && N.cf != 0;
            return Gt.disabled = !ee,
            ee
        }
          , e = D(c("23fa5673d3acc0744caf007cdb8e"))
          , t = D(c("c351f785341d3dcea212aacd18f230b2"))
          , r = D(c("398f895fcecb4b0428dca407e8c2261a3a"))
          , s = D(c("cb59ff8d3ce525b6baeab2b57aeb35a5a8e9"))
          , n = D(c("8d5b3d7372ede33ddce2"))
          , a = D(c("1523a5fbea6f77a97e7ab2b2c6"))
          , o = D(c("57ad6bf9a8e9b1ab3ce44cb196e696b915"))
          , l = D(c("56c22ada290e70083d9b0d850d03"))
          , u = D(c("d96f693f2e25b67ea73b0f71"))
          , d = D(c("2f450391c401d4d4710155cf"))
          , f = D(c("887cf8e8eeba8836fc04"))
          , b = D(c("84f0f464e02a8cb2e0b8"))
          , m = D(c("96026a1af2d86d9dd8460c54"))
          , x = D(c("1d2bade3d57742b9087ec2b4d9"))
          , v = D(c("6014908009d4d6740755c5c9"))
          , S = D(c("a2965686d2520954e9d400d2dc"))
          , w = D(c("475d7b89a515aed50cef3dada1"))
          , E = D(c("5b296f7dac788e254e75073f8b719d330e6f"))
          , P = D(c("e97f592f00318d499d075e471c1494449c"))
          , C = D(c("e410148486d04950c14d5cd096a05c2a803c"))
          , L = D(c("5eca12c2161645184b94479d0f"))
          , F = D(c("730147559f5baa0f17"))
          , X = D(c("84f0f464e02afbebdfb8a2"))
          , ie = D(c("144064d474862d466e082d"))
          , te = D(c("9cc8ec5cd51d9681c5d88a18df54989edf"))
          , V = D(c("4cb8bc2c2a4efdce19d0fa"))
          , K = D(c("c91f79cf3751a06d9c2b3d"))
          , W = D(c("7f95b3c165db6a92d4d1f39f"))
          , J = D(c("5fb553e18ae080bb34f113bf"))
          , he = D(c("0a3efe2e60f6b3ca414aae40"))
          , je = D(c("d2c6a6d6be14d400a99f"))
          , re = D(c("d16761373d35856dba06327f29"))
          , ne = D(c("b420c4b4cfee8a7e"))
          , ei = (Ao = c("e17c10711720826ac4370a6c"),
        (mw || jt)[c("a0009796d68cb512c41c898fc38faf13dc")](Ao))
          , Re = D(c("c2fde7b0a823ed2be7b9e3a9ba30fd"))
          , mt = D(c("f8e7482e8c215fb62db3363d"))
          , Qe = D(c("5ec146840e1f090605854d9c04564e0900"))
          , It = D(c("095fb90ffa0441217ce7d02cf4e8702d"))
          , gt = D(c("706fc5b959abd56a00"))
          , wi = D(c("71cc90cc948810cd54849ac198c31dc4ef"))
          , et = D(c("cc383cacbec25c42b940"))
          , Gt = D(c("ae1a4272dca027b0d42a113d"))
          , Ne = D(c("82b676a6e8740d6bf8f43e"))
          , ti = D(c("bc239bf7a9e52f71b07b"))
          , Bt = null;
        $(ti, c("4ebc7c883108"), () => {
            B["1ak"] = 0,
            Se(),
            tt.location.reload()
        }
        ),
        $(et, c("899365cc788a"), i),
        $(Gt, c("4b9f2157ac6b"), () => {
            (async () => {
                if (i()) {
                    var ee = new FormData;
                    ee.append(c("e1260c7f0038"), B["1ak"]),
                    ee.append(c("1573e4adeb647aa178"), et.value),
                    ee.append(c("3eac668e3626763b"), N.cf),
                    N.cf = 0,
                    i(),
                    me(Ne, c("a4948503c10f8f"));
                    try {
                        var xe = (await (await fetch(c("6d7bdd6690121a01472099419a01564f150f91576457b172"), {
                            [c("5844ffdf34c2fa")]: c("c3248ae513"),
                            [c("c1502c903c")]: ee
                        })).json())[c("bf93ae5626")];
                        if (xe === 200)
                            return !tt.location.reload();
                        if (xe === 201)
                            fe(Ne, c("4a3a6f2927a975")),
                            _e(Ne, c("c16730913758a695ac1f79cc244dea32e136326f3028"));
                        else {
                            if (xe !== 202)
                                throw 0;
                            fe(Ne, c("c8f8696fa56b6b")),
                            _e(Ne, c("ec6441cad5f302279b2b11b3ddfb0a239d3b5bea32e12376366528b665bc6f693c3e2fad74"))
                        }
                    } catch {
                        fe(Ne, c("2a5a8f4947c995")),
                        _e(Ne, c("9ca3bb1bd71e909881c7d612da0b8589"))
                    }
                    tt[c("3237813758b48ca0562e")][c("b8fb9f78d979")](Bt)
                }
            }
            )()
        }
        ),
        $(gt, c("0efcbcc87148"), () => {
            me(It, c("0d91ffa5ff"))
        }
        ),
        $(wi, c("e3f789bf04f3"), () => {
            Bt ||= tt[c("f0b547319a3642ae94ac")][c("cf72b42c376127")](c("f0e40070803044a98bbd5327996050a663ba6f306b3b32b661b72f29"), {
                [c("d77bb03e3e673837")]: c("4fb029f692c5948716c91a8c93e4a4b868d617a881e782e23d"),
                [c("13b77c7cf2")]: c("54c3fa422040f8c739"),
                [c("423065392ab569ba21")]: function(ee) {
                    N.cf = ee,
                    i()
                }
            }),
            fe(It, c("f0ae42269a"))
        }
        ),
        $(Qe, c("1c0e3286439a"), () => {
            jt[c("9007a78ff896b515fd0cb4aef088b30ace05")] ? jt[c("b2a60cacc2010d25d6b81fbfdb2aee")]() : jt[c("f42759a381")][c("19f8fe3de8eb6c2467e7cf38d6f5553d4cf4")]()
        }
        ),
        $(mt, c("0efcbcc87148"), () => {
            Ye.Ic()
        }
        );
        for (Nh of ei) {
            Jg = Nh,
            e1 = c("fc2c");
            let ee = Jg[c("2a5f8d494fcc95b5")][e1];
            $(Nh, c("61b18ffd86bd"), () => {
                var xe = c("a002879fc1969212cc2a8f89da989c");
                Re[c("ac998f0bd1f29777")][xe] = ee
            }
            )
        }
        let it = r.firstElementChild;
        $(r, c("7caed226e33a"), ee => {
            var xe, Me;
            (ee = ee.target).nodeName === c("63563002b357a7") && (xe = D(c("fa25cf689dfba9fe6c40ea7465e3a1ef6f")),
            Me = D(c("67bd5be99ffd8ff3") + ee.getAttribute("data-tab")),
            me(it, c("0113e040ec0062")),
            me(xe, c("5cccfd5b0947c7")),
            fe(ee, c("a335c6e24e2e4c")),
            fe(Me, c("72e257f11f715d")),
            it = ee)
        }
        ),
        $(e, c("5367392fb463"), () => {
            fe(t, c("ee1ed3f59b75d1"))
        }
        ),
        $(s, c("7caed226e33a"), () => {
            me(t, c("225287414fc18d"))
        }
        ),
        $(n, c("ab3fc1f74c0b"), () => {
            _w[c("3eac6cb832316b3434b3")][c("03c3779ff3dddd9f73c8")](N.bg)
        }
        );
        for (Oi of Object.keys(tr))
            e = Gi(c("6d319f54980d1d")),
            fe(e, c("1d7bf6fdce6257bd4a78")),
            _e(e, Oi),
            lt(e, Oi),
            Si(a, e);
        lt(a, B["1b"]),
        $(a, c("c0f26a72aa7263"), () => {
            B["1b"] = a.value,
            Se()
        }
        );
        for (Xh of Object.keys(jh))
            Oi = Gi(c("4cf2fe6b394efc")),
            fe(Oi, c("edab068d1e9287cd9a88")),
            _e(Oi, Xh),
            lt(Oi, Xh),
            Si(o, Oi);
        lt(o, B["1o"]),
        B["1o"].toString() != c("a7e8") && (jt[c("7d1f8a55730bd051e913644c6608")](c("8d1c602468"))[c("9ad828d4f24a")][c("e614dd0b9994de")] = c("72f646e95e20") + jh[B["1o"]] + c("e89e031ede7e0b8dc0a047379b")),
        $(o, c("a1714bb54b71c2"), () => {
            var ee = o.value;
            (B["1o"] = ee) != c("fdde") ? jt[c("d3f5a0a325f10aafb7e9beba30e2")](c("36a597ad43"))[c("36b48cb0562e")][c("b6240d3bc9a40e")] = c("f6f2cae5d22c") + jh[ee] + c("5ec809d45030014756965d8d05") : jt[c("7e7e3574f0ea17f0ea722b6de5e9")](c("5524b86ca0"))[c("ce2ce418be86")][c("9ded6a2252fdd1")] = "",
            Se()
        }
        ),
        lt(l, B["1d"]),
        $(l, c("f1011b451b0192"), () => {
            B["1d"] = parseInt(l.value),
            Se()
        }
        ),
        Ci(x, B["1af"]),
        $(x, c("ff536913ed53e0"), () => {
            B["1af"] = x.checked,
            Se()
        }
        ),
        lt(v, c("3bc90f1d") + B["1g"].toString(16).padStart(6, "0")),
        $(v, c("e3f78db709ff0c"), function() {
            B["1g"] = parseInt(this.value.substring(1), 16),
            N.fe(),
            Se()
        }),
        lt(S, c("c43034a4") + B["1ae"].toString(16).padStart(6, "0")),
        $(S, c("ddad37f10fb586"), function() {
            B["1ae"] = parseInt(this.value.substring(1), 16),
            Se()
        }),
        lt(w, c("34a04434") + B["1v"].toString(16).padStart(6, "0")),
        $(w, c("8357ed17695f6c"), function() {
            B["1v"] = parseInt(this.value.substring(1), 16),
            N.fe(),
            Se()
        }),
        lt(E, B["1s"]),
        $(E, c("96443048f4cc39"), () => {
            B["1s"] = parseInt(E.value),
            Se()
        }
        ),
        Ci(P, B["1z"]),
        ht.visible = B["1z"],
        $(P, c("ee1cd8e09c64d1"), () => {
            B["1z"] = P.checked,
            ht.visible = B["1z"],
            Se()
        }
        ),
        Ci(C, B["1k"]),
        $(C, c("9327fde7792f7c"), () => {
            B["1k"] = C.checked,
            Se()
        }
        ),
        lt(L, B["1y"]),
        $(L, c("043c28a77dad"), () => {
            var ee;
            L.value !== "" && (L.validity.valid ? (ee = parseInt(L.value),
            isNaN(ee) ? (L.value = 0,
            B["1y"] = 0,
            Se()) : ee < 0 || 65535 < ee ? L.value = B["1y"] : (B["1y"] = ee,
            Se())) : L.value = B["1y"])
        }
        );
        for (Tt of Object.keys(Jt))
            v = Gi(c("b628083dd3a412")),
            fe(v, c("51b7baa9bab623e136a4")),
            _e(v, Tt),
            lt(v, Tt),
            Si(F, v),
            Jt[Tt] = new Audio(Jt[Tt]);
        B["1u"] && (fe(Tt = Gi(c("0bd37d8ae6afff")), c("0107ea19ea0673516614")),
        _e(Tt, c("1f1354e1d73bc8")),
        lt(Tt, c("6b5f182d9b4f9c")),
        Si(F, Tt),
        Jt[c("94a6a314ec06b7")] = new Audio(B["1u"])),
        lt(F, B["1c"]),
        $(F, c("4555af99a75d2e"), () => {
            var ee = Jt[B["1c"]];
            ee && ee.pause(),
            B["1c"] = F.value,
            (ee = Jt[B["1c"]]) && ee.play(),
            Se()
        }
        );
        for (vi of Object.keys(ai))
            Tt = Gi(c("407ef2e72dfae8")),
            fe(Tt, c("d93f3221323eab798e3c")),
            _e(Tt, vi),
            lt(Tt, vi),
            Si(X, Tt),
            ai[vi] = new Audio(ai[vi]);
        B["1aj"] && (fe(vi = Gi(c("c5d9370c20d5a5")), c("f75d9047145c0907905e")),
        _e(vi, c("aaf819ceda501d")),
        lt(vi, c("914166b76169fa")),
        Si(X, vi),
        ai[c("28ba1f08581203")] = new Audio(B["1aj"])),
        lt(X, B["1ai"]),
        $(X, c("46b460b8243c69"), () => {
            var ee = ai[B["1ai"]];
            ee && ee.pause(),
            B["1ai"] = X.value,
            (ee = ai[B["1ai"]]) && ee.play(),
            Se()
        }
        ),
        Ci(ie, B["1n"]),
        $(ie, c("1d6df7b1cf7546"), () => {
            B["1n"] = ie.checked,
            Se()
        }
        ),
        Ci(te, B["1ac"]),
        $(te, c("1baf756ff1b7c4"), () => {
            B["1ac"] = te.checked,
            Se()
        }
        ),
        _e(V.nextElementSibling, B["1i"]),
        $(V, c("b4669ee6d6ee9f"), () => {
            _e(V.nextElementSibling, V.value),
            B["1i"] = parseFloat(V.value),
            Se()
        }
        ),
        $(V, c("6e965e7107f7"), () => {
            _e(V.nextElementSibling, V.value)
        }
        ),
        _e(K.nextElementSibling, B["1x"]),
        $(K, c("172b71ebf52bf8"), () => {
            _e(K.nextElementSibling, K.value),
            B["1x"] = parseFloat(K.value),
            Se()
        }
        ),
        $(K, c("39c3d51cc8da"), () => {
            _e(K.nextElementSibling, K.value)
        }
        ),
        _e(W.nextElementSibling, B["1p"]),
        $(W, c("7022daa21aa2d3"), () => {
            _e(W.nextElementSibling, W.value),
            B["1p"] = parseFloat(W.value),
            Se()
        }
        ),
        $(W, c("9c84b01fd505"), () => {
            _e(W.nextElementSibling, W.value)
        }
        ),
        _e(J.nextElementSibling, B["1q"]),
        $(J, c("0111eb55eb1162"), () => {
            _e(J.nextElementSibling, J.value),
            B["1q"] = parseFloat(J.value),
            Se()
        }
        ),
        $(J, c("34ec18774d7d"), () => {
            _e(J.nextElementSibling, J.value)
        }
        ),
        _e(he.nextElementSibling, B.mo),
        $(he, c("00b22a326a3223"), () => {
            _e(he.nextElementSibling, he.value),
            B["1w"] = parseFloat(he.value),
            Se()
        }
        ),
        $(he, c("dda731e014a6"), () => {
            _e(he.nextElementSibling, he.value)
        }
        ),
        Ci(je, B["1l"]),
        $(je, c("41d1ab15abd122"), () => {
            B["1l"] = je.checked,
            Se()
        }
        ),
        Ci(re, B["1m"]),
        $(re, c("87dbe19b65db68"), () => {
            B["1l"] = re.checked,
            Se()
        }
        ),
        Ci(ne, B["1a"]),
        $(ne, c("b4669ee6d6ee9f"), () => {
            B["1a"] = ne.checked,
            Se(),
            tt.location.reload()
        }
        ),
        $(u, c("cab8e4bca038f5"), () => {
            var ee, xe = u.files[0];
            xe && ((ee = new FileReader).onload = Me => {
                B["1e"] = Me.target.result,
                Se(),
                location.reload()
            }
            ,
            ee.readAsText(xe))
        }
        ),
        $(d, c("b949538d5349da"), () => {
            var ee, xe = d.files[0];
            xe && ((ee = new FileReader).onload = Me => {
                B["1j"] = Me.target.result,
                Se(),
                location.reload()
            }
            ,
            ee.readAsText(xe))
        }
        ),
        $(f, c("84b6ae36e63eaf"), function() {
            var ee, xe = this.files[0];
            xe && ((ee = new FileReader).onload = Me => {
                B["1t"] = Me.target.result,
                Se(),
                location.reload()
            }
            ,
            ee.readAsDataURL(xe))
        }),
        $(b, c("6052cad20ad2c3"), function() {
            var ee, xe = this.files[0];
            xe && ((ee = new FileReader).onload = Me => {
                B["1u"] = Me.target.result,
                Se(),
                location.reload()
            }
            ,
            ee.readAsDataURL(xe))
        }),
        $(m, c("e77b813b057b08"), function() {
            var ee, xe = this.files[0];
            xe && ((ee = new FileReader).onload = Me => {
                B["1aj"] = Me.target.result,
                Se(),
                location.reload()
            }
            ,
            ee.readAsDataURL(xe))
        })
    }
    var T = {}
      , G = {}
      , z = {}
      , Ii = new Ds
      , Ji = new Fe
      , ct = new Fe
      , se = null;
    T.Ze = Bi(c("5b7b3420bb7f96")),
    T.d = T.Ze[c("273c46f9de31c8f05b")],
    z.e = function() {
        var i = B["1n"] ? 1 : T.Ze[c("c0f56765ad7663c7a1e16f779e7c7af6bf")];
        return (i = B["1ac"] ? .5 : i) || 1
    }
    ,
    T.Ze.addEventListener(c("7fdcee9367"), async function() {
        function i() {
            var h = tt.visualViewport;
            document.documentElement.style.setProperty("--stage-scale", Math.max(.1, Math.min((h && h.width || tt.innerWidth) / 1786, (h && h.height || tt.innerHeight) / 1070))),
            G.w.ea()
        }
        var e, t, r, s, n, a, o, l, u, d, f, b, m, x, v, S;
        function w(h) {
            this.Va = h,
            this.D = 0
        }
        function E(h, p, _, g, y, M, A, R, I, U) {
            this.Ab = h,
            this.Ch = p,
            this[c("3d7ada88b5473191")] = null,
            this.Dh = !1,
            this.jb = _,
            this.kb = g,
            this.Wf = y,
            this.Xf = M,
            this.cj = A || (I || y) / 2,
            this.ul = R || (U || M) / 2,
            this.Nh = I || y,
            this.Rh = U || M,
            this.Nl = .5 - (this.cj - .5 * this.Nh) / this.Wf,
            this.db = .5 - (this.ul - .5 * this.Rh) / this.Xf,
            this.Ul = this.Wf / this.Nh,
            this.Zl = this.Xf / this.Rh
        }
        function P(h, p, _, g, y, M, A, R, I, U, H, Q, k, Y, ae, oe) {
            this.og = h,
            this.pg = p,
            this.xm = _,
            this.Km = g,
            this.Di = y,
            this.Tm = M,
            this.Mi = A,
            this.an = R,
            this.vb = I,
            this.qn = U,
            this.Vi = H,
            this.Bn = Q,
            this.Zi = k,
            this.ij = Y,
            this.Ng = ae,
            this.sj = oe
        }
        function C() {}
        function L(h) {
            this.qf = h
        }
        function F() {
            this.cc = []
        }
        function X(h, p) {
            this.ih = h,
            this.ne = p,
            this.Kf = this.If = 0
        }
        function ie() {
            this.Ea = new Te,
            this.Ea.sortableChildren = !0,
            this.H = new a,
            this.H.zIndex = 1.6,
            this.P = 0,
            this.i = Array(797),
            this.i[0] = this.Ih(0, new T.mb, new T.mb);
            for (var h = 1; h < 797; h++)
                this.i[h] = this.Ih(h, new T.mb, new T.mb);
            this.Oh = this.Mh = this.Jg = 0
        }
        function te(h, p) {
            this.I = h,
            this.I.Da(!1),
            this.id = p,
            this.id.Da(!1)
        }
        function V(h) {
            this.W = h,
            this.ua = !1,
            this.ue = 1
        }
        function K(h, p) {
            this.Yb = h,
            this.vl = p
        }
        function W() {
            ++W.Pl,
            this.hi = this.fi = this.di = this.$h = null,
            this.Sb = this.mi = this.Pd = !1
        }
        function J() {}
        function he() {}
        function je() {
            this.qc = T.nc.gi,
            this.bb = 0,
            this.lh = 500,
            this.Se = 4e3,
            this.sg = 7e3
        }
        function re() {}
        function ne(h) {
            this.Vg = h
        }
        function ei(h, p) {
            this.K = h,
            this.fh = 80 <= h.Wa,
            this.Gc = this.Dc = this.vf = this.tf = 0,
            this.ed = this.fh ? 1 : h.vc,
            this.xg = 1,
            this.Bg = !1,
            this.Df = this.le = 0,
            this.Ma = 1,
            this.Rk = 6.283185307179586 * Math.random(),
            this.rd = new T.Yk,
            this.rd.Tc(G.w.h.B.qc, this.K.qi === T.Xc.Wd ? null : G.w.o.N().me(this.K.qi), G.w.o.N().cl(this.K.Wa)),
            p.ej(h.G, this.rd)
        }
        function Re() {
            this.Na = new b(new T.mb,new T.mb),
            this.Na.id.u.ao = "add",
            this.Na.id.u.zIndex = 100,
            this.Na.I.u.zIndex = 500
        }
        function mt(h, p) {
            this.I = h,
            this.id = p
        }
        function Qe() {
            this.ob = this.gb = this.nb = this.lb = this.ra = 0,
            this.$f = []
        }
        function It(h, p) {
            for (var _ = 0; _ < h.length; _++)
                if (parseInt(h[_][c("2ed694")]) === p)
                    return _;
            return -1
        }
        function gt() {}
        function wi() {}
        function et() {}
        function Gt() {
            this.ad = [],
            this.Rd = []
        }
        function Ne() {}
        function ti(h, p) {
            this.pt = h,
            this.ff = p
        }
        function Bt() {
            var h = new si({
                [c("13a56172e5a1fb7f6fa96e")]: {
                    [c("94848002ea1dbf93cc82ad06d4188d9d")]: [-.5, -.5, .5, -.5, .5, .5, -.5, -.5, .5, .5, -.5, .5],
                    [c("9e4e3454daf00bdad453")]: [-.5, -.5, .5, -.5, .5, .5, -.5, -.5, .5, .5, -.5, .5]
                }
            })
              , p = new Z;
            this.yc = vt.from({
                [c("172f75")]: {
                    [c("59bcbefea9ab27")]: c("7031c0a617acc52e17279ff94ca5d728e821e7e1b4b3aa38e92defe8cef8fe1ef115a691fd87a313fd4ce8dbea88bd5d8543d292f2909403cd01ba94df949a16dfefd730f620c6c6d9fd8e79d56f8bfba5b43023b27065a5edab3a7a987876dcbfce6047f1165482e8e86f45b54b71dd8d94100389545284cd8b1a4ebc4f41d595a2462a9b2b7ba68cbb5333d97e7cea3090373d6d3329a565fc786b613c3aec35d36216430a248b7cbd280a721e3880529c2f1250070f8f0dca285e1c3c1b9159671df159a0443755680eb819bf4e7a1463e3fd37f3e9652554ebef3ef4f63a6363b79315d3f7552140f4cc799fae59055290965685d0630d41e9d403cfca1a430397f335b3d92e1c6c88fb11acd721a878e7e1b4f0f115ad698bfebeedeb6da044e0d3b1d7e611cc0ca2a8f382ac0b8543d2d697b1c3459818be9ed4be8110c2e5d730f620c4b79dbbca2e8e3ddbbdf0b43252e12736b2faa92f29fc383cafa6c47110f11726d1bddb6e4ea47d71dc89c54b5c8a101487cd8a6e1ede0d58da93f21a22a22044b39db16a248f244aa66fbf6761477074e739f77a72296e0cfa20a07751244064d73ddb6a4e2e5d338e54c24741141810870dcb5a5e1f394bcd007422f15bef13644c6015e571ec0a7d2969a7a174bfa325786cddf43ef1ea4b2240fcd032cae44a1548eed935d5bb1d501b878154c0f2450957d9dd03cfc3721135c0aa0ce085055d79fbee4efd9b7db074f0e3a1e7f630e4069ab4ffb4ba36ff0ff7d1a4c0e523bd5bea9df98eea47881c948381c7d65d8d4bda8dc98f9a1ac8d19d70dd719fe8d6a0d473c528cccce5a33223ea2523a58bbc382bfd333eb6f5925006e46433909c"),
                    [c("1560e5a9fe677ea269")]: c("1576e5adfa6368a57260bae2917a4ab34d6682ea997c47b34c6a8ad3f30703a51016f69ed858428553499ac2f14426977713f5c8bf6e2e840e51a072b56760467076967db7233d632f23fa22d12406775173d5289c190470022ca05694101f450c43c46adc5a3a591307995f731fa606b50566557916ee4ebf3a2a7221f7c721edf2623a7cafa80eb8be5e254ffbc53bd7fb026a19ecce3f9fbb1d5044f6d61cc1d3450d6ac9da00d88b0c3264828201abdf21173bd7ee4efdc82ae363e7e1b4a09232f02dbfa9e992a839e304a6c6a7a7f357d94ceaaaea82b70b8543d29ec59c885f815cd8cb89caac5a80c0d7318420c4b79dbbca2e8e3d88eaa3a52721f46163efbcec787e8f7262f0a2842013f1165282ea996e4ea4596bdd8583661b916143cf9ccc585ec90f6d9ac2f14417913d75a897bb5e6ece7d14ea32e13707612d32a27abc19386d312bfa22d17751564064d76dbd3f1368182c8a6f97040041014fd21bbb4f491c585ccf153342a606b55337792c48bb19bf4e2a7221a7a174e3e3747c3cb8ab2df9e46a2355f7c717cafa482a0ca89b799eda0a5201d6d61cc1d3450d7ac5d703cf8b0d406b97f144f598745d7af8ee4efd9b7db074f0e3a1e7f672b818efe9bcf8fc6fb553e2c6a6d5a002fb5dffd9ac82a80ad21d838ae79a8a18da5cd8cb89ceaa5a82b18466d731def2fbe69664ce4288eab2fd636aea6761f5edab493efe2d3eb1e0883711e40f3395e8dc5944b0426ce096d4505f854c08d6cd8a681ede0d0b8dc0e40073d17706e2c8881f79cc680cff25e37276366521bb579f383a6b1e21b37f937751244065a33ddb6a0a78072b9c549406304b1909850dcb5a5e1e3f4bcd006e04e646e9177e7b6616e44ea84d4d6521c3b673d1")
                },
                [c("273f59ef")]: {
                    [c("d295f197a202e0")]: {
                        [c("bc6890fbb2e8527cad7b72")]: "vertmain",
                        [c("dc5e71da92d247")]: c("f75b8d180e4f094bcd00461eec56e41a5256601ce44ee00d2a7221a7a406b0b6566d2bbabe7eadab2d6004a09321f5e448324cf9df35c2f0620145d0da1c9095760558de88148e8b0c332781f151f6f3624a0a9ffb3de88c7fa563f2f6b6e5e365b82c9db4feb1aa0be200bc90f28aa40ad508ae99f595fb5ce11c8387978dd5529b3a8cc89ed8dd3a95b3b1268444d3b588acc83b993fceaaf2a17744ab676af38bf66674be5c62efb8c0371095002497aecc791ff91e5dc9d3830700a11014f4cd896b1ede0d0b8dc0e40073d17706b2aaac492490384aa66fbf6760457074e77ebc2969296e0db923d37750514064a43dd91b4e2b297bdf61d45232570114824b8d4f491c31019c516d27ed5de31975557a5fb90ca8494d6521c3b676a5a325783cb8ab69afbe6a0453f3cd27c3f9553564fbdf2ec4e60a5370cfd21086de044d0ae9dd5f8f8b0c3564808051f5f7624a799ff94ce88c7fa563f2a6c7baaa38fa7cf99afab8ad6bb5529185a7d7f354dd4ce8a8b9dd9f4a9241c7c194d0d4478d4bda8efe929b11d4a4c142d236c4a28acadf3bfd28c9cbe5a14336f45423a789bc3e2bab6f61eaa089220af1172682ec997842b24977c18799121ac10716c189cb0f08af4840d696ae402ed17673e2caf95d27932f5fa355bf2b356b272ba42deb7a7e3f1c6bed20a63e0c76043ab276803c046e002dca13b34743655052c74f8b050e5c555fd6153342a600b5146e566d13e55ba54e266523b2e525e7a3240b6ce4f22af2fc727512d7866695fa483b48f6fe32c4f840125cd19656858304291c988b20d2cd5e1c14dcaa12aac42a0b6c898959fdff6ab010b1a7f6a0a523ad6bfa8de9afba3ae82ea797e490a242aa59ffdcdec8ee2e8543d2d696c5c345985cd8cb89c9de1dc5e89e77dd6bdef7d7fa937fd56290a6e5a33263ab666fe3a1f6643eff5c2bade0d77740e00025e4be9a280eef683b9da3941272c1071692da890f09dc181c8fd5f5022f9b2657b391a65463cc641bfd30a716367c1629b87abd6f684d787cef66843151315615812bdb7f5859486cac05c12356133143c46adc5a3a094d2fda004057b704f313754c6c02ae0ccc18616523b2e521e7f27a2970e4b369adcf3a6211b7916480a4177d1baa8e689df2400350d6da0bdb8e07411c988b0debcb4d0424ca931bb6df331126d4ee4efd9b7cc174f0e3f2b0a565ad6a89bdbfefeb6cd544e0a0b1d59742aa59ffd9acc8ec5f8543d2d690c58a18cb189e92c393c64e99a4c033d55193fffbe69579d828ccbfe5a24336f62570f2abab2f288f7b3dadf5925706e666339799803f19ec003b9ca5941003b25054c38dc1654e984d5bcbd5f30266c30713f5c8ec087bd97f0eea32e16761347076962deb7a7e3e6d6bed20c46053620424c22ad9371d6c486cdf05c226561645019b479b0b17791307995f731ff01af0267557631fe848e411610d70f6e12deda325783cbada69afbe3a6211b7916480a4177d1baa8e6e9dbb1d501490834e9094070f55c5d90dd1fb511927ddb119b698322f26c8a71899cc2eee22a4bcf6b88b36fc2ba3a3a9effe7aa020f7d1a4c0e457bd5beaceaeddfb5d9054d0c381c7d6529a49c0de9ecd8210d3e09e56da6c90e8cae48925c9598ceeaee2647cb6784bf6bceb6363e92e4cbae0e03711e4002497fd9b2a0eee1d3b9fa1941003c1071692da890f09dc4b4fcdd5f3022c813146b28cec090ad97f0e9965a336367c1a33a378ac3e7e3f1f6bef51c46222315766c22ad97f592c486cdf4f84160351014887478a030f451200da023157b070a044374e6c19bf19be3d697323a7a001bdeb61383cb8ab66b8bc2f2644f1907196d5416b1bbf981985ff790543d6d61ce5c944014dc3d402989c7c557382f25af59f624a0a9ff94cfc907fa974f191a1e58772ba69efe9bcf8fc6fb553e28ce191a612ec47acbff9959d00cf0386d696c5c344ec5cd8cbcda98b07f3ee9d71d020c5c59db9bb2e8c4cdbbdf0b43023e12736b2faa9787eb8687cf1f593224ca15166d2ac8c2969f91f2e8ad0f00704a01015f5cd896b1edc7c5dcb82b45137d177069296a05c248e204dea32e16764467076962deb7a7e3e6d6bed20c460536126398b779b151d791f328e59d45132014756814d9a5e5e1f3e08cc022441c611b7352208485fb90ca84c3f6523b2b676a5f3432d61feee3ef8dd7c314df78667e4b315685fffc86e88ad6c0602909657f083052b1c9afa498f9e1a427197f144e084770d1ddfb308b8cc2acf37a4a0e1a1e364c97cf8ebfab8ad6db5529185a7d7f354dd4ce8a8b9dd9f4a9735c7c3e5d0d6368d4dda9cde929b0f98b3db268635d3b388eb9365d86490e8e8a12b36f62570f6babc382bb9496be7a4d46046f1172682ebe83f19ec597bd794c45056bb074292dbfa4c08de181dfad5f27066c40413f3c8ae4824893d16fd29f47063216176b561b72e32623a66ee39c46053620424c22ad92f387d002e8345834741145055b60dcb5a084d101e93557357b076a046461d3d4aec4ee20b7f6823abb676a5a323787be3f528f4e0787813bb866695e0462a0ca9e829c3f7490f43cf9657f08305584cc4d20ad2dc52036480f351f6f7624a79efa515abd13ded22e7e0c6f0f616ad698bfeb8eda82df106bf86fa91f357d90fb4ceaeddb81dc1168f92cd9bce529838cfc99cd8dc4f95b3c2268635d3b388e59568dd7997e0aeb9323ae12736e19cfc7258a3727cfbf5925306e61560c2bb9b3f189f4b2d9dc5826716d6760387a9900f09dc100b8cb5e40073d17106ab97aa5b3f952250e730f86761342323b43cfc79186a6e7cfa23a47751244061a53dd91b4e2e5d7bdd10d450430147569b4d8d4f491c090b87447400e677ea1a684a2c49ca19bf4e792572b6b677d6e0247a3cb9de69afbe3a6365b79164d1f35f2c5ce8ce0fccf35f0c548ac630d0de431d4bcf9e5efe8b0d4034e1a219b5da220a6c888859ff8e39d434ba90ebbab433ad6bfaf1a9effe2afe08b48ce688a549ed3dbf93e898ac0af312839fc1d0d4478d4ba8de9ecd9b11d9e79d71d976d8f2ecec827fc97f9bc0a6f77176b03c23a48abc3a5ae92f3ebae2913711e4002497b4cc6e0eee1d7fcb8ac45147815165d884d6581edf7c0b8dc0b75720c06005849efa086ecf081bfd30f47117216776a36da13e2e7e380db07c8e204626557cc22ad96a452f486dad05c12356164543c518dc584b094f5e93557557b104ea00624a651bf27fe212603234b1d261a7b6612d7abebe7fdee82c6204a1e67197a6026b6dbf996cdbfb4c541491f0028694125b7c82ce02d4c850022cc1ed0186d92b173bf5bd19bfd22ef97fb0b4e6f0f414ad6bfaeba2ede77aa251f8c6a6d5a309f10fb599f19ef01ae31e8e9cd6ba9012da158b82829ccb4cf2a4c2429137c6a28ab9df398c28ccbfb2f47666b67b23a5f8f86e71b96e7afab4e27d4fbb573395e88c2869f91f2ec096d4505f854c65d884d6581edf7f0b8fb1e40507d17674")
                    },
                    [c("ce39e200b58ef18ba2")]: {
                        [c("74a0d8330a30eaa415a3ca")]: "fragmain",
                        [c("d93934792f2dba")]: c("f75b8d180e4f094bcd00461eec56e41a5256601ce44ee00d2a7221a7a406b0b6566d2bbabe7eadab2d6004a09321f5e448324cf9df35c2f0620145d0da1c9095760558de88148e8b0c332781f151f6f3624a0a9ffb3de88c7fa563f2f6b6e5e365b82c9db4feb1aa0be200bc90f28aa40ad508ae99f595fb5ce11c8387978dd5529b3a8cc89ed8dd3a95b3b1268444d3b588acc83b993fceaaf2a17744ab676af38bf66674be5c62efb8c0371095002497aecc791ff91e5dc9d3830700a11014f4cd896b1ede0d0b8dc0e40073d17706b2aaac492490384aa66fbf6760457074e77ebc2969296e0db923d37750514064a43dd91b4e2b297bdf61d45232570114824b8d4f491c31019c516d27ed5de31975557a5fb90ca8494d6521c3b676a5a325783cb8ab69afbe6a0453f3cd27c3f9553564fbdf2ec4e60a5370cfd21086de044d0ae9dd5f8f8b0c3564808051f5f7624a799ff94ce88c7fa563f2a6c7baaa38fa7cf99afab8ad6bb5529185a7d7f354dd4ce8a8b9dd9f4a9241c7c194d0d4478d4bda8efe929b11d4a4c142d236c4a28acadf3bfd28c9cbe5a14336f45423a789bc3e2bab6f61eaa089220af1172682ec997842b24977c18799121ac10716c189cb0f08af4840d696ae402ed17673e2caf95d27932f5fa355bf2b356b272ba42deb7a7e3f1c6bed20a63e0c76043ab276803c046e002dca13b34743655052c74f8b050e5c555fd6153342a600b5146e566d13e55ba54e266523b2e525e7a3240b6ce4f22af2fc727512d7866695fa483b48f6fe32c4f840125cd19656858304291c988b20d2cd5e1c14dcaa12aac42a0b6c898959fdff6ab010b1a7f6a0a523ad6bfa8de9afba3ae82ea797e490a242aa59ffdcdec8ee2e8543d2d696c5c345985cd8cb89c9de1dc5e89e77dd6bdef7d7fa937fd56290a6e5a33263ab666fe3a1f6643eff5c2bade0d77740e00025e4be9a280eef683b9da3941272c1071692da890f09dc181c8fd5f5022f9b2657b391a65463cc641bfd30a716367c1629b87abd6f684d787cef66843151315615812bdb7f5859486cac05c12356133143c46adc5a3a094d2fda004057b704f313754c6c02ae0ccc18616523b2e521e7f27a2970e4b369adcf3a6211b7916480a4177d1baa8e689df2400350d6da0bdb8e07411c988b0debcb4d0424ca931bb6df331126d4ee4efd9b7cc174f0e3f2b0a565ad6a89bdbfefeb6cd544e0a0b1d59742aa59ffd9acc8ec5f8543d2d690c58a18cb189e92c393c64e99a4c033d55193fffbe69579d828ccbfe5a24336f62570f2abab2f288f7b3dadf5925706e666339799803f19ec003b9ca5941003b25054c38dc1654e984d5bcbd5f30266c30713f5c8ec087bd97f0eea32e16761347076962deb7a7e3e6d6bed20c46053620424c22ad9371d6c486cdf05c226561645019b479b0b17791307995f731ff01af0267557631fe848e411610d70f6e12deda325783cbada69afbe3a6211b7916480a4177d1baa8e6e9dbb1d501490834e9094070f55c5d90dd1fb511927ddb119b698322f26c8a71899cc2eee22a4bcf6b88b36fc2ba3a3a9effe7aa020f7d1a4c0e457bd5beaceaeddfb5d9054d0c381c7d6529a49c0de9ecd8210d3e09e56da6c90e8cae48925c9598ceeaee2647cb6784bf6bceb6363e92e4cbae0e03711e4002497fd9b2a0eee1d3b9fa1941003c1071692da890f09dc4b4fcdd5f3022c813146b28cec090ad97f0e9965a336367c1a33a378ac3e7e3f1f6bef51c46222315766c22ad97f592c486cdf4f84160351014887478a030f451200da023157b070a044374e6c19bf19be3d697323a7a001bdeb61383cb8ab66b8bc2f2644f1907196d5416b1bbf981985ff790543d6d61ce5c944014dc3d402989c7c557382f25af59f624a0a9ff94cfc907fa974f191a1e58772ba69efe9bcf8fc6fb553e28ce191a612ec47acbff9959d00cf0386d696c5c344ec5cd8cbcda98b07f3ee9d71d020c5c59db9bb2e8c4cdbbdf0b43023e12736b2faa9787eb8687cf1f593224ca15166d2ac8c2969f91f2e8ad0f00704a01015f5cd896b1edc7c5dcb82b45137d177069296a05c248e204dea32e16764467076962deb7a7e3e6d6bed20c460536126398b779b151d791f328e59d45132014756814d9a5e5e1f3e08cc022441c611b7352208485fb90ca84c3f6523b2b676a5f3432d61feee3ef8dd7c314df78667e4b315685fffc86e88ad6c0602909657f083052b1c9afa498f9e1a427197f144e084770d1ddfb308b8cc2acf37a4a0e1a1e364c97cf8ebfab8ad6db5529185a7d7f354dd4ce8a8b9dd9f4a9735c7c3e5d0d6368d4dda9cde929b0f98b3db268635d3b388eb9365d86490e8e8a12b36f62570f6babc382bb9496be7a4d46046f1172682ebe83f19ec597bd794c45056bb074292dbfa4c08de181dfad5f27066c40413f3c8ae4824893d16fd29f47063216176b561b72e32623a66ee39c46053620424c22ad92f387d002e8345834741145055b60dcb5a084d101e93557357b076a046461d3d4aec4ee20b7f6823abb676a5a323787be3f528f4e0787813bb866695e0462a0ca9e829c3f7490f43cf9657f08305584cc4d20ad2dc52036480f351f6f7624a79efa515abd13ded22e7e0c6f0f616ad698bfeb8eda82df106bf86fa91f357d90fb4ceaeddb81dc1168f92cd9bce529838cfc99cd8dc4f95b3c2268635d3b388e59568dd7997e0aeb9323ae12736e19cfc7258a3727cfbf5925306e61560c2bb9b3f189f4b2d9dc5826716d6760387a9900f09dc100b8cb5e40073d17106ab97aa5b3f952250e730f86761342323b43cfc79186a6e7cfa23a47751244061a53dd91b4e2e5d7bdd10d450430147569b4d8d4f491c090b87447400e677ea1a684a2c49ca19bf4e792572b6b677d6e0247a3cb9de69afbe3a6365b79164d1f35f2c5ce8ce0fccf35f0c548ac630d0de431d4bcf9e5efe8b0d4034e1a219b5da220a6c888859ff8e39d434ba90ebbab433ad6bfaf1a9effe2afe08b48ce688a549ed3dbf93e898ac0af312839fc1d0d4478d4ba8de9ecd9b11d9e79d71d976d8f2ecec827fc97f9bc0a6f77176b03c23a48abc3a5ae92f3ebae2913711e4002497b4cc6e0eee1d7fcb8ac45147815165d884d6581edf7c0b8dc0b75720c06005849efa086ecf081bfd30f47117216776a36da13e2e7e380db07c8e204626557cc22ad96a452f486dad05c12356164543c518dc584b094f5e93557557b104ea00624a651bf27fe212603234b1d261a7b6612d7abebe7fdee82c6204a1e67197a6026b6dbf996cdbfb4c541491f0028694125b7c82ce02d4c850022cc1ed0186d92b173bf5bd19bfd22ef97fb0b4e6f0f414ad6bfaeba2ede77aa251f8c6a6d5a309f10fb599f19ef01ae31e8e9cd6ba9012da158b82829ccb4cf2a4c2429137c6a28ab9df398c28ccbfb2f47666b67b23a5f8f86e71b96e7afab4e27d4fbb573395e88c2869f91f2ec096d4505f854c65d884d6581edf7f0b8fb1e40507d17674")
                    }
                },
                [c("4ff234b1bcf1a7a532fb")]: {
                    [c("371d6dcfc318c8dc5a")]: p.source,
                    [c("917740a57876fbadeb")]: p.source.style,
                    [c("d1373d6d3329a565aa")]: {
                        [c("5a1e5f02328052be14165619078e")]: {
                            value: [1, .5, .25, .5],
                            type: "vec4<f32>"
                        },
                        [c("2c083a9a487507f151d61566546c")]: {
                            value: [0, 0],
                            type: "vec2<f32>"
                        },
                        [c("7b59290b87447400e67be310745d7d")]: {
                            value: [0, 0],
                            type: "vec2<f32>"
                        }
                    }
                }
            }),
            this.Pc = new Zi({
                [c("06f0adf6677eb86f77")]: h,
                [c("d939336d392bad")]: this.yc
            })
        }
        function it() {
            this.u = new Fe,
            this.Qi = this.Oi = 0
        }
        function ee(h) {
            this.B = h,
            this.K = new T.ye.xe,
            this.ab = !1,
            this.oc = !0,
            this.ge = !1,
            this.yg = this.hb = 0,
            this.Ma = 1,
            this.Kb = this.rf = 0,
            this.fa = {},
            this.Ra = 0,
            this.wb = new Float32Array(400),
            this.Pa = new Float32Array(400),
            this.Z = new Float32Array(400),
            this.U = this.ca = this.ta = this.Xi = null,
            this.Pg()
        }
        function xe(h, p, _, g, y) {
            this.ra = h,
            this.lb = p,
            this.nb = _,
            this.gb = g,
            this.ob = y
        }
        function Me(h) {
            this.A = new T.Of,
            this.A.Ea[c("aada08d9ed57192dd6")](this.A.H),
            this.dc = null,
            this.ec = h,
            this.P = 0,
            this.Qf = this.Mf = this.Lf = this.Jf = this.Hf = this.Ff = this.vc = 1,
            this.uk(c("7543c51b9f0c1d4a1b08"))
        }
        function ut(h) {
            this.W = h
        }
        z.Ga = function(h) {
            var p = h.parent;
            p?.removeChild(h)
        }
        ,
        G.w = null,
        z.Mn = function(h) {
            return encodeURIComponent(h)
        }
        ,
        z.Pn = function(h) {
            clearTimeout(h)
        }
        ,
        z.Qn = function(h) {
            var p = (Math.floor(h) % 60).toString()
              , _ = (Math.floor(h / 60) % 60).toString()
              , g = (Math.floor(h / 3600) % 24).toString()
              , y = (h = Math.floor(h / 86400).toString(),
            c("bf94a04b30"))
              , M = c("a17a4ca15765")
              , A = c("de02c91f")
              , R = c("288a0f18");
            return 0 < h ? h + c("6573d528") + y + c("879dbbca") + g + c("dba9effe") + M + c("706480f3") + _ + c("a93f19ec") + A + c("52462655") + p + c("ef05c352") + R : 0 < g ? g + c("4d1bfd30") + M + c("2692da89") + _ + c("baee4efd") + A + c("74e08477") + p + c("05d3b588") + R : 0 < _ ? _ + c("bd8b0d40") + A + c("2e9ac2f1") + p + c("6573d528") + R : p + c("f1474114") + R
        }
        ,
        z.Sn = function(h) {
            return h.includes(c("439c3753a1")) ? h.replaceAll(c("2ed782a454"), 'target="_black" href') : h
        }
        ,
        z.Tn = function(h, p=null, _=null) {
            var g = T.d[c("9c8eac0ac10587b6c8908b12c60d")](c("0260a7676fe7bc"));
            c("f276da6193e1d1e79f6f") !== typeof p && p !== null && (c("3eba6eb527356d3b23b3") !== typeof p[c("9ac238")] && (g[c("8af228")] = p[c("51abb7")]),
            c("4d4ba164b4243a6a3022") !== typeof p[c("b94b4895534d")] && p[c("a335d6ef493b")] && (g[c("2c1c1d865e62")] = c("59aba8f5b3ad")),
            c("387c14ef59eb17612575") !== typeof p[c("feeba5f76761")] && p[c("af84d4445696")] && (g[c("da8ff98bbb1d")] = c("b5c2520e5cd8")),
            c("fefaaef56775ad7b63f3") !== typeof p[c("a17151bb5665c8aac07d42b2")]) && (g[c("5b6f2f21ac638e200a730c38")] = p[c("f58505c70a9994de948916de")]),
            g[c("b6330139df")] = c("6e8b557906a606c31c664e6809e84ee40e7b"),
            g[c("08aa3838")] = h,
            _ && (g[c("c0fe6c7fab7462")] = g[c("407eece121f4e26e3b6debef29fee67e3e46f7")] = function() {
                try {
                    _()
                } catch {}
                g[c("ff5f6f1eec55e1")] = g[c("916d7db67067f3b1ea7e7ab8786df7b1cf7546")] = null
            }
            ),
            (T.d[c("8cb5ab3ef4")] || T.d[c("5046f7d711c9f34a3d47eed81ed4ca4e077fc3de01")](c("b9425e8d59"))[0])[c("39cbcb1cd8c05b3329dbaf10")](g)
        }
        ,
        z.aa = function(h, p) {
            return p.prototype = Object.create(h.prototype),
            (p.prototype.constructor = p).parent = h,
            p
        }
        ,
        z.tl = function(h) {
            return (h %= 6.283185307179586) < 0 ? h + 6.283185307179586 : h
        }
        ,
        z.Wn = function(h, p, _) {
            return z.Hc(_, h, p)
        }
        ,
        z.Hc = function(h, p, _) {
            return _ < h ? _ : h < p ? p : Number.isFinite(h) ? h : .5 * (p + _)
        }
        ,
        z.Q = function(h, p, _, g) {
            return h < p ? Math.min(p, h + _ * g) : Math.max(p, h - _ * g)
        }
        ,
        z.Ah = function(h, p, _) {
            return p + (h - p) * Math.pow(.5, _ / 33.333)
        }
        ,
        z.te = function(h, p, _) {
            return h - (h - p) * _
        }
        ,
        z.Sf = function(h, p) {
            return Math.sqrt(h * h + p * p)
        }
        ,
        z.Ml = function(h, p) {
            var g = 0 + p;
            if (h == null)
                throw new TypeError;
            var y = h.length >>> 0
              , _ = (p = Math.min(1, y),
            Math.min(0, y))
              , g = g === void 0 ? y : g >> 0
              , y = Math.min((g < 0 ? Math.max(y + g, 0) : Math.min(g, y)) - _, y - p);
            for (g = 1,
            _ < p && p < _ + y && (g = -1,
            _ += y - 1,
            p += y - 1); 0 < y; )
                _ in h ? h[p] = h[_] : delete h[p],
                _ += g,
                p += g,
                y--
        }
        ,
        z.bo = function(h, p, _, g) {
            var y = 6.283185307179586 * Math.random();
            return [h + (_ = Math.sqrt(_ * _ + Math.random() * (g - _) * (g + _))) * Math.cos(y), p + _ * Math.sin(y)]
        }
        ,
        z.Tl = function() {
            return 2147483647 * Math.random()
        }
        ,
        z.Yl = function() {
            var h = [32, 33, 34, 35];
            return h[parseInt(Math.random() * h.length)]
        }
        ,
        z.co = (e = [c("b354"), c("6000"), c("f477"), c("2e8c"), c("ae0b"), c("0eaa"), c("a285"), c("c105"), c("a36c"), c("268e"), c("b626"), c("370a"), c("ff53"), c("b94e"), c("f420"), c("ebfa"), c("69bd"), c("6cd5"), c("1ec6"), c("2259"), c("c2b8"), c("fee3"), c("7824"), c("bf9e"), c("5529"), c("84a5"), c("16d6"), c("23a6"), c("5052"), c("dc59"), c("1256"), c("a96c"), c("49cd"), c("39d2"), c("00a8"), c("a960")].map(function(h) {
            return h.charCodeAt(0)
        }),
        function(h) {
            c("5d3bb17484340a7a0032") == typeof h && (h = 16);
            for (var p = "", _ = 0; _ < h; _++)
                p += String.fromCharCode(e[Math.floor(Math.random() * e.length)]);
            return p
        }
        ),
        z.eo = function(h, p, _, g) {
            p = _ * (1 - .5 * p);
            var y = Math.min(p, 1 - p);
            return z.gg(h, y ? (_ - p) / y : 0, p, g)
        }
        ,
        z.gg = function(h, p, _, g) {
            var y = (p *= 1 - Math.abs(2 * _ - 1)) * (1 - Math.abs(h / 60 % 2 - 1));
            return _ -= p / 2,
            0 <= h && h < 60 ? [_ + p, _ + y, _, g] : 60 <= h && h < 120 ? [_ + y, _ + p, _, g] : 120 <= h && h < 180 ? [_, _ + p, _ + y, g] : 180 <= h && h < 240 ? [_, _ + y, _ + p, g] : 240 <= h && h < 300 ? [_ + y, _, _ + p, g] : [_ + p, _, _ + y, g]
        }
        ,
        z.Pe = function() {
            return Date.now()
        }
        ,
        z.Ud = function(h, p) {
            for (var _ in h)
                h.hasOwnProperty(_) && p(_, h[_])
        }
        ,
        z.ko = function(h) {
            for (var p = h.length - 1; 0 < p; p--) {
                var _ = Math.floor(Math.random() * (p + 1))
                  , g = h[p];
                h[p] = h[_],
                h[_] = g
            }
            return h
        }
        ,
        T.mh = Bi(c("ed9f1dd2109bb1d1938012da")),
        T.Dg = Bi(c("a79cc86e4a8a447bd8")),
        T.Nm = ( () => {
            function h(I) {
                this.Va = I,
                this.D = 0
            }
            let p = c("6d398a54b80c071c")
              , _ = (h.prototype.n = function() {
                var I = this.Va[p](this.D);
                return this.D += 1,
                I
            }
            ,
            c("61b586e0b0bf09ec51"))
              , g = (h.prototype.q = function() {
                var I = this.Va[_](this.D);
                return this.D += 1,
                I
            }
            ,
            c("4eb87595070a7a1167d1"))
              , y = (h.prototype.jc = function() {
                var I = this.Va[g](this.D);
                return this.D += 2,
                I
            }
            ,
            c("a2d401c1ef591c089c"))
              , M = (h.prototype.s = function() {
                var I = this.Va[y](this.D);
                return this.D += 2,
                I
            }
            ,
            c("57ef3cbe92e2a9fd6d"))
              , A = (h.prototype.sf = function() {
                var I = this.Va[M](this.D);
                return this.D += 4,
                I
            }
            ,
            c("d3e3b0b202e137bee8be"))
              , R = (h.prototype.hj = function() {
                var I = this.Va[A](this.D);
                return this.D += 4,
                I
            }
            ,
            c("a2d401c1e05b0758de885e"));
            return h.prototype.f = function() {
                var I = this.Va[R](this.D);
                return this.D += 4,
                I
            }
            ,
            h
        }
        )(),
        T.hh = (t = c("d45673d391c76e13"),
        w.prototype.Je = function(h) {
            this.Va[t](this.D, h),
            this.D += 1
        }
        ,
        r = c("84a6a323c137beeaba"),
        w.prototype.Fb = function(h) {
            this.Va[r](this.D, h),
            this.D += 2
        }
        ,
        s = c("719196d0a08f19dc48dc"),
        w.prototype.cn = function(h) {
            this.Va[s](this.D, h),
            this.D += 2
        }
        ,
        n = c("c8ea6f6f997460ebe393"),
        w.prototype.uj = function(h) {
            this.Va[n](this.D, h),
            this.D += 4
        }
        ,
        w),
        T.Kn = function() {}
        ,
        T.zb = (E.cg = function() {
            return new E("",null,0,0,0,0,0,0,0,0)
        }
        ,
        E.fm = function(h, p, _) {
            return new E(h,p,_[c("edef")],_[c("08eb")],_[c("2d2d")],_[c("f237")],_[c("d2d6")],_[c("fdd8")],_[c("3cba")],_[c("a049")])
        }
        ,
        E.prototype.hg = function() {
            return this.Dh || (this.Ch != null && (this.Texture = new Z({
                source: this.Ch,
                frame: new Oe(this.jb,this.kb,this.Wf,this.Xf)
            })),
            this.Dh = !0),
            this.Texture
        }
        ,
        E.prototype.Nd = function() {
            this.Texture != null && this.Texture[c("cdda2af325b0bcfd")]()
        }
        ,
        E),
        T.lg = (P.prototype.Nd = function() {
            for (var h = 0; h < this.og.length; h++)
                this.og[h][c("74a1d3340c3bd5b2")]();
            for (this.og = [],
            h = 0; h < this.pg.length; h++)
                this.pg[h].Nd();
            this.pg = []
        }
        ,
        P.cg = function() {
            var h = new P.ie(T.La.Qa,T.La.Qa)
              , p = new P.kd(c("c91f79cf2b58a966b724"),[T.La.Qa],[T.La.Qa]);
            return new P([],[],{},{},{},p,{},new P.ke("",p,h),{},new P.qa([T.La.Qa]),{},new P.qa([T.La.Qa]),{},new P.qa([T.La.Qa]),{},new P.qa([T.La.Qa]))
        }
        ,
        P.kk = function(h, p, _) {
            var g = new P.ie(T.La.Qa,T.La.Qa);
            return h = new P.kd(c("1be92f3df9b6c77445b2"),[h],[16777215]),
            new P([],[],{},{},{},h,{},new P.ke("",h,g),{},new P.qa([p]),{},new P.qa([_]),{},new P.qa([T.La.Qa]),{},new P.qa([T.La.Qa]))
        }
        ,
        P.qk = function(h, p, _, g) {
            var y = {};
            z.Ud(h[c("cc7e61f3bfd3564ab751")], function(ve, Ae) {
                y[ve] = c("3f557381") + Ae
            });
            for (var M, A, R = {}, I = 0; I < h[c("82e02ffce8563a6bebe208f4ed6b")].length; I++) {
                var U = h[c("307219ea5ac4047559703ee25ff9")][I];
                R[U[c("0bd569")]] = new P.kd(y[U[c("e5a615f104bf")]],U[c("b306d4d552")].map(function(ve) {
                    return p[ve]
                }),U[c("5a0c700229")].map(function(ve) {
                    return ve
                }))
            }
            I = new P.kd(16777215,[p[c("71d2")]],[16777215]),
            U = {};
            for ([M,A] of Object.entries(h[c("fc2847aa73952b3070")]))
                U[parseInt(M)] = new P.qa([p[A[0]]]);
            var H, Q, k = new P.qa([p[c("10d0")]]), Y = {};
            for ([H,Q] of Object.entries(h[c("84b8a922fc31b99fe5beba")]))
                Y[parseInt(H)] = new P.qa([p[Q[0]]]);
            var ae, oe, q = new P.qa([p[c("5574")]]), j = {};
            for ([ae,oe] of Object.entries(h[c("ce37f115a1a7fd86a2")]))
                j[parseInt(ae)] = new P.qa(ae === "0" ? [] : [p[oe[0]]]);
            var ue, pe, Ie = new P.qa([]), _t = {};
            for ([ue,pe] of Object.entries(h[c("f74f950b085f181dbb596206")]))
                _t[parseInt(ue)] = new P.qa(ue === "0" ? [] : [p[pe[0]]]);
            var Di = new P.qa([])
              , Br = {}
              , de = (z.Ud(h[c("8667276bfef223f3ca763355")], function(ve, Ae) {
                ve = parseInt(ve),
                Br[ve] = new P.ie(p[Ae[c("6695498a0f")]],p[Ae[c("7aec50e209")]])
            }),
            {})
              , Ee = (z.Ud(h[c("d606fa00b682e8949a06c305")], function(ve, Ae) {
                ve = parseInt(ve),
                de[ve] = new P.Pj(p[Ae[c("4fe230b1b6")]])
            }),
            {});
            return z.Ud(h[c("ec494bde9d855b2080")], function(ve, Ae) {
                ve = parseInt(ve),
                Ee[ve] = new P.ke(Ae[c("d4517fd3b4cc")],new P.kd(y[Ae[c("cdcd24e93f")][c("042534be65bc")]],null,Ae[c("ff436a1bed")][c("7026deac03")].map(function(dt) {
                    return p[dt]
                })),new P.ie(null,p[Ae[c("090ae44ef917602e")][c("7026deac03")]]))
            }),
            h = new P.ke({},I),
            new P(_,g,Br,de,R,I,Ee,h,U,k,Y,q,j,Ie,_t,Di)
        }
        ,
        P.prototype.pd = function(h) {
            return this.Di.hasOwnProperty(h) ? this.Di[h] : this.Tm
        }
        ,
        P.prototype.me = function(h) {
            return this.Mi.hasOwnProperty(h) ? this.Mi[h] : this.an
        }
        ,
        P.prototype.qh = function(h) {
            return this.vb.hasOwnProperty(h) ? this.vb[h] : this.qn
        }
        ,
        P.prototype.sh = function(h) {
            return this.Vi.hasOwnProperty(h) ? this.Vi[h] : this.Bn
        }
        ,
        P.prototype.wh = function(h) {
            return this.Ng.hasOwnProperty(h) ? this.Ng[h] : this.sj
        }
        ,
        P.prototype.Nf = function(h) {
            return this.Zi.hasOwnProperty(h) ? this.Zi[h] : this.ij
        }
        ,
        P.prototype.cl = function(h) {
            return this.xm[h]
        }
        ,
        P.prototype.Eh = function(h) {
            return this.Km[h]
        }
        ,
        P.ke = function(h, p) {
            this.Tf = p
        }
        ,
        P.kd = function(h, p, _) {
            this.Yf = h,
            this.Ja = p,
            this.Dd = _
        }
        ,
        P.qa = function(h) {
            this.Ja = h
        }
        ,
        P.ie = function(h, p) {
            this.Ja = h,
            this.Dd = p
        }
        ,
        P.Pj = function(h) {
            this.Ja = h
        }
        ,
        P),
        T.La = (C.prototype.init = async function() {
            var h = (await we.load(c("a37197d04e3548fdce2f88ac690153cbdf0dc1cf521b6698951bd8cc4f"))).source
              , p = (await we.load(c("1206e6637fcab9ce7f58f91f58c88cde551d945b41"))).source
              , _ = (this.Gl = new T.zb(c("9e59055dcdd00dc1df68095bc3d705c9d7"),h,0,0,128,128,350,100,220,220),
            this.dn = new T.zb(c("386f16ee44d21f6d297debe73d"),h,128,0,128,128,350,220,220,220),
            this.Bl = new T.zb(c("a7b5c87d45b95941ce82d84e5a904c"),h,256,0,128,128,148,63.5,128,128),
            this.Ug = new T.zb(c("1d6afab6fe6148bd4b49c0b4c66d"),p,0,0,32,32,0,0,0,0),
            (await we.load(c("76220a4f13e65dea1b7c6523c4f721f3ab7b2776e1b53cf3e9"))).source)
              , h = new T.zb(c("67fc0cbcb4f994bb1c"),_,0,0,42,80,75,64,128,128)
              , p = new T.zb(c("ef4494042c491a138340"),_,46,0,20,48,109,63,128,128)
              , _ = new T.zb(c("782ddfad23bed526ee0ea0b2f7b0"),_,46,52,64,64,0,0,0,0);
            h = T.lg.kk(_, h, p),
            this.$a = new T.Zh({},h),
            this.gc = this.bi = -1e4,
            (h = T.Ze.document.createElement(c("5042f3cd22c4e5"))).width = 80,
            h.height = 80,
            this.eg = {
                ic: h,
                ji: h.getContext(c("eac9c8"), {
                    willReadFrequently: !0
                }),
                Qd: new Z({
                    source: Xe.from(h)
                })
            },
            this.Zc = null,
            this.qg = []
        }
        ,
        C.Qa = T.zb.cg(),
        C.prototype.m = function() {}
        ,
        C.prototype.ti = function(h, p, _) {
            var g, y = this, M = this.$a.wi();
            this.bi === 1 ? h?.() : ((g = new T.Qm(M)).Um(function(A, R) {
                g === y.Zc && _ != null && _(A, R)
            }),
            g.Wm(function(A) {
                g === y.Zc && p != null && p(A)
            }),
            g.bn(function() {
                g === y.Zc && p != null && p(Error())
            }),
            g.rn(function(A) {
                if (g === y.Zc) {
                    y.gc = z.Pe(),
                    y.Zc = null,
                    y.$a.N().Nd(),
                    y.$a = A,
                    h?.();
                    for (let I of B["1ag"])
                        G.w.l.za(I, T.j.R) || (B["1ag"] = B["1ag"].filter(U => U !== I));
                    for (var R in B["1ah"])
                        if (B["1ah"][R])
                            for (let I of B["1ah"][R])
                                G.w.l.za(I, R) || (B["1ah"][R] = B["1ah"][R].filter(U => U !== I));
                    y.Gn()
                } else
                    try {
                        A.N().Nd()
                    } catch {}
            }),
            g.jj(),
            this.bi = 1,
            this.Zc = g)
        }
        ,
        C.prototype.hd = function() {
            return 0 < this.$a.wi()
        }
        ,
        C.prototype.mf = function(h) {
            this.qg.push(h)
        }
        ,
        C.prototype.Gn = function() {
            for (var h = 0; h < this.qg.length; h++)
                this.qg[h]()
        }
        ,
        C.prototype.N = function() {
            return this.$a.N()
        }
        ,
        C),
        T.Kj = (L.prototype.Cc = function(h) {
            return this.qf[h]
        }
        ,
        L.dk = (F.prototype.md = function(h, p) {
            for (var _ = 0; _ < this.cc.length; _++)
                if (this.cc[_].ih === h)
                    throw Error();
            return this.cc.push(new L.yk(h,p)),
            this
        }
        ,
        F.prototype.Gk = function() {
            for (var h = 0, p = 0; p < this.cc.length; p++)
                h += this.cc[p].ne;
            for (var p = {}, _ = 0, g = 0; g < this.cc.length; g++) {
                var y = this.cc[g];
                y.ne /= h,
                y.If = _,
                y.Kf = _ + y.ne,
                _ = y.Kf,
                p[y.ih] = y
            }
            return new L(p)
        }
        ,
        F),
        L.yk = (X.prototype.xh = function(h) {
            return this.If + (this.Kf - this.If) * h
        }
        ,
        X),
        L),
        T.Of = (ie.Hl = 797,
        ie.prototype.Ih = function(h, p, _) {
            var g = new o(p,_);
            return p.u.zIndex = .001 * (2 * (797 - h) + 1 + 3),
            _.u.zIndex = .001 * (2 * (797 - h) - 2 + 3),
            g
        }
        ,
        ie.prototype.Tc = function(h, p, _, g, y, M, A) {
            var R = _.Ja;
            if (h = (h === T.nc.Id ? p.Tf : _).Dd,
            0 < R.length && 0 < h.length)
                for (p = 0; p < this.i.length; p++)
                    this.i[p].I.qb(R[p % R.length]),
                    this.i[p].id.qb(G.w.o.Ug),
                    this.i[p].id.Od(h[p % h.length]);
            this.H.Tc(g, y, M, A)
        }
        ,
        ie.prototype.vi = function(h) {
            G.w.h.V.K.Wa = h;
            var p = G.w.o.N().pd(h);
            if (h = p.Ja,
            p = p.Dd,
            h.length && p.length)
                for (let _ = 0; _ < this.i.length; ++_)
                    this.i[_].I.qb(h[_ % h.length]),
                    this.i[_].id.qb(G.w.o.Ug),
                    this.i[_].id.Od(p[_ % p.length])
        }
        ,
        ie.prototype.Ol = function(h) {
            G.w.h.V.K.Sc = h,
            h = G.w.o.N().Nf(h),
            this.H.be(.004, this.H.Tb, h.Ja)
        }
        ,
        a = ( () => {
            class h extends Te {
                constructor() {
                    super(),
                    this.sortableChildren = !0,
                    this.rc = [],
                    this.sc = [],
                    this.tc = [],
                    this.Tb = [],
                    this.Vd = new Te,
                    this.Xd = [];
                    for (var _ = 0; _ < 4; _++) {
                        var g = new T.mb;
                        g.qb(G.w.o.Bl),
                        this.Vd.addChild(g.u),
                        this.Xd.push(g)
                    }
                    this.Vd.zIndex = .0011,
                    this.addChild(this.Vd),
                    this.Ei(),
                    this.Wb = new T.mb,
                    this.Wb.qb(G.w.o.Gl),
                    this.Wb.u.zIndex = .001,
                    this.E = new T.mb,
                    this.E.qb(G.w.o.dn),
                    this.E.u.zIndex = .001,
                    this.addChild(this.Wb.u),
                    this.addChild(this.E.u),
                    this.Ni()
                }
            }
            return h.prototype.Tc = function(p, _, g, y) {
                this.be(.002, this.rc, p.Ja),
                this.be(.003, this.sc, _.Ja),
                this.be(.004, this.Tb, y.Ja),
                this.be(.005, this.tc, g.Ja)
            }
            ,
            h.prototype.be = function(p, _, g) {
                for (; g.length > _.length; ) {
                    var y = new T.mb;
                    _.push(y),
                    this.addChild(y.u)
                }
                for (; g.length < _.length; )
                    _.pop().xc();
                for (y = 0; y < g.length; y++) {
                    p += 1e-4;
                    var M = _[y];
                    M.qb(g[y]),
                    M.u.zIndex = p
                }
            }
            ,
            h.prototype.ba = function(p, _, g, y) {
                for (this.visible = !0,
                this.position.set(p, _),
                this.rotation = y,
                p = 0; p < this.rc.length; p++)
                    this.rc[p].fb(g);
                for (p = 0; p < this.sc.length; p++)
                    this.sc[p].fb(g);
                for (p = 0; p < this.tc.length; p++)
                    this.tc[p].fb(g);
                for (p = 0; p < this.Tb.length; p++)
                    this.Tb[p].fb(g)
            }
            ,
            h.prototype.ja = function() {
                this.visible = !1
            }
            ,
            h.prototype.kj = function(p, _) {
                this.Vd.visible = !0,
                _ /= 1e3;
                for (var g = 1 / this.Xd.length, y = 0; y < this.Xd.length; y++) {
                    var M = 1 - (_ + g * y) % 1;
                    this.Xd[y].u.alpha = 1 - M,
                    this.Xd[y].fb(p * (.5 + 4.5 * M))
                }
            }
            ,
            h.prototype.Ei = function() {
                this.Vd.visible = !1
            }
            ,
            h.prototype.Vm = function(p) {
                B["1s"] === 1 && (this.E.u.visible = !0,
                this.E.fb(p))
            }
            ,
            h.prototype.Al = function() {
                this.E.u.visible = !1
            }
            ,
            h.prototype.qj = function(p, _, g) {
                this.Wb.u.visible = !0,
                this.Wb.u.alpha = z.Q(this.Wb.u.alpha, p.ge ? .9 : .2, g, .0025),
                this.Wb.fb(_)
            }
            ,
            h.prototype.Ni = function() {
                this.Wb.u.visible = !1
            }
            ,
            h
        }
        )(),
        ie.prototype.Ka = function(h) {
            return this.Mh + this.Oh * Math.sin(.3141592653589793 * h - this.Jg)
        }
        ,
        ie.prototype.zj = function(h, p, _, g) {
            var y = 2 * h.hb
              , M = h.Z
              , A = h.Ra
              , R = 4 * A - 3
              , I = (this.Jg = p / 400 * 3.141592653589793,
            this.Mh = 1.5 * y,
            this.Oh = .15 * y * h.rf,
            M[0])
              , U = M[1];
            g(I, U) ? (k = M[2],
            Y = M[3],
            ae = M[4],
            oe = M[5],
            H = Math.atan2(oe + 2 * U - 3 * Y, ae + 2 * I - 3 * k),
            this.H.ba(I, U, y, H),
            this.i[0].ba(I, U, y, this.Ka(0), H),
            this.i[1].ba(.64453125 * I + .45703125 * k + -.1015625 * ae, .64453125 * U + .45703125 * Y + -.1015625 * oe, y, this.Ka(1), o.Sa(this.i[0], this.i[2])),
            this.i[2].ba(.375 * I + .75 * k + -.125 * ae, .375 * U + .75 * Y + -.125 * oe, y, this.Ka(2), o.Sa(this.i[1], this.i[3])),
            this.i[3].ba(.15234375 * I + .94921875 * k + -.1015625 * ae, .15234375 * U + .94921875 * Y + -.1015625 * oe, y, this.Ka(3), o.Sa(this.i[2], this.i[4]))) : (this.H.ja(),
            this.i[0].ja(),
            this.i[1].ja(),
            this.i[2].ja(),
            this.i[3].ja());
            for (var H, Q, k, Y, ae, oe, q = 4, j = 2, ue = 2 * A - 4; j < ue; j += 2)
                g(I = M[j], U = M[j + 1]) ? (H = M[j - 2],
                Q = M[j - 1],
                k = M[j + 2],
                Y = M[j + 3],
                ae = M[j + 4],
                oe = M[j + 5],
                this.i[q].ba(I, U, y, this.Ka(q), o.Sa(this.i[q - 1], this.i[q + 1])),
                q++,
                this.i[q].ba(-.06640625 * H + .84375 * I + .2578125 * k + -.03515625 * ae, -.06640625 * Q + .84375 * U + .2578125 * Y + -.03515625 * oe, y, this.Ka(q), o.Sa(this.i[q - 1], this.i[q + 1])),
                q++,
                this.i[q].ba(-.0625 * H + .5625 * I + .5625 * k + -.0625 * ae, -.0625 * Q + .5625 * U + .5625 * Y + -.0625 * oe, y, this.Ka(q), o.Sa(this.i[q - 1], this.i[q + 1])),
                q++,
                this.i[q].ba(-.03515625 * H + .2578125 * I + .84375 * k + -.06640625 * ae, -.03515625 * Q + .2578125 * U + .84375 * Y + -.06640625 * oe, y, this.Ka(q), o.Sa(this.i[q - 1], this.i[q + 1]))) : (this.i[q].ja(),
                q++,
                this.i[q].ja(),
                q++,
                this.i[q].ja(),
                q++,
                this.i[q].ja()),
                q++;
            for (g(I = M[2 * A - 4], U = M[2 * A - 3]) ? (H = M[2 * A - 6],
            Q = M[2 * A - 5],
            k = M[2 * A - 2],
            Y = M[2 * A - 1],
            this.i[R - 5].ba(I, U, y, this.Ka(R - 5), o.Sa(this.i[R - 6], this.i[R - 4])),
            this.i[R - 4].ba(-.1015625 * H + .94921875 * I + .15234375 * k, -.1015625 * Q + .94921875 * U + .15234375 * Y, y, this.Ka(R - 4), o.Sa(this.i[R - 5], this.i[R - 3])),
            this.i[R - 3].ba(-.125 * H + .75 * I + .375 * k, -.125 * Q + .75 * U + .375 * Y, y, this.Ka(R - 3), o.Sa(this.i[R - 4], this.i[R - 2])),
            this.i[R - 2].ba(-.1015625 * H + .45703125 * I + .64453125 * k, -.1015625 * Q + .45703125 * U + .64453125 * Y, y, this.Ka(R - 2), o.Sa(this.i[R - 3], this.i[R - 1])),
            this.i[R - 1].ba(k, Y, y, this.Ka(R - 1), o.Sa(this.i[R - 2], this.i[R - 1]))) : (this.i[R - 5].ja(),
            this.i[R - 4].ja(),
            this.i[R - 3].ja(),
            this.i[R - 2].ja(),
            this.i[R - 1].ja()),
            this.P === 0 && 0 < R && this.Ea.addChild(this.H),
            0 < this.P && R == 0 && z.Ga(this.H); this.P < R; )
                this.Ea.addChild(this.i[this.P].I.u),
                this.Ea.addChild(this.i[this.P].id.u),
                this.P += 1;
            for (; this.P > R; )
                --this.P,
                this.i[this.P].id.xc(),
                this.i[this.P].I.xc();
            g = h.fa[T.Ec.rk],
            this.i[0].nd() && g != null && g.ua ? this.H.kj(y, p) : this.H.Ei(),
            p = h.fa[T.Ec.Bm],
            this.i[0].nd() && p != null && p.ua ? this.H.qj(h, y, _) : this.H.Ni(),
            h = h.fa[T.Ec.Fl],
            this.i[0].nd() && h != null && h.ua ? this.H.Vm(y) : this.H.Al()
        }
        ,
        te.prototype.ba = function(h, p, _, g, y) {
            this.I.Da(!0),
            this.I.pe(h, p),
            this.I.fb(_),
            this.I.yh(y),
            this.id.Da(!0),
            this.id.pe(h, p),
            this.id.fb(g),
            this.id.yh(y)
        }
        ,
        te.prototype.ja = function() {
            this.I.Da(!1),
            this.id.Da(!1)
        }
        ,
        te.prototype.nd = function() {
            return this.I.nd()
        }
        ,
        te.Sa = function(h, p) {
            return Math.atan2(h.I.u.position.y - p.I.u.position.y, h.I.u.position.x - p.I.u.position.x)
        }
        ,
        o = te,
        ie),
        T.Ec = (V.Bm = 0,
        V.Fl = 1,
        V.rk = 2,
        V.kl = 6,
        V),
        T.Zh = (T.lg.cg(),
        K.prototype.wi = function() {
            return this.Yb[c("67a8")]
        }
        ,
        K.prototype.N = function() {
            return this.vl
        }
        ,
        K),
        T.Qm = (W.uc = {
            ym: c("ee4fc8b1"),
            Cm: c("11b2eb75"),
            Lm: c("4182bb46"),
            Ci: c("f7188159"),
            Fi: c("779801de")
        },
        W.Pl = 1e5,
        W.Ii = new T.Kj.dk().md(W.uc.ym, 1).md(W.uc.Cm, 10).md(W.uc.Lm, 50).md(W.uc.Ci, 15).md(W.uc.Fi, 5).Gk(),
        W.prototype.rn = function(h) {
            this.$h = h
        }
        ,
        W.prototype.Wm = function(h) {
            this.di = h
        }
        ,
        W.prototype.bn = function(h) {
            this.fi = h
        }
        ,
        W.prototype.Um = function(h) {
            this.hi = h
        }
        ,
        W.prototype.pc = function() {
            return this.Sb
        }
        ,
        W.prototype.jj = function() {
            this.mi || (this.mi = !0,
            this.Pd ? this.bf() : this.Cn())
        }
        ,
        W.prototype.Cn = async function() {
            if (this.Pd)
                this.bf();
            else
                try {
                    var h = await fetch(c("c0b43055a97062fea9bc385dbe7869f6a3d5605afa5279d5b5d37347b04c"))
                      , p = JSON.parse(c(await h.text()));
                    this.Hn(p)
                } catch {
                    this.sn()
                }
        }
        ,
        W.prototype.Hn = function(h) {
            if (B["1e"])
                try {
                    if ((y = JSON.parse(B["1e"])) && y[c("fee9a9fd67")]) {
                        h[c("a92b")][c("df6795203c771025937784051973")] = y[c("d0c77b4fb1")];
                        for (var p = [], _ = Math.min(y[c("1ba07860")], 9), g = y[c("0115ef5bf2")].map(H => Math.min(Math.max(H, 0), 16777215)), y = 0; y < _; y++)
                            p.push(c("4541b38a96593e8f3951a25fa2293a6a0a") + (_ - 1 - y)),
                            h[c("8545")][c("de18d403bd90d1869218c5269990c593b1") + y] = {
                                [c("1a1b")]: c("caacf8af913ce512a68cf9baa408"),
                                [c("44a4")]: 128 * y,
                                [c("b437")]: 0,
                                [c("f8fa")]: 128,
                                [c("11b6")]: 128
                            };
                        h[c("5e9c4b980c325607078e6c90090f")].push({
                            [c("99637f")]: 19999,
                            [c("b95a4985504b")]: "0",
                            [c("ddac3ee304")]: p,
                            [c("7343190980")]: g,
                            [c("c421")]: 0,
                            [c("6246")]: 0
                        }),
                        h[c("36b493a0540c8e224bbf41a330327d112fb47c")].push({
                            [c("6e91516c17")]: c("ce1ce512a68cf9"),
                            [c("1885331868")]: [19999]
                        })
                    }
                } catch {}
            if (B["1j"])
                try {
                    var M, A = JSON.parse(B["1j"]);
                    A && A[c("29fcc230c8")] && (h[c("4fb1")][c("a0069681fb969304dc1687a4db988f0d")] = A[c("ee19d9ed97")],
                    h[c("20c2")][c("0581f3cad6997ecf7991e29fe66772b64a36")] = {
                        [c("f475")]: c("af97c5506c874055c387d4754c895c5c"),
                        [c("993b")]: A[c("c30c")],
                        [c("11b0")]: A[c("b15b")],
                        [c("f959")]: A[c("6046")],
                        [c("f95e")]: A[c("44fd")],
                        [c("1216")]: A[c("f0b14a")],
                        [c("680f")]: A[c("4061fb")],
                        [c("c581")]: 130,
                        [c("e16a")]: 130
                    },
                    M = A[c("41c6ba04a0")].toLowerCase(),
                    h[M + c("5eab499216")][c("8781b0c3")] = {
                        [c("20c1")]: c("23a35164f8bbdc695fb34041d885d0506cd4"),
                        [c("f6b3")]: 0
                    })
                } catch {}
            var R = this;
            if (this.Pd)
                this.bf();
            else {
                var I, U = [], p = [], _ = [];
                for (I in h[c("d5f7")])
                    h[c("66c6")].hasOwnProperty(I) && (g = h[c("9616")][I],
                    A = new W.lj(I,g,1,1),
                    U.push(A),
                    p.push(A),
                    _.push(g),
                    we.add({
                        [c("7828d6a21dbe")]: g,
                        [c("b6340a2a")]: g
                    }));
                we.load(_, function(k) {
                    var Y = W.uc.Ci;
                    R.Si(Y, W.Ii.Cc(Y).xh(+k))
                }).then(k => {
                    U.forEach(function(Y) {
                        Y.texture = k[Y.Ej]
                    }),
                    R.Aj(h, U)
                }
                )
            }
        }
        ,
        W.prototype.Aj = function(h, p) {
            var _, g, y, M = this;
            this.Pd ? this.bf() : (g = {},
            y = 0,
            (function A() {
                y < p.length ? (_ = p[y++],
                g[_.G] = new T.Qj(_.texture,_.texture.source),
                A()) : qt(function() {
                    return M.Xj(h, g)
                }, 0)
            }
            )())
        }
        ,
        W.prototype.Xj = function(h, p) {
            var _ = this
              , g = {}
              , y = 0
              , M = Object.values(h[c("8e2c")]).length
              , A = (z.Ud(h[c("46e4")], function(U, H) {
                H = T.zb.fm(H[c("f5d6")] + c("e1775055") + U, p[H[c("ff00")]].Qd, H),
                g[U] = H,
                ++y % 10 == 0 && (U = W.uc.Fi,
                _.Si(U, W.Ii.Cc(U).xh(y / M)))
            }),
            Object.values(p).map(function(U) {
                return U.Qd
            }))
              , R = Object.values(g)
              , I = new T.Zh(h,T.lg.qk(h, g, A, R));
            qt(function() {
                return _.ek(I)
            }, 0)
        }
        ,
        W.lj = function(h, p) {
            this.G = h,
            this.Ej = p
        }
        ,
        W.prototype.ek = function(h) {
            var p;
            this.Sb ? h.N().Nd() : (this.Sb = !0,
            p = this,
            qt(function() {
                return p.$h(h)
            }, 0))
        }
        ,
        W.prototype.sn = function() {
            var h, p = Error();
            this.Sb || (this.Sb = !0,
            h = this,
            qt(function() {
                return h.di(p)
            }, 0))
        }
        ,
        W.prototype.bf = function() {
            var h;
            this.Sb || (this.Sb = !0,
            h = this,
            qt(function() {
                return h.fi()
            }, 0))
        }
        ,
        W.prototype.Si = function(h, p) {
            var _;
            this.Sb || this.Pd || (_ = this,
            qt(function() {
                return _.hi(h, p)
            }, 0))
        }
        ,
        W),
        T.Un = {},
        T.vk = (J.prototype.m = function() {}
        ,
        J),
        T.pa = (he.Yj = c("ea8cc1a28d10def2976dc05a85f3d9fd9f"),
        he.fk = c("735318398440961d245c110f8655732ded55e81374"),
        c("f3d398b91add0a8398f398801ed2ed9767"),
        c("1bbb7051ecb6d94d46ba4474cbbdcd"),
        he.zk = c("d1353e5b3227ba6d8627346838"),
        he.Hk = c("a323c8c949314af1c53dc0fb"),
        he.nh = c("8343e82974536014"),
        c("f5832ef91d9ca1c597992ce8b4a56de4349dcad7ffcf7ae95888fc87a1695dae2532fbfcc33b5280284ca89cea7d44a31275cea8f07149b06e5ffcb3e81555d373"),
        he.th = c("03c368a9f4d0e8886ed8"),
        he.ud = function(h, p) {
            try {
                window.localStorage.setItem(h, p)
            } catch {}
        }
        ,
        he.Pf = function(h) {
            try {
                return window.localStorage.getItem(h)
            } catch {
                return ""
            }
        }
        ,
        he),
        G.Xn = (l = [[-28.06744, 64.95936], [-10.59082, 72.91964], [14.11773, 81.39558], [36.51855, 81.51827], [32.82715, 71.01696], [31.64063, 69.41897], [29.41419, 68.43628], [30.64379, 67.47302], [29.88281, 66.76592], [30.73975, 65.50385], [30.73975, 64.47279], [31.48682, 63.49957], [32.18994, 62.83509], [28.47726, 60.25122], [28.76221, 59.26588], [28.03711, 58.60833], [28.38867, 57.53942], [28.83955, 56.2377], [31.24512, 55.87531], [31.61865, 55.34164], [31.92627, 54.3037], [33.50497, 53.26758], [32.73926, 52.85586], [32.23389, 52.4694], [34.05762, 52.44262], [34.98047, 51.79503], [35.99121, 50.88917], [36.67236, 50.38751], [37.74902, 50.51343], [40.78125, 49.62495], [40.47363, 47.70976], [38.62799, 46.92028], [37.53193, 46.55915], [36.72182, 44.46428], [39.68218, 43.19733], [40.1521, 43.74422], [43.52783, 43.03678], [45.30762, 42.73087], [46.99951, 41.98399], [47.26318, 40.73061], [44.20009, 40.86309], [45.35156, 39.57182], [45.43945, 36.73888], [35.64789, 35.26481], [33.13477, 33.65121], [21.47977, 33.92486], [12.16268, 34.32477], [11.82301, 37.34239], [6.09112, 38.28597], [-1.96037, 35.62069], [-4.82156, 35.60443], [-7.6498, 35.26589], [-16.45237, 37.44851], [-28.06744, 64.95936]],
        {
            Yn: function(h, p) {
                for (var _ = !1, g = l.length, y = 0, M = g - 1; y < g; M = y++)
                    l[y][1] > h != l[M][1] > h && p < (l[M][0] - l[y][0]) * (h - l[y][1]) / (l[M][1] - l[y][1]) + l[y][0] && (_ = !_);
                return _
            }
        }),
        T.ll = ( () => {
            function h(y, M) {
                var A = M ? (M = 1.3,
                15554111) : (M = 1.1,
                16044288);
                return new g(y,A,!0,.5,M,.5,.7)
            }
            function p(y, M, A) {
                return ((255 * y & 255) << 16) + ((255 * M & 255) << 8) + (255 * A & 255)
            }
            class _ extends Te {
                constructor() {
                    super(),
                    this.J = [],
                    this.Qc = 0
                }
            }
            _.prototype.ql = function(y) {
                var M, A;
                this.Qc += y,
                1 <= this.Qc && (A = Math.floor(this.Qc),
                this.Qc -= A,
                y = 0 < A ? "+" + Math.floor(A) : A < 0 ? "-" + Math.floor(A) : "0",
                M = Math.min(1.5, .5 + A / 600),
                A = A < 1 ? "0xFFFFFF" : A < 30 ? p(1 - (A = (A - 1) / 29) + .96 * A, 1 - A + .82 * A, 1 - A + 0 * A) : A < 300 ? p(.96 * (1 - (A = (A - 30) / 270)) + .93 * A, .82 * (1 - A) + .34 * A, 0 * (1 - A) + .25 * A) : A < 700 ? p(.93 * (1 - (A = (A - 300) / 400)) + .98 * A, .34 * (1 - A) + 0 * A, .25 * (1 - A) + .98 * A) : 16318713,
                y = new g(y,A,!0,.5,M,Math.random(),1 + .5 * Math.random()),
                this.addChild(y),
                this.J.push(y))
            }
            ,
            _.prototype.dj = function(y) {
                y ? (N.$g(N.at + 1),
                y = h(c("849d8316cc0a8294d8"), !0),
                this.addChild(y),
                this.J.push(y),
                (N.at % 10 ? (Jt[B["1c"]].pause(),
                Jt[B["1c"]]) : (ai[B["1ai"]].pause(),
                ai[B["1ai"]])).play()) : (N.dh(N.Ag + 1),
                y = h(c("a14546b8493395e8cd7545b90c"), !1),
                this.addChild(y),
                this.J.push(y))
            }
            ,
            _.prototype.Aa = function(y, M) {
                y = (A = G.w.g.v.C).da.width;
                for (var A = A.da.height, R = 0; R < this.J.length; ) {
                    var I = this.J[R];
                    I.ag += M / 2e3 * I.ch,
                    I.Uc += M / 2e3 * I.Vl,
                    I.alpha = .5 * Math.sin(3.141592653589793 * I.Uc),
                    I.scale.set(I.ag),
                    I.position.x = y * (.25 + .5 * I.$l),
                    I.position.y = I.am ? A * (1 - .5 * (1 + I.Uc)) : A * (1 - .5 * (0 + I.Uc)),
                    1 < I.Uc && (z.Ga(I),
                    this.J.splice(R, 1),
                    R--),
                    R++
                }
            }
            ;
            var g = class extends ke {
                constructor(y, M, A, R, I, U, H) {
                    super({
                        text: y,
                        style: {
                            fill: M,
                            fontFamily: "PTSans",
                            fontSize: 36
                        }
                    }),
                    this.anchor.set(.5),
                    this.am = A,
                    this.ag = R,
                    this.ch = I,
                    this.$l = U,
                    this.Uc = 0,
                    this.Vl = H
                }
            }
            ;
            return _
        }
        )(),
        T.Qj = function(h, p) {
            this.Qd = p
        }
        ,
        T.nc = {
            gi: 0,
            Id: 16
        },
        T.Xc = (je.Wd = 0,
        je.prototype.Ai = function() {
            return 1.02 * this.lh
        }
        ,
        je),
        T.Om = (re.prototype.init = async function(h) {
            var p = this;
            this.ic = h,
            this.da = (h = {
                [c("29f9ca32dbff5c")]: p.ic,
                [c("0f2270e1f823e7e962267dc9f420f2fc")]: 0,
                [c("c5d7290c20dba715accd")]: !0,
                [c("2566d5bdcf7f59b9437dca")]: c(B["1a"] ? "ee08d5e39573c1" : "6046c7d103d9")
            },
            await _o(h)),
            this.Ta = new Te,
            this.Ta[c("7032ddb100a4d42b1d0ad2a210a9cc2aee")] = !0,
            this.Ub = Math.floor(Math.random()),
            this.wc = this.Ji = 0,
            this.ef = 15,
            this.vh = .5,
            this.gf = 0,
            this.fd = new T.Dn,
            this.Gg = new Ze,
            this.ee = new Te,
            this.jd = new Te,
            this.jd[c("1575f8baed6b79a0784df7b9cd7651b14b")] = !0,
            this.he = new Te,
            this.Y = new Te,
            this.Y[c("81816cc67197e5d4ecb963d5619afda5ff")] = !0,
            this.Xa = new Te,
            this.t = new u,
            this.t.position.x = Nt.any ? 60 : 70 + this.t.F - 40,
            this.t.position.y = Nt.any ? 60 : 70 + this.t.F - 40,
            this.Ac = new d,
            this.oa = new f,
            this.ld = new T.ll,
            this.yb = new Fe,
            this.Ca = {
                x: 0,
                y: 0
            },
            this.Mg = this.Gh = 0,
            this.m()
        }
        ,
        re.prototype.m = function() {
            this.da.background.color = 0,
            this.fd.Pc[c("7198baca91830f")] = 10,
            this.Ta[c("2d7fcb84f24a5a8851")](this.fd.Pc),
            this.Gg[c("b9507282594bc7")] = 20,
            this.Ta[c("2a5a88596dd799ad56")](this.Gg),
            this.ee[c("949f9f09fc0ca2")] = 5e3,
            this.Ta[c("28980e1f6f15079354")](this.ee),
            this.jd[c("e9202272093b97")] = 5100,
            this.Ta[c("a97b4fb86e76c68cd5")](this.jd),
            this.he[c("1c17178144941a")] = 1e4,
            this.Ta[c("7020d6a737addf2b1c")](this.he),
            this.yb[c("2d6aca98c5574181")] = G.w.Fd.gh,
            this.yb[c("be2eee32aabcf6")][c("0eecb5d5")](.5),
            this.yb[c("cc6747f1b4c46a")] = 1,
            this.Y[c("de0ec415a19bcd9982")](this.yb),
            this.Xa[c("6a1a400d069e")] = .6,
            this.Xa[c("b8f3b365d86886")] = 2,
            this.Y[c("d769bd2e18643422bb")](this.Xa),
            this.ld[c("ddb416fe05b79b")] = 3,
            this.Y[c("4d5fab64922a3a6831")](this.ld),
            this.t[c("31c3df14ddc7")] = .8,
            this.t[c("7b5634009b5579")] = 4,
            this.Y[c("9000b687d78dbf0bfc")](this.t),
            this.Ac[c("12599d4b72c2a0")] = 5,
            this.Y[c("41d3a71086de2e142d")](this.Ac),
            this.oa[c("208b2b1d40101e")] = 6,
            Mr[c("5853d3c538c8e6")] = 6,
            this.Y[c("8838aebfcfb5a733f4")](this.oa),
            this.Y[c("9b2df9ea5c3848fec7")](Mr),
            N.Ad = new ke({
                [c("e3e080ae13")]: c("4020fa"),
                [c("9ad828d4f24a")]: {
                    [c("3ea96fbf361565382fbb71")]: c("5071c6f035cbe5"),
                    [c("22558b5b52e481c34f")]: 12,
                    [c("8e79394dfe")]: 16777215
                }
            }),
            N.Ad.position.x = this.t.F / 40 * 100,
            N.Ad.position.y = this.t.F / 40 * 90,
            Bs.position.x = 15,
            Bs.position.y = this.t.height + 25,
            Cr.position.x = 15,
            Nt.any ? (Bs.scale.set(.8, .8),
            Cr.scale.set(.8, .8),
            Cr.position.y = this.t.height + 150) : Cr.position.y = this.t.height + 175,
            this.Bd = new ke({
                [c("4a28782422ba")]: {
                    [c("baad13a3ca09e13cabbffd")]: c("29caff0fccf05c"),
                    [c("1245bb4b62f4b1d37f")]: 12,
                    [c("6057cbdf08")]: 16777215
                }
            }),
            this.Bd.anchor = 1,
            this.Y.addChild(this.Bd),
            this.Y.addChild(N.Ad),
            this.$ = new Ze,
            this.Y.addChild(this.$),
            this.Y.addChild(Bs),
            this.Y.addChild(Qt),
            this.Y.addChild(Cr),
            (async () => {
                function h() {
                    se.Re = !1,
                    se.wg = !1,
                    se.De = !1,
                    se.p = -1,
                    se.visible = !1,
                    ct.visible = !1,
                    (se.M.alpha = 1) === B["1f"] ? (se.S.texture = g[2].S,
                    se.M.texture = g[2].M,
                    se.S.alpha = g[2].Db) : B["1f"] === 2 ? (se.S.texture = g[4].S,
                    se.M.texture = g[2].M,
                    se.S.alpha = g[2].Db,
                    se.wg = !0,
                    se.De = !0,
                    se.position.x = 100,
                    se.position.y = _.offsetHeight - 100,
                    se.visible = !0,
                    se.M.alpha = 0,
                    ct.visible = !0,
                    ct.position.x = _.offsetWidth - 100,
                    ct.position.y = _.offsetHeight - 100) : B["1f"] === 3 ? (se.S.texture = g[4].S,
                    se.M.texture = g[2].M,
                    se.S.alpha = g[2].Db,
                    se.wg = !0,
                    se.De = !0,
                    se.position.x = _.offsetWidth - 100,
                    se.position.y = _.offsetHeight - 100,
                    se.visible = !0,
                    se.M.alpha = 0,
                    ct.visible = !0,
                    ct.position.x = 100,
                    ct.position.y = _.offsetHeight - 100) : B["1f"] === 4 ? (se.S.texture = g[0].S,
                    se.M.texture = g[0].M,
                    se.S.alpha = g[0].Db) : B["1f"] === 5 ? (se.S.texture = g[1].S,
                    se.M.texture = g[1].M,
                    se.S.alpha = g[1].Db) : (se.Re = !0,
                    se.visible = !1,
                    se.p = -1),
                    se.Me()
                }
                if (Nt.any) {
                    this.Y.addChild(Ir);
                    var p, _ = document.querySelector(c("819a77d969")), g = [{
                        S: await we.load(c("2d3b9da6dc4d518d594392daff47548e5442daaff0026d842b51")),
                        M: await we.load(c("9dab2d164cfdc13dc9f3026a6ff7c43ec4f24a3f00939d14dbc1")),
                        Db: 1
                    }, {
                        S: await we.load(c("ebb9df9802cf138b9fc1d0d431c5168892c098b14e82af826dd3")),
                        M: await we.load(c("4197f132a8d9251125dfee4e8bd320e238aeb6dbe4f579f837ad")),
                        Db: 1
                    }, {
                        S: this.da[c("289e0f15490f0f8b555517fb40f00462")](new Ze().circle(0, 0, 40).fill(16711680)),
                        M: this.da[c("21f5c63ac0e4462c4ccece24d9eb5d05")](new Ze().circle(0, 0, 20).fill(16711680)),
                        Db: .5
                    }, {
                        S: this.da[c("df77843c06660422824c8c221f691f3b")](new Ze().circle(0, 0, 40).fill(16711680)),
                        M: this.da[c("b145568a5054d69cdc7e5e94495bcd95")](new Ze().circle(0, 0, 20).fill(16711680)),
                        Db: .5,
                        position: [500, 500]
                    }, {
                        S: await we.load(c("499ff93aa0d12de93da7f6b693ab38ea30a6bed3e5e02ffe06")),
                        M: this.da[c("fbcb98801ac2e08666e0608ef3cdfb9f")](new Ze().circle(0, 0, 20).fill(16711680)),
                        Zn: !0,
                        Db: 1
                    }], y = (ct.visible = !1,
                    ct.texture = await we.load(c("5c88ac690d5ec0da08d083052e54c5d905d1cb60496fc2ad13")),
                    ct.anchor.set(.5),
                    ct[c("2bb95b7bc194fc4d5781")] = "static",
                    ct.alpha = .5,
                    ct.on(c("b8f99562d2799bfda4fe757d"), () => {
                        ct.alpha = 1,
                        N.Zf.rb = !0
                    }
                    ),
                    ct.on(c("31d2dc0ddbd2521a4cda"), () => {
                        ct.alpha = .5,
                        N.Zf.rb = !1
                    }
                    ),
                    this.Y.addChild(ct),
                    (se = new gw({
                        S: new Fe,
                        M: new Fe,
                        Fm: I => {
                            N.Zf.Gb = I.angle,
                            ht.position.x = .5 * _.offsetWidth + I.Wh * Math[c("1c0e319c")](I.angle),
                            ht.position.y = .5 * _.offsetHeight + I.Wh * Math[c("8caea731")](I.angle)
                        }
                    }))[c("11e7e521fbf25a277def")] = c("8022b6b2f0bca5"),
                    se.on(c("ea8bc394800bd5f3966cc36b"), I => {
                        se.De && (se.p = I.pointerId,
                        se.zi())
                    }
                    ),
                    se.position.x = 150,
                    se.position.y = 150,
                    se.p = -1,
                    this.Y.addChild(se),
                    {
                        eh: new Fe(await we.load(c("c91f79ba2051ad69bd2776361335b27cad23356b342db07ecf220d73"))),
                        $m: new Fe(await we.load(c("a054d0b5c99a841ec41ccfc9ea90811dd9ed816cc72b86e9df"))),
                        Jm: new Fe(await we.load(c("fc680c896dbe203a683063e54eb4253965312bb3719b37113a153880"))),
                        jn: new Fe(await we.load(c("2c585cb95d6e10ea58e053357e660ee44fe65b4c7434c0a22abbf6792f"))),
                        pn: new Fe(await we.load(c("7543c56e94051945110bda02471ce058ea0562167914ec"))),
                        An: new Fe(await we.load(c("a4d0d431c5168892c098cb4df6f2916b9a7598e0"))),
                        sm: new Fe(await we.load(c("245054b14596081240184bcd766c1de15de913665e6254fb52ea"))),
                        Ic: new Fe(await we.load(c("0236f6536bf8aaf0667ee92f48f2bfc37b4fb15773cbb7c87e05ac4379"))),
                        qm: new Fe(await we.load(c("df35d3140e7b073f8b7dcc682d71023c864c94011b451b01924a9809104b0f018a5e655cf35ae2"))),
                        un: new Fe(await we.load(c("580ca8ed31c2fc460c54878122c0c84d0756c7951cd3c9"))),
                        Lk: new Fe(await we.load(c("1be92f48f2bfc37b4fb10024e1a2c67546f25d70c8")))
                    }), M = (y.An.on("pointerdown", I => {
                        I.preventDefault(),
                        Ye.Vf()
                    }
                    ),
                    y.$m.on(c("042529be66ad2f29683239b1"), () => {
                        Ye.Gi()
                    }
                    ),
                    y.sm.on(c("4cede1763e55f7d130cae149"), () => {
                        Ye.bj()
                    }
                    ),
                    y.Ic.on(c("f1121c4d1b12925a9d050c42"), () => {
                        Ye.Ic()
                    }
                    ),
                    y.qm.on(c("91727cad7b72f2bafd656ca2"), () => {
                        Ye.Rg()
                    }
                    ),
                    y.un.on(c("e44549de86cd4f49885259d1"), () => {
                        Ti(N.Ib - B["1i"])
                    }
                    ),
                    y.Lk.on(c("799a94c5939a1ac2e59d74da"), () => {
                        Ti(N.Ib + B["1i"])
                    }
                    ),
                    y.eh.on(c("997a74a5737afaa2c57d54ba"), () => {
                        N.Fe = !N.Fe,
                        y.eh.alpha = N.Fe ? 1 : .3
                    }
                    ),
                    y.pn.on(c("dc5d71c68ec54741805a51d9"), () => {
                        G.w.g.v.C.oa.Ob = !G.w.g.v.C.oa.Ob,
                        G.w.g.v.C.Xa.visible = G.w.g.v.C.oa.Ob,
                        G.w.g.v.C.oa.Aa(G.w.g.v.C.oa.Cb)
                    }
                    ),
                    y.jn.on(c("6b6c023781549410174b0208"), () => {
                        N.gd = !N.gd
                    }
                    ),
                    y.Jm.on(c("dbfcb2a731e404a087fb92b8"), () => {
                        N.wd = !N.wd
                    }
                    ),
                    0);
                    for (p in y) {
                        var A = y[p];
                        A[c("5b7c323db664883d0d")].x = M,
                        A[c("ec5858da9eb57f2c9020")] = "static",
                        A[c("c8fa7f69bf727c")] = c("ea8bc394800bd5f3"),
                        A[c("a6560449c2da")] = .3,
                        Ii.addChild(A),
                        M += A.width + 10
                    }
                    Ii.position.y = 10,
                    this.Y.addChild(Ii),
                    ht.circle(0, 0, 5).stroke({
                        width: 2,
                        color: 16777215,
                        alpha: 1
                    }),
                    ht.x = 500,
                    ht.y = 100,
                    this.Y.addChild(ht);
                    var R = [await we.load(c("06b2fadf6774ae7462faf593544ebb477fcbbdf62b05ac4379")), await we.load(c("778d4bac96c39f8713d5a4c045d96a94eed4eca539927d90e8")), await we.load(c("2f4503e4de0bd7cf5b0d1c98fd01d2cc561c24edf15ab5d820")), await we.load(c("86327a5fe7f42ef4e27a7513d4ce3bc7ff4b3d76a8852cc3f9")), await we.load(c("baee4e8bd320e238aeb6a1e7803ae73ba3b7e982fd71e00fb5")), await we.load(c("912721827869f5a1f56f3efe5b63f0b2c87e468b1138d7b6ce"))];
                    Ji[c("26c38dc15e4e9e58")] = R[B["1f"]],
                    Ji[c("2f0547c7dd10f8c9530d")] = "static",
                    Ji[c("57eb2cb8a8e3af")] = c("7e7f2f78ece721e7"),
                    Ji.on(c("c627e730a4afe9afbb2f"), () => {
                        B["1f"] = (B["1f"] + 1) % R.length,
                        Ji[c("4227612d32a27abc")] = R[B["1f"]],
                        Se(),
                        h()
                    }
                    ),
                    this.Y.addChild(Ji),
                    h()
                }
            }
            )(),
            this.ea()
        }
        ,
        re.prototype.ea = function() {
            var h = z.e()
              , p = (_ = Zg(this.ic))[0]
              , _ = _[1];
            --this.da.view[c("44e1e36f3c6cf8fe")][c("d77bb63f296f38")][c("6e8f597917ef63ec127350")],
            this.da.resize(p, _, h),
            this.vh = Math.min(Math.min(p, _), .625 * Math.max(p, _)),
            this.yb[c("b8f99578d57997e0ae")][c("6841")] = p / 2,
            this.yb[c("69aa84ef84aa06cf1f")][c("b791")] = _ / 2,
            this.yb[c("00a62b37703d")] = p,
            this.yb[c("13ac706ff0a0ed")] = _,
            this.Ac[c("d8d97558b55977c08e")][c("da93")] = Nt.any ? 130 : 200,
            this.Ac[c("d293fb96bf13f106b4")][c("b2ba")] = Nt.any ? 50 : 10,
            Ir.nf || (Ir[c("5a1b731e379b499e0c")][c("9e57")] = p - 120,
            Ir[c("adee401358d6da0bdb")][c("c62e")] = _ - 210),
            Qt[c("f1121c571c129e4797")][c("ae47")] = p / 2,
            this.oa.nf || (this.oa[c("f59618db109e92c393")][c("fd96")] = p - 225,
            this.oa[c("cb0ca2cd26f438adbd")][c("bdd7")] = 1),
            Mr[c("ebec82ad06d4188d9d")][c("7b54")] = p - 10,
            Mr[c("5051fdd03dd1ff4836")][c("41cb")] = 300,
            Ii.nf || (Ii.position.x = p - 230 - Ii.width,
            Ji.x = Ii.position.x - 100)
        }
        ,
        re.prototype.Aa = function(h, p) {
            this.ef = 15,
            this.ee[c("aac909d0c1491502daaa18a1c42216")](),
            this.jd[c("8fb2f46f7cb27045ffa1f56e69a973")](),
            this.he[c("c46763faa7ef6f58a47462fba2c47c")](),
            this.Xa[c("7fc2e49f6cc260b5efd1e59e79d963")](),
            N.dg = () => {
                var g = So[B["1b"]];
                this.fd.wk(g || G.w.Fd.Af)
            }
            ,
            N.dg();
            var _ = this.Gg;
            _.clear(),
            _.circle(0, 0, h.lh),
            _.stroke({
                width: .2,
                color: N.Pb ? B["1g"] : 16711680,
                alpha: 1
            }),
            this.oa.Ob = p,
            this.Xa[c("f4335fb491ab562e")] = p
        }
        ,
        re.prototype.Ha = function(h, p) {
            if (!(this.da.width <= 5)) {
                var _ = G.w.h.V
                  , g = this.da.width
                  , y = this.da.height
                  , M = (this.ef = z.Q(this.ef, G.w.h.Jc, p, .002),
                this.vh / (this.ef * N.Ib))
                  , A = G.w.h.V.fa[T.Ec.kl]
                  , R = (this.gf = z.Hc(this.gf + p / 1e3 * (.1 * (A != null && A.ua ? 1 : 0) - this.gf), 0, 1),
                this.yb.alpha = this.gf,
                this.Ub += .01 * p,
                360 < this.Ub && (this.Ub %= 360),
                this.Ji = Math.sin(h / 1200 * 6.283185307179586),
                _ = _.vd(),
                this.Ca.x = z.Ah(this.Ca.x, _.jb, p),
                this.Ca.y = z.Ah(this.Ca.y, _.kb, p),
                y / M / 2);
                for (G.w.h.dl(this.Ca.x - 1.3 * (A = g / M / 2), this.Ca.x + 1.3 * A, this.Ca.y - 1.3 * R, this.Ca.y + 1.3 * R),
                this.fd.Aa(this.Ca.x, this.Ca.y, 2 * A, 2 * R),
                A = G.w.h.B.lh,
                this.Ta.scale.x = M,
                this.Ta.scale.y = M,
                this.Ta.position.x = g / 2 - this.Ca.x * M,
                this.Ta.position.y = y / 2 - this.Ca.y * M,
                A - 10 < (R = z.Sf(_.jb, _.kb)) ? (this.wc = z.Hc(1 + (R - A) / 10, 0, 1),
                R = z.gg(Math.floor((Math.atan2(Math.sin(6.283185307179586 * this.Ub / 360) * (1 - this.wc), Math.cos(6.283185307179586 * this.Ub / 360) * (1 - this.wc) + +this.wc) + 6.283185307179586) % 6.283185307179586 * 360 / 6.283185307179586), 1, .75 - .25 * this.wc),
                this.fd.Od(R[0], R[1], R[2], .1 + this.wc * (.5 + .5 * this.Ji) * .2)) : (this.wc = 0,
                R = z.gg(Math.floor(this.Ub), 1, .75),
                this.fd.Od(R[0], R[1], R[2], .1)),
                R = 0; R < this.Xa.children.length; R++) {
                    var I = this.Xa.children[R];
                    I.xd && (I.position.x = g / 2 - (this.Ca.x - I.xd.x) * M,
                    I.position.y = y / 2 - (this.Ca.y - I.xd.y) * M)
                }
                if (this.t.Bb.position.x = _.jb / A * this.t.F,
                this.t.Bb.position.y = _.kb / A * this.t.F,
                M = N.Qe[0],
                _ = N.Qe[1],
                M !== 0 ? (this.t.eb.visible = !0,
                this.t.eb.position.x = M / A * this.t.F,
                this.t.eb.position.y = _ / A * this.t.F) : this.t.eb.visible = !1,
                this.Ac.Cd(h),
                this.ld.Aa(h, p),
                this.$.clear(),
                N.wd && (h = this.Ta[c("d297fba2ba08fa08b6")]({
                    x: 0,
                    y: 0
                }),
                this.$.moveTo(.5 * g, .5 * y),
                this.$.lineTo(h.x, h.y),
                this.$.stroke({
                    width: 2,
                    color: 16737894,
                    alpha: .75
                })),
                g = performance.now(),
                N.pb && (y = N.pb.b,
                h = N.pb.c,
                p = N.pb.d,
                this.t.r.position.x = N.pb.a / h * this.t.F,
                this.t.r.position.y = y / h * this.t.F,
                p != 0) && 6e4 < g - p && (this.t.r[c("799c92df948c13d5")] = 0,
                N.pb = 0),
                100 < g - N.ph) {
                    N.ph = g,
                    N.bc = !N.bc;
                    for (var U of Object.values(N.k))
                        U.bc ? (U.clear(),
                        U.circle(0, 0, .06 * this.t.F),
                        U.stroke({
                            width: 2,
                            color: 0
                        }),
                        U.fill(N.bc ? 16711680 : 255)) : (U.clear(),
                        U.circle(0, 0, .06 * this.t.F),
                        U.stroke({
                            width: 2,
                            color: 0
                        }),
                        U.fill(U.Dm))
                }
                for (N.z && 55 <= g - this.Gh && (y = (U = G.w.g.v.Gb) + Math.PI / 360 * 9,
                G.w.g.v.Gb = Math.PI < y ? -U : y,
                this.Gh = g),
                N.gd && 2e3 <= g - this.Mg && (this.Mg = g,
                Ye.Vf()); 0 < Fs.length && Fs[0] <= g - 1e3; )
                    Fs.shift();
                Fs.push(g),
                Mr.Fk(),
                Qg = Fs.length,
                this.Bd.text = Qg.toString(),
                this.Bd.position.x = this.da.width - 2,
                this.Bd.position.y = this.da.height - 2,
                this.da.render({
                    container: this.Ta,
                    clear: !0
                }),
                this.da.render({
                    container: this.Y,
                    clear: !1
                })
            }
        }
        ,
        re.prototype.ej = function(h, p) {
            p.Na.I.u.zIndex = (h + 2147483648) / 4294967296 * 5e3,
            this.ee.addChild(p.Na.id.u),
            this.jd.addChild(p.Na.I.u)
        }
        ,
        re.prototype.Cl = function(h, p, _, g) {
            p.Ea.zIndex = G.w.h.B.bb ? 0 : 10 + (h + 32768) / 65536 * 5e3,
            this.he.addChild(p.Ea),
            h !== G.w.h.B.bb && (this.Xa.addChild(_),
            this.Xa.addChild(g))
        }
        ,
        u = class extends Ds {
            constructor() {
                super(),
                this.F = Nt.any ? 40 : 80,
                this.Gd = new Fe,
                this.Gd[c("2f015fc1db0bc7")][c("6fd31496")](.5),
                this.Gd[c("370955dad30d")] = .5,
                this.Gd[c("d614fb08b68e")] = this.F / 40,
                this.Bb = new Ze,
                this.Bb[c("5a1155033a8a58")] = 2,
                this.Bb[c("29fbc72cc5ff")] = .9,
                this.eb = new Ze,
                this.eb[c("61a8aafa81b31f")] = 2,
                this.eb[c("0759650ae35d")] = .9,
                this.r = new Ze,
                this.r[c("dbfab4bd36f20db7")] = 0,
                this.r[c("ab26e4f04b0549")] = 2,
                this.r[c("637509268f79")] = .9;
                var h = new Ze
                  , p = (N.fe = () => {
                    h.clear(),
                    h.circle(0, 0, this.F),
                    h.moveTo(0, -this.F),
                    h.lineTo(0, +this.F),
                    h.moveTo(-this.F, 0),
                    h.lineTo(+this.F, 0),
                    h.fill({
                        color: 0,
                        alpha: .4
                    }),
                    h.stroke({
                        width: 2,
                        color: N.Pb ? B["1g"] : 16711680
                    }),
                    this.Bb.clear(),
                    this.Bb.circle(0, 0, .08 * this.F),
                    this.Bb.stroke({
                        width: 2,
                        color: 0
                    }),
                    this.Bb.fill(N.Pb ? B["1g"] : 16711680),
                    this.eb.clear(),
                    this.eb.circle(0, 0, .08 * this.F),
                    this.eb.stroke({
                        width: 2,
                        color: 0
                    }),
                    this.eb.fill(16776960),
                    this.r.clear(),
                    this.r.moveTo(0, 0),
                    this.r.lineTo(.15 * this.F, .15 * this.F),
                    this.r.moveTo(0, .15 * this.F),
                    this.r.lineTo(.15 * this.F, 0),
                    this.r.stroke({
                        color: 16711680
                    })
                }
                ,
                N.fe(),
                new ke({
                    text: c("fec793"),
                    style: {
                        fontFamily: c("d11207573428a4"),
                        fontSize: 16,
                        fill: 16777215
                    }
                }))
                  , _ = (p.position.x = -35,
                p.position.y = this.F + 15,
                new ke({
                    text: c("f5ad3ee435"),
                    style: {
                        fontFamily: c("9dde4b0340fcd0"),
                        fontSize: 16,
                        fill: 16777215
                    }
                }));
                _.position.x = 10,
                _.position.y = this.F + 15;
                let g = new ke({
                    style: {
                        fontFamily: c("9f80f54142ba56"),
                        fontSize: 16,
                        fill: 16777215
                    }
                })
                  , y = (g.position.x = p.position.x + p.width / 2,
                g.position.y = this.F + 33,
                g.anchor.x = .5,
                new ke({
                    style: {
                        fontFamily: c("8e4f0472f3cd27"),
                        fontSize: 16,
                        fill: 16777215
                    }
                }));
                y.position.x = _.position.x + _.width / 2,
                y.position.y = this.F + 33,
                y.anchor.x = .5,
                N.dh = M => {
                    N.Ag = M,
                    y.text = N.Ag
                }
                ,
                N.$g = M => {
                    N.at = M,
                    g.text = N.at
                }
                ,
                (async () => {
                    var M = await we.load(c("1f7513d4ce3bc7ff4b3d0ca8ed3fc1f14c0b1fd2dd03"));
                    (M = new Fe(M))[c("5cdaf74b1459")] = 2.5 * this.F,
                    M[c("06ffadf06d73b8")] = 2.5 * this.F,
                    M[c("3d4fd193a95d31")][c("8fb3f476")](.5),
                    this[c("f58713cc3a8292c099")](M)
                }
                )(),
                this[c("59abbfe89ea636fc05")](h),
                this[c("11e3f720d6ee7e247d")](this.Gd),
                this[c("63750132a47080360f")](this.eb),
                this[c("ea9ac899ad17d9ed96")](this.r),
                this[c("af81d546708c5c4ad3")](this.Bb),
                this[c("f1031740360e9e449d")](_),
                this[c("8e7e3445d1cb3dc9f2")](p),
                this[c("e93b0f782e36864c95")](y),
                this[c("c799ad5e08942452ab")](g)
            }
        }
        ,
        d = ( () => {
            class h extends Te {
                constructor() {
                    super(),
                    this.lc = {}
                }
            }
            h.prototype.Cd = function(_) {
                for (var g in _ = .5 + .5 * Math.cos(_ / 1e3 / 1.6 * 6.283185307179586),
                this.lc) {
                    var g = this.lc[g]
                      , y = g.Vh;
                    g.alpha = 1 - y + y * _
                }
            }
            ;
            let p = [40, 40, 40, 120, 50, 25, 40];
            return h.prototype.Aa = function(_) {
                for (var g in this.lc)
                    _[g] != null && _[g].ua || (z.Ga(this.lc[g]),
                    delete this.lc[g]);
                for (var y in g = 0,
                _) {
                    var M, A, R = _[y];
                    if (R.ua) {
                        let I = this.lc[y];
                        I || (M = G.w.o.N().Eh(R.W).Ja,
                        I = new Te,
                        M = new Fe(M.hg()),
                        A = new ke({
                            text: "40",
                            style: {
                                fontFamily: "PTSans",
                                fontSize: 20,
                                fill: 16777215
                            }
                        }),
                        I.Vh = 0,
                        M.width = 40,
                        M.height = 40,
                        A.position.y = 40,
                        A.position.x = 20,
                        A.anchor.x = .5,
                        I.addChild(M),
                        I.addChild(A),
                        this.lc[y] = I,
                        this.addChild(I)),
                        I.getChildAt(1).text = Math.round((1 - R.ue) * p[R.W]),
                        I.Vh = R.ue,
                        I.position.x = g,
                        g += 40
                    }
                }
            }
            ,
            h
        }
        )(),
        f = ( () => {
            function h(g) {
                return new Intl.NumberFormat("en",{
                    notation: "compact",
                    compactDisplay: "short"
                }).format(g)
            }
            class p extends Ds {
                constructor() {
                    super(),
                    this.Ob = !0,
                    this.Ge = 12,
                    this.Ld = 9,
                    this.J = [];
                    for (var y = 0; y < 14; y++)
                        this.Md()
                }
            }
            p.prototype.Aa = function(g) {
                this.Cb = g;
                var y = G.w.h.B.qc === T.nc.Id
                  , M = 0
                  , A = 0;
                A >= this.J.length && this.Md(),
                this.J[A].Ie(1, "white"),
                this.J[A].Ke("", N.He || "Top " + B["1d"], `(${G.w.h.ki} online)`),
                this.J[A].position.y = M,
                M += this.Ge,
                A += 1,
                0 < g.Rd.length && (M += this.Ld);
                for (var R = 0; R < g.Rd.length; R++) {
                    var I = g.Rd[R]
                      , U = G.w.o.N().me(I.tm);
                    A >= this.J.length && this.Md(),
                    this.J[A].Ie(.8, U.Tf.Yf),
                    this.J[A].Ke("".concat(R + 1), "", "".concat(Math.floor(I.Kb))),
                    this.J[A].position.y = M,
                    M += this.Ge,
                    A += 1
                }
                for (0 < g.ad.length && (M += this.Ld),
                R = 0; R < Math.min(B["1d"], g.ad.length); R++) {
                    var H, I = g.ad[R], Q = (U = G.w.h.B.bb === I.xi) ? (H = "white",
                    G.w.h.V.K.Ab) : (Q = G.w.h.tb[I.xi]) != null ? (H = (y ? G.w.o.N().me(Q.K.qi).Tf : G.w.o.N().pd(Q.K.Wa)).Yf,
                    (Q = this.Ob ? Q.K.Ab : "---") || "No nickname") : (H = "gray",
                    "No nickname");
                    U && (M += this.Ld),
                    A >= this.J.length && this.Md(),
                    this.J[A].Ie(U ? 1 : .8, H),
                    this.J[A].Ke("".concat(R + 1), Q, "".concat(h(Math.floor(I.Kb)))),
                    this.J[A].position.y = M,
                    M += this.Ge,
                    A += 1,
                    U && (M += this.Ld)
                }
                for (G.w.h.$e > g.ad.length && (M += this.Ld,
                A >= this.J.length && this.Md(),
                this.J[A].Ie(1, "white"),
                this.J[A].Ke("".concat(G.w.h.$e), G.w.h.V.K.Ab, "".concat(h(Math.floor(G.w.h.V.Kb)))),
                this.J[A].position.y = M,
                A += 1); this.J.length > A; )
                    z.Ga(this.J.pop())
            }
            ,
            p.prototype.Md = function() {
                var g = new _;
                (g[c("272846e9c228c4f141")][c("ee06")] = 0) < this.J.length && (g[c("d45579d4b1dd7344b2")][c("6840")] = this.J[this.J.length - 1][c("6e8f5f721bf75dea18")][c("f913")] + this.Ge),
                this.J.push(g),
                this[c("8355e11244506016ef")](g)
            }
            ;
            var _ = ( () => {
                class g extends Te {
                    constructor() {
                        super(),
                        this.bd = new ke({
                            text: "",
                            style: {
                                fontFamily: "PTSans",
                                fontSize: 12,
                                fill: 16777215
                            }
                        }),
                        this.bd.anchor.x = 1,
                        this.bd.position.x = 30,
                        this.addChild(this.bd),
                        this.zc = new ke({
                            text: "",
                            style: {
                                fontFamily: "PTSans",
                                fontSize: 12,
                                fill: 16777215
                            }
                        }),
                        this.zc.anchor.x = 0,
                        this.zc.position.x = 35;
                        var M = new Te
                          , A = new Ze().rect(0, 0, 150, 20).fill();
                        M.mask = A,
                        M.addChild(A),
                        M.addChild(this.zc),
                        this.addChild(M),
                        this.dd = new ke({
                            text: "",
                            style: {
                                fontFamily: "PTSans",
                                fontSize: 12,
                                fill: 16777215
                            }
                        }),
                        this.dd.anchor.x = 1,
                        this.dd.position.x = 220,
                        this.addChild(this.dd)
                    }
                }
                return g.prototype.Ke = function(y, M, A) {
                    this.bd.text = y,
                    this.dd.text = A,
                    this.zc.text = M
                }
                ,
                g.prototype.Ie = function(y, M) {
                    this.bd.alpha = y,
                    this.bd.style.fill = M,
                    this.zc.alpha = y,
                    this.zc.style.fill = M,
                    this.dd.alpha = y,
                    this.dd.style.fill = M
                }
                ,
                g
            }
            )();
            return p
        }
        )(),
        re),
        T.vn = ( () => {
            function h(g) {
                this.h = g,
                this.hf = [],
                this.$i = 0
            }
            h.prototype.mj = function(g) {
                this.hf.push(new T.Nm(new T.Dg(g)))
            }
            ,
            h.prototype.Og = function() {
                this.hf = [],
                this.$i = 0
            }
            ,
            h.prototype.tj = function() {
                for (var g = 0; g < 10 && this.hf.length !== 0; g++) {
                    var y = this.hf.shift();
                    this.vj(y)
                }
            }
            ,
            h.prototype.vj = function(g) {
                switch (255 & g.n(0)) {
                case 0:
                    this.Bj(g);
                    break;
                case 1:
                    this.Fj(g);
                    break;
                case 2:
                    this.Lj(g);
                    break;
                case 3:
                    this.Rj(g);
                    break;
                case 4:
                    this.Zj(g);
                    break;
                case 5:
                    this.gk()
                }
            }
            ,
            h.prototype.Bj = function(g) {
                this.h.B.qc = g.n();
                var y = g.s()
                  , M = (this.h.B.bb = y,
                this.h.V.K.G = y,
                this.h.B.lh = g.f(),
                this.h.B.Se = g.f(),
                this.h.B.sg = g.f(),
                y = [],
                g.n());
                for (let A = 0; A < M; ++A) {
                    let R = g.q()
                      , I = g.jc()
                      , U = g.q()
                      , H = "";
                    for (let Q = 0; Q < U; ++Q)
                        H += String.fromCharCode(g.jc());
                    y.push([H, I, R])
                }
                Cr.Me(y),
                G.w.g.v.C.Aa(this.h.B, !0)
            }
            ;
            let p = [];
            h.prototype.Fj = function(g) {
                for (var y = this.$i++, M = g.s(), A = this.ib(g), R = 0; R < A; R++)
                    this.Ak(g);
                for (A = this.ib(g),
                R = 0; R < A; R++)
                    this.Ik(g);
                for (A = this.ib(g),
                R = 0; R < A; R++)
                    this.Mk(g);
                for (A = this.ib(g),
                R = 0; R < A; R++)
                    this.Qk(g);
                for (A = this.ib(g),
                R = 0; R < A; R++)
                    this.Vk(g);
                for (A = this.ib(g),
                R = 0; R < A; R++)
                    this.Xk(g);
                for (A = g.q(),
                R = 0; R < A; R++)
                    this.$k(g);
                for (A = this.ib(g),
                R = 0; R < A; R++)
                    this.el(g);
                for (var I, A = this.ib(g), R = {}, U = 0; U < A; ++U) {
                    var H = g.jc()
                      , Q = g.q()
                      , k = g.hj()
                      , Y = g.f()
                      , ae = g.f();
                    R[H] = [H, Q, k, Y, ae]
                }
                var oe = R;
                for (Ie of Object.keys(N.k).filter(Di => !(Di in oe)))
                    G.w.g.v.C.t.removeChild(N.k[Ie]),
                    delete N.k[Ie];
                for (I of Object.values(oe)) {
                    var q, j = I[0], ue = I[1], pe = I[2], Ie = I[3], _t = I[4];
                    N.k[j] || ((q = new Ze)[c("74bfff291c2cc2")] = 1,
                    q[c("fd8f13c0e993")] = .9,
                    q.clear(),
                    q.circle(0, 0, .06 * G.w.g.v.C.t.F),
                    q.stroke({
                        width: 2,
                        color: 0
                    }),
                    q.fill(pe),
                    q.Dm = pe,
                    q.bc = !1,
                    G.w.g.v.C.t.addChild(q),
                    N.k[j] = q),
                    j = N.k[j],
                    ue && !j.bc && (To.pause(),
                    To.play()),
                    j.bc = ue,
                    j.position.x = Ie / 500 * G.w.g.v.C.t.F,
                    j.position.y = _t / 500 * G.w.g.v.C.t.F
                }
                for (R = g.q(),
                A = [],
                U = 0; U < R; ++U)
                    H = g.jc(),
                    Q = g.jc(),
                    k = g.q(),
                    (Y = this.Jd(H)) && A.push([Y.K.Ab, Q, k, H]);
                e: if (A.length !== p.length)
                    R = !1;
                else {
                    for (R = A.length; R--; )
                        if (U = A[R],
                        H = p[R],
                        U[1] !== H[1] || U[4] !== H[4]) {
                            R = !1;
                            break e
                        }
                    R = !0
                }
                R || (p = A,
                Bs.Me(A)),
                0 < y && this.il(g),
                this.h.ml(y, M)
            }
            ,
            h.prototype.Qk = function(g) {
                var y = new T.ye.xe
                  , M = (y.G = g.s(),
                y.qi = this.h.B.qc === T.nc.Id ? g.n() : T.Xc.Wd,
                y.Wa = g.s(),
                y.Ae = g.s(),
                y.ce = g.s(),
                y.Ce = g.s(),
                y.Sc = g.s(),
                g.n())
                  , A = "";
                for (let U = 0; U < M; U++) {
                    var R = g.s();
                    A += String.fromCharCode(R)
                }
                if (B["1k"] && typeof N.zh == "object") {
                    g = A.match(/\b(\w+)\b/g);
                    let U = [];
                    if (g)
                        for (var I of g)
                            U.push(I.toLowerCase());
                    N.zh.some(H => U.includes(H)) && (A = "Censored")
                }
                y.Ab = A = A === "" ? "No nickname" : A,
                (this.h.B.bb === y.G ? this.h.V : (y.Wa === 19999 && (y.Wa = 35),
                y.Ae === 999 && (y.Ae = 0),
                y.ce === 999 && (y.ce = 0),
                y.Ce === 999 && (y.Ce = 0),
                y.Sc === 999 && (y.Sc = 0),
                (A = this.h.tb[y.G]) != null && A.Hd(),
                (A = new T.ye(this.h.B)).Xh(G.w.g.v.C),
                this.h.tb[y.G] = A)).Sh(y)
            }
            ,
            h.prototype.Vk = function(g) {
                var y, M = g.s(), A = !!(1 & (R = g.n())), R = !!(2 & R), I = 0;
                A && (I = g.s()),
                (g = this.Jd(M)) !== void 0 && (g.oc = !1,
                g.ab) && (y = this.Jd(M),
                A && y !== void 0 && y.ab ? I === this.h.B.bb ? (M = this.h.V.vd(),
                g = g.fg(M.jb, M.kb),
                Math.max(0, 1 - g.Le / (.5 * this.h.Jc)),
                g.Le < .5 * this.h.Jc && G.w.g.v.C.ld.dj(R)) : M === this.h.B.bb ? (N.pb = {
                    a: y.Z[0],
                    b: y.Z[1],
                    c: y.B.lh,
                    d: 0
                },
                G.w.g.v.C.t.r[c("e0c74b408d574ad2")] = 1) : (R = this.h.V.vd(),
                Math.max(0, 1 - g.fg(R.jb, R.kb).Le / (.5 * this.h.Jc))) : M === this.h.B.bb ? (N.pb = {
                    a: y.Z[0],
                    b: y.Z[1],
                    c: y.B.lh,
                    d: 0
                },
                G.w.g.v.C.t.r[c("c5c02e0b20d8a719")] = 1) : (R = this.h.V.vd(),
                Math.max(0, 1 - g.fg(R.jb, R.kb).Le / (.5 * this.h.Jc))))
            }
            ,
            h.prototype.el = function(g) {
                var y = (y = g.s()) === this.h.B.bb ? null : this.h.tb[y]
                  , M = !!(1 & (U = g.n()))
                  , A = (2 & U && (U = g.f(),
                y) && y.Ne(U),
                U = g.f(),
                g.f());
                if (y && y.oi(U, A, M),
                M = this.ib(g),
                y)
                    for (var R in y.fa)
                        (U = y.fa[R]) && (U.ua = !1);
                for (R = 0; R < M; R++) {
                    var I, U = g.n(), A = g.n();
                    y && (I = y.fa[U],
                    (I ||= y.fa[U] = new T.Ec(U)).ua = !0,
                    I.ue = Math.min(1, Math.max(0, A / 100)))
                }
            }
            ,
            h.prototype.il = function(g) {
                var y, M = this.h.V, A = 1 & (I = g.n()), R = 4 & I;
                for (y in 2 & I && (I = M.Kb,
                M.Ne(g.f()),
                0 < (I = M.Kb - I)) && G.w.g.v.C.ld.ql(I),
                R && (this.h.ui = g.f()),
                R = g.f(),
                I = g.f(),
                M.oi(R, I, A),
                N.Qe[0] = g.f(),
                N.Qe[1] = g.f(),
                A = this.ib(g),
                M.fa)
                    (R = M.fa[y]) && (R.ua = !1);
                for (y = 0; y < A; y++) {
                    var R = g.n()
                      , I = g.n()
                      , U = M.fa[R];
                    U || (U = new T.Ec(R),
                    M.fa[R] = U),
                    U.ua = !0,
                    U.ue = Math.min(1, Math.max(0, I / 100))
                }
                G.w.g.v.C.Ac.Aa(M.fa)
            }
            ,
            h.prototype.Xk = function(g) {
                var A = g.s()
                  , y = this.Jd(A)
                  , M = g.f()
                  , A = g.q();
                if (y)
                    y.Ne(M),
                    y.Em(function() {
                        return g.f()
                    }, A),
                    y.Da(!0);
                else
                    for (y = 0; y < A; y++)
                        g.f()
            }
            ,
            h.prototype.$k = function(g) {
                g = g.s(),
                (g = this.h.tb[g]) && g.oc && g.Da(!1)
            }
            ,
            h.prototype.Ak = function(g) {
                var y = new T.Bi.xe;
                y.G = g.sf(),
                y.qi = this.h.B.qc === T.nc.Id ? g.n() : T.Xc.Wd,
                y.vc = g.f(),
                y.Wa = g.q(),
                (g = this.h.Vb[y.G]) != null && g.Hd(),
                (g = new T.Bi(y,G.w.g.v.C)).Ki(this.Xm(y.G), this.en(y.G), !0),
                this.h.Vb[y.G] = g
            }
            ,
            h.prototype.Ik = function(g) {
                g = g.sf(),
                (g = this.h.Vb[g]) && (g.xg = 0,
                g.ed *= 1.5,
                g.Bg = !0)
            }
            ,
            h.prototype.Mk = function(g) {
                var y = g.sf();
                g = g.s(),
                (y = this.h.Vb[y]) && (y.xg = 0,
                y.ed *= .1,
                y.Bg = !0,
                g = this.Jd(g)) && g.ab && (this.h.B.bb,
                g = g.vd(),
                y.Ki(g.jb, g.kb, !1))
            }
            ;
            var _ = [34, 29, 26, 24, 22, 20, 18, 17, 15, 14, 13, 12, 11, 10, 9, 8, 8, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 20, 22, 24, 26, 29, 34];
            return h.prototype.Lj = function(g) {
                for (var y = G.w.o.eg.ji, M = y.getImageData(0, 0, 80, 80), A = _[0], R = 80 - A, I = 0, U = 0; U < 628; U++)
                    for (var H = g.n(), Q = 0; Q < 8; Q++) {
                        var k = 4 * (A + 80 * I);
                        (H >> Q & 1) != 0 ? (M.data[k] = 255,
                        M.data[1 + k] = 255,
                        M.data[2 + k] = 255,
                        M.data[3 + k] = 255) : M.data[3 + k] = 0,
                        ++A >= R && ++I < 80 && (R = 80 - (A = _[I]))
                    }
                y.putImageData(M, 0, 0),
                (g = G.w.g.v.C.t.Gd).texture = G.w.o.eg.Qd,
                g.texture.source.update()
            }
            ,
            h.prototype.Zj = function(g) {
                let y = g.jc()
                  , M = "";
                for (let A = 0; A < y; ++A)
                    M += String.fromCharCode(g.jc());
                Qt[c("fd9a1ac8f5")] = M,
                Qt[c("3eb969a22b316830")] = 1,
                Qt.Kh && clearTimeout(Qt.Kh),
                Qt.Kh = setTimeout( () => {
                    Qt[c("0580eecbe09867d9")] = 0
                }
                , 6e4)
            }
            ,
            h.prototype.gk = function() {
                this.h.En()
            }
            ,
            h.prototype.Rj = function(g) {
                this.h.ki = g.s(),
                this.h.$e = g.s();
                var y = new T.Hg;
                y.ad = [];
                for (var M = g.n(), A = 0; A < M; A++) {
                    var R = g.s()
                      , I = g.f();
                    y.ad.push(T.Hg.nj(R, I))
                }
                if (y.Rd = [],
                this.h.B.qc === T.nc.Id)
                    for (M = g.n(),
                    A = 0; A < M; A++)
                        R = g.n(),
                        I = g.f(),
                        y.Rd.push(T.Hg.rj(R, I));
                G.w.g.v.C.oa.Aa(y)
            }
            ,
            h.prototype.Jd = function(g) {
                return g === this.h.B.bb ? this.h.V : this.h.tb[g]
            }
            ,
            h.prototype.Xm = function(g) {
                return ((65535 & g) / 32768 - 1) * this.h.B.Ai()
            }
            ,
            h.prototype.en = function(g) {
                return ((g >> 16 & 65535) / 32768 - 1) * this.h.B.Ai()
            }
            ,
            h.prototype.ib = function(g) {
                var y, M, A = g.n();
                return (128 & A) == 0 ? A : (128 & (y = g.n())) == 0 ? y | A << 7 & 16256 : (128 & (M = g.n())) == 0 ? M | y << 7 & 16256 | A << 14 & 2080768 : (128 & (g = g.n())) == 0 ? g | M << 7 & 16256 | y << 14 & 2080768 | A << 21 & 266338304 : void 0
            }
            ,
            h
        }
        )(),
        T.$b = (ne.kf = function() {
            return new T.$b(null)
        }
        ,
        ne.ah = function(h) {
            return new T.$b(h)
        }
        ,
        ne.prototype.Cc = function() {
            return this.Vg
        }
        ,
        ne.prototype.pf = function() {
            return this.Vg != null
        }
        ,
        ne),
        T.Bi = (ei.prototype.Hd = function() {
            this.rd.Na.id.xc(),
            this.rd.Na.I.xc()
        }
        ,
        ei.prototype.Ki = function(h, p, _) {
            this.tf = h,
            this.vf = p,
            _ && (this.Dc = h,
            this.Gc = p)
        }
        ,
        ei.prototype.re = function(h, p) {
            h = Math.min(2.5, 1.5 * this.ed),
            this.le = z.Q(this.le, Math.min(.5, +this.ed), p, .0025),
            this.Df = z.Q(this.Df, h, p, .0025),
            this.Ma = z.Q(this.Ma, this.xg, p, .0025)
        }
        ,
        ei.prototype.ve = function(h, p, _) {
            this.Dc = z.Q(this.Dc, this.tf, p, .0025),
            this.Gc = z.Q(this.Gc, this.vf, p, .0025),
            this.rd.Aa(this, h, p, _)
        }
        ,
        ei.xe = function() {
            this.G = 0,
            this.qi = T.Xc.Wd,
            this.Wa = this.vc = 0
        }
        ,
        ei),
        T.Yk = (Re.prototype.Tc = function(h, p, _) {
            (h = _.Ja) != null && this.Na.I.qb(h),
            (_ = _.Dd) != null && this.Na.id.qb(_)
        }
        ,
        Re.prototype.Aa = function(h, p, _, g) {
            g(h.Dc, h.Gc) ? (p = h.Df * (1 + .3 * Math.cos(h.Rk + p / 200)),
            h.fh ? this.Na.ba(h.Dc, h.Gc, 2 * h.le * B["1q"], +h.Ma, 1.2 * p * B["1q"], .8 * h.Ma) : this.Na.ba(h.Dc, h.Gc, 2 * h.le * B["1p"], +h.Ma, 2 * p * B["1p"], .3 * h.Ma)) : this.Na.ja()
        }
        ,
        mt.prototype.ba = function(h, p, _, g, y, M) {
            this.I.Da(!0),
            this.I.pe(h, p),
            this.I.fb(_),
            this.I.Fa(g),
            this.id.Da(!0),
            this.id.pe(h, p),
            this.id.fb(y),
            this.id.Fa(M)
        }
        ,
        mt.prototype.ja = function() {
            this.I.Da(!1),
            this.id.Da(!1)
        }
        ,
        b = mt,
        Re),
        T.nl = (Qe.prototype.m = function() {}
        ,
        Qe.prototype.Oa = function(h) {
            switch (h) {
            case T.j.R:
                return this.ra;
            case T.j.sa:
                return this.lb;
            case T.j.va:
                return this.nb;
            case T.j.wa:
                return this.gb;
            case T.j.xa:
                return this.ob
            }
            return 0
        }
        ,
        Qe.prototype.ig = function() {
            return new T.kh(this.ra,this.lb,this.nb,this.gb,this.ob)
        }
        ,
        Qe.prototype.jg = function(h) {
            this.$f.push(h),
            this.sb()
        }
        ,
        Qe.prototype.pi = function() {
            if (!G.w.o.hd())
                return z.Yl();
            for (var h = [], p = G.w.o.$a.Yb[c("34f61d6e564808f95df43a662365")], _ = 0; _ < p.length; _++) {
                var g = p[_];
                this.za(g[c("64dcc2")], T.j.R) && h.push(g)
            }
            return h.length === 0 ? 0 : h[parseInt(h.length * Math.random())][c("7fd9e5")]
        }
        ,
        Qe.prototype.zm = function() {
            if (G.w.o.hd()) {
                var h = G.w.o.$a.Yb[c("9fa3ca7b4d955764c6a1ed7348a8")]
                  , p = It(h, this.ra);
                if (!(p < 0)) {
                    for (var _ = p + 1; _ < h.length; _++)
                        if (this.za(h[_][c("3ea664")], T.j.R))
                            return this.ra = h[_][c("57e13d")],
                            void this.sb();
                    for (_ = 0; _ < p; _++)
                        if (this.za(h[_][c("61bb87")], T.j.R)) {
                            this.ra = h[_][c("7ae258")],
                            this.sb();
                            break
                        }
                }
            }
        }
        ,
        Qe.prototype.ok = function() {
            if (G.w.o.hd) {
                var h = G.w.o.$a.Yb[c("b2b01facd8060a3bdbb238a4dd3b")]
                  , p = It(h, this.ra);
                if (!(p < 0)) {
                    for (var _ = p - 1; 0 <= _; _--)
                        if (this.za(h[_][c("72ea50")], T.j.R))
                            return this.ra = h[_][c("9c84ba")],
                            void this.sb();
                    for (_ = h.length - 1; p < _; _--)
                        if (this.za(h[_][c("5a0278")], T.j.R)) {
                            this.ra = h[_][c("0f2975")],
                            this.sb();
                            break
                        }
                }
            }
        }
        ,
        Qe.prototype.ia = function(h, p) {
            if (!G.w.o.hd() || this.za(h, p))
                switch (p) {
                case T.j.R:
                    this.ra !== h && (this.ra = h,
                    this.sb());
                    break;
                case T.j.sa:
                    this.lb !== h && (this.lb = h,
                    this.sb());
                    break;
                case T.j.va:
                    this.nb !== h && (this.nb = h,
                    this.sb());
                    break;
                case T.j.wa:
                    this.gb !== h && (this.gb = h,
                    this.sb());
                    break;
                case T.j.xa:
                    this.ob !== h && (this.ob = h,
                    this.sb())
                }
        }
        ,
        Qe.prototype.za = function(h, p) {
            var _ = this.Ye(h, p);
            return !!_ && (_.ff === 0 || _.ff === 1 || G.w.T.kn(h, p))
        }
        ,
        Qe.prototype.Ye = function(h, p) {
            if (!G.w.o.hd())
                return null;
            var _ = G.w.o.$a.Yb;
            if (p === T.j.R)
                return (h = It(_[c("bab817a4d00ef223a3aac0bca523")], h)) < 0 ? null : T.Wi.wn(_[c("0d8de4a9ff4361b6747fd3a1fa7e")][h]);
            var g = null;
            switch (p) {
            case T.j.sa:
                g = _[c("6e9a496401c75de602")][h];
                break;
            case T.j.va:
                g = _[c("dc4071da94d951778d5652")][h];
                break;
            case T.j.wa:
                g = _[c("fbc49c9a0cf4e89177")][h];
                break;
            case T.j.xa:
                g = _[c("d8ce764aaf5e7bdca4d84147")][h]
            }
            return g != null ? T.Wi.In(g) : null
        }
        ,
        Qe.prototype.sb = function() {
            for (var h = 0; h < this.$f.length; h++)
                this.$f[h]()
        }
        ,
        Qe),
        T.j = (gt.R = c("8ae827f4e06c"),
        gt.sa = c("cddb36e522"),
        gt.va = c("1ba1727bebb8d2"),
        gt.xa = c("4551ab99ba492e8f"),
        gt.wa = c("fa63dd798d"),
        gt),
        T.oj = (wi.prototype.init = async function() {
            for (var h in tr)
                we.add({
                    [c("5365392fb67b")]: h,
                    [c("6525957b")]: tr[h]
                });
            for (var p in So = await we.load(Object.keys(tr)))
                So[p].source.style[c("44f4e2733a7cf9e801f2ea7a")] = c("6043c7c301d4d2"),
                So[p].source[c("77c90c9e94eb98801ac2e08666f96c86ead9f989")] = !0;
            this.Af = await we.load(c("c351f7f0251f3a9ff93aafd910e434a4b2f1b9b279ff3ca8ab")),
            this.gh = await we.load(c("0470749161b42b3c692e6bed568d370d674b26897f")),
            this.Af.source.style[c("67f90dbe99f99ead22cf1587")] = c("7e7d2561e7f230"),
            this.Af.source[c("a335d0e2481f4cf4ce2eccea4a2d58d2de05c5d5")] = !0,
            this.gh.source.style[c("916377a06763e4bbd4657fa9")] = c("3231913553a68c"),
            (h = T.d.createElement(c("39c9da02cbcf4c"))).width = 80,
            h.height = 80,
            this.eg = {
                ic: h,
                ji: h[c("241203836b96040f49051a")](c("82a120"), {
                    willReadFrequently: !0
                }),
                Qd: new Z({
                    source: Xe.from(h)
                })
            }
        }
        ,
        wi.prototype.m = function(h) {
            function p() {
                --_ == 0 && h()
            }
            var _ = 4;
            p(),
            p(),
            p(),
            p()
        }
        ,
        wi),
        T.wj = (et.prototype.init = async function() {
            this.v = new T.Gj,
            await this.v.init(),
            this.Ba = new T.Mj,
            await this.Ba.init(),
            this.Sj = new T.$j,
            this.hk = new T.lk,
            this.tk = new T.xk,
            this.Bk = new T.Jk,
            this.Nk = new T.Sk,
            this.Wk = new T.Zk,
            this.sk = new T.al,
            this.Rf = new T.jl,
            await this.Rf.init(),
            T.ol(),
            this.Rc = new T.rl,
            await this.Rc.init(),
            this.Kg = new T.wl,
            this.Ed = new T.Jl,
            this.Cf = new T.Ql,
            this.Vc = new T.Wl,
            this.ci = new T.bm,
            this.gm = new T.jm,
            this.ya = []
        }
        ,
        et.prototype.m = function() {
            this.ya = [this.v, this.Ba, this.Sj, this.hk, this.tk, this.Bk, this.Nk, this.Wk, this.sk, this.Rf, this.Kg, this.Ed, this.Cf, this.Vc, this.ci, this.gm],
            G.w.g.Rc.m();
            for (var h = 0; h < this.ya.length; h++)
                this.ya[h].m()
        }
        ,
        et.prototype.Cd = function(h, p) {
            G.w.g.Rc.Ha();
            for (var _ = this.ya.length - 1; 0 <= _; _--)
                this.ya[_].Ha(h, p)
        }
        ,
        et.prototype.ea = function() {
            G.w.g.Rc.ea();
            for (var h = this.ya.length - 1; 0 <= h; h--)
                this.ya[h].ea()
        }
        ,
        et.prototype.ma = function(h) {
            e: {
                for (var p = this.ya, _ = 0; _ < p.length; _++)
                    if (p[_] === h) {
                        h = _;
                        break e
                    }
                h = -1
            }
            h < 0 || (this.ya[0].Sd(),
            p = this.ya,
            h !== 0 && (_ = p[h],
            z.Ml(p, h),
            p[0] = _),
            this.vm())
        }
        ,
        et.prototype.vm = function() {
            var h = this.ya[0];
            h.Ua(),
            h.X(),
            this.Li()
        }
        ,
        et.prototype.Ym = function() {
            return this.ya.length !== 0 && this.ya[0].W === T.cb.We && this.Ed.gn()
        }
        ,
        et.prototype.ln = function() {
            return this.ya.length === 0 ? null : this.ya[0]
        }
        ,
        et.prototype.Li = function() {
            this.Ym() && this.ma(this.Ed)
        }
        ,
        et),
        T.Hg = (Gt.nj = function(h, p) {
            return {
                xi: h,
                Kb: p
            }
        }
        ,
        Gt.rj = function(h, p) {
            return {
                tm: h,
                Kb: p
            }
        }
        ,
        Gt),
        T.tn = ( () => {
            function h() {
                var de = M.checked && R.checked && 3 <= A.value.length && N.df != 0;
                return I.disabled = !de,
                de
            }
            async function p() {
                if (h()) {
                    var de = new FormData;
                    de.append(c("ddbb2cf513bc82f980"), A.value),
                    de.append(c("df73870d17611738"), N.df),
                    N.df = 0,
                    h(),
                    fe(I, c("c2bfebb4a23ee63e")),
                    me(oe, c("6d3f8c54981416"));
                    try {
                        var Ee = await (await fetch(c("1d2bad96c0624af11750d5bdce7358a8486c8ad2f7") + N.Fg, {
                            [c("e45843c380d64e")]: c("1556d89bcd"),
                            [c("883ba5bff5")]: de
                        })).json()
                          , ve = Ee[c("81916cd060")];
                        if (ve === 200)
                            G.w.T.jf(Ee[c("54c1f75339")]);
                        else {
                            let Ae = c("0c0820b47e8e250d315766826a9b3519");
                            ve === 201 ? Ae = c("d0f46146a64b77cabd8c281bb55e3b9dd0c54358815b") : ve === 202 && (Ae = c("b44a98ebc1acc83b9939cee8adf06b7fea7669faedab3a7aaf7e61eabed56106e61577d5bd8c281bbd4172c097d446")),
                            fe(oe, c("bdcf5c0428c4a6")),
                            _e(oe, Ae),
                            tt[c("de1bd5038c80d09c8a12")][c("7d1c9a436406")](j)
                        }
                    } catch {
                        fe(oe, c("8cbcad2bf917b7")),
                        _e(oe, c("00842c386a3a31b92deb7a3e7e2f21ad")),
                        tt[c("b5d2421a57d9cf05d1cb")][c("f6f5ddfa9f7f")](j)
                    }
                    me(I, c("dbe0b2af3bf90fb5"))
                }
            }
            function _() {
                this.Cg = [],
                this.Eg = [],
                this.ka = !1,
                this.L = {},
                $(M, c("51a1bbe5bba132"), h),
                $(A, c("7fd9ef8276c0"), h),
                $(R, c("3a28942c50a865"), h),
                $(I, c("d92937653e25"), p)
            }
            let g = D(c("ff153341f040e0064057661de759"))
              , y = D(c("05d3b58bfa8e6ecc5f9be8a9e27676b6"))
              , M = D(c("b10701d74743d0bcdc58569f"))
              , A = D(c("d5e365bb2bafbcc2bca33a"))
              , R = D(c("786c88f80ea8d901e13ca781f1b9a324"))
              , I = D(c("0236f62664e3a6cb6f7ca56e7afaa2"))
              , U = D(c("3eea32e2327e6a342bb2"))
              , H = D(c("326d972d57a99fac17259d205be262a52c"))
              , Q = D(c("047074e478f4263e7a3822"))
              , k = (D(c("d2c6a6d6a00ee844bf93ec84ac0a")),
            D(c("2c585ccc402c19ea58e905")))
              , Y = D(c("afc583115d855843e387d24f55af525bd184"))
              , ae = D(c("302440b044a81e74"))
              , oe = D(c("649094041a5ccdfe1ecfc14d"))
              , q = D(c("a93f19ef5d33df8fd84c4797"))
              , j = null;
            c("a5f1523d5aee");
            var ue = c("a4929312db0d");
            function pe() {}
            _.mk = (pe.prototype.ak = async function(de) {
                try {
                    if (B["1ak"]) {
                        var Ee = await (await fetch(c("5b296f08be608877515209398071877f595a") + B["1ak"])).json()
                          , ve = Ee[c("d929346838")];
                        if (ve === 200)
                            return void G.w.T.jf(Ee[c("f58216dc18")]);
                        if (ve === 201)
                            return void fe(D(c("20df150909170799")), c("108e22067a"))
                    }
                } catch {}
                Hh[c("cddf2ce33eb7bdf0a6")][c("18803e")][c("44fce87e3c70ebf725e7eb")]({
                    [c("f6e4d4e09f65c85297eb")]: c("62421c4c5fc21fcc524a184f5cd2043644e852b00432513b11e250e447377777e0f92cf2f27c276ae4e97be8e47b7e40e2d3278bf148374ef6ce29defb5d035eccc701dbd2190b56c7"),
                    [c("899b7ec862a1fca5fd6770b0")]: !1,
                    [c("e0d2435f885747d483")]: de,
                    [c("7e7a3374ddf521f1e57a177fe5e913edfc703d51e6")]: !0,
                    [c("fa7ecf68a1e9a5f5617e9b7369e597fb7f6fb87260")]: !0
                }),
                Hh[c("f0a051209b3058b38b")][c("c5df23")][c("1093370d700024a56d9d2e0472")](D("#btnGoogle"), {
                    [c("24010e92459c")]: c("4550ae94a55f2fa32f52ae63ba"),
                    [c("ac8e8705d5")]: c("67f408a88cf9"),
                    [c("7afc55e90a67")]: c("79decb9c"),
                    [c("b6341028caae")]: c("a654014bc9d709")
                }),
                Hh[c("7aea5fee117a2e65f1")][c("dc447a")][c("6203561a0b875c")]()
            }
            ,
            new pe),
            _.prototype.m = function() {
                this.Ck()
            }
            ,
            _.prototype.Ef = function() {
                return this.ka ? this.L[c("272d5affd903c4fa")] : ""
            }
            ,
            _.prototype.oe = function() {
                return this.ka ? this.L[c("cb09bedb3dee30afb6")] : ""
            }
            ,
            _.prototype.bl = function() {
                return this.ka && this.L[c("a5ff541b46f4d839c3ea680947c7dd")]
            }
            ,
            _.prototype.we = function() {
                return this.ka ? this.L[c("aad803d4c04c")] : 0
            }
            ,
            _.prototype.Fh = function() {
                return this.ka ? this.L[c("e8d54f4d8951")] : 1
            }
            ,
            _.prototype.pl = function() {
                return this.ka ? this.L[c("5e9c4b980c2c4d11")] : 0
            }
            ,
            _.prototype.sl = function() {
                return this.ka ? this.L[c("ea9ed5989d20d9e5")] : 0
            }
            ,
            _.prototype.fj = function() {
                return this.ka ? this.L[c("00bc2d26703d19be6c")] : 0
            }
            ,
            _.prototype.xl = function() {
                return this.ka ? this.L[c("9c8ab20ed3028780fb9c82")] : 0
            }
            ,
            _.prototype.Dl = function() {
                return this.ka ? this.L[c("7821dbbf23a4da")] : 0
            }
            ,
            _.prototype.cm = function() {
                return this.ka ? this.L[c("cab9e9aeba00e314a095fd93b70b")] : 0
            }
            ,
            _.prototype.em = function() {
                return this.ka ? this.L[c("da83f98cba1cc81e9680")] : 0
            }
            ,
            _.prototype.km = function(de) {
                this.Cg.push(de),
                de()
            }
            ,
            _.prototype.kg = function(de) {
                this.Eg.push(de),
                de()
            }
            ,
            _.prototype.kn = function(de, Ee) {
                return !!(Ee = this.L[Ee]) && Ee.includes(de)
            }
            ,
            _.prototype.um = function(de) {
                var Ee = this
                  , ve = this.Ef()
                  , Ae = this.we()
                  , dt = this.Fh();
                this.mm(function() {
                    de?.()
                }, function(ki) {
                    Ee.L = ki,
                    Ee.Yg(),
                    Ee.tg(),
                    ki = Ee.Ef();
                    var r1 = Ee.we()
                      , Eo = Ee.Fh();
                    ve === ki && (1 < Eo && Eo !== dt && G.w.g.Ed.yi(new T.Mm(Eo)),
                    20 <= (ki = r1 - Ae)) && G.w.g.Ed.yi(new T.Pm(ki)),
                    de?.()
                })
            }
            ,
            _.prototype.mm = function(de, Ee) {
                (async () => {
                    try {
                        var ve = await (await fetch(c("81d731f26486ee9dbbbc67d36a97e1e5a344") + B["1ak"])).json()
                          , Ae = ve[c("8e7c3f45f7")];
                        Ae === 200 ? Ee(ve[c("c47167e3a9")]) : Ae === 201 && tt.location.reload()
                    } catch {
                        de()
                    }
                }
                )()
            }
            ,
            _.prototype.Rm = async function(de, Ee, ve, Ae) {
                try {
                    ((await fetch(c("2bf91f58ce90d80701a25753cec5c958549c585ccb89e40005") + B["1ak"] + c("8cf8fd19f905f7d0d0") + de + c("ee5a82b7867ac460d3b4fc") + Ee)).status === 200 ? Ae : ve)()
                } catch {
                    ve()
                }
            }
            ,
            _.prototype.mn = function(de) {
                let Ee = this;
                (async () => {
                    try {
                        var ve = await (await fetch(c("0a3efe5b6fefb9842065b34a79c0b4cc4547b34a77c1c58364") + de)).json()
                          , Ae = ve[c("31c1dc00d0")];
                        Ae === 200 ? Ee.jf(ve[c("a4918703c9")]) : Ae === 202 ? (me(g, c("819360c06c80e2")),
                        fe(y, c("0597e4cce08c6e")),
                        j = tt[c("9fa4d4604da7517fcbbd")][c("0261a17b62f2ba")](c("302440b040f004694b7d13e759a01d602e65e3fa2af0f4"), {
                            [c("0bcf648aeaabf47b")]: c("92932c91d7661968dbea1febd647194795f512cfc4440f0df0"),
                            [c("b8fa9371d9")]: c("cb1aa1db37e933aeb6"),
                            [c("fd8d1edced9062d76e")]: function(dt) {
                                N.df = dt,
                                h()
                            }
                        })) : Ae === 201 && fe(D(c("730a021cda4a9804")), c("1d61efb5cf"))
                    } catch {
                        this.xn()
                    }
                }
                )()
            }
            ,
            _.prototype.xn = function() {
                G.w.g.ma(G.w.g.Vc)
            }
            ;
            let Ie = D(c("c11771c73642b59da8572e8e605da06ea5"))
              , _t = vo(D(c("d726aa2f297a383cf27995370e")), !0)
              , Di = vo(D(c("bb42ceda4d1520dfa606e8da2e1622")), !0)
              , Br = {
                [c("d5a322")]: D(c("b10701d74643c59edc58168948")),
                [c("b6260b")]: D(c("44b0b4243b7cf8ed29efa37e23")),
                [c("fee1a1")]: D(c("374d0b99c809cfd85a026cdca2")),
                [c("2baf4c")]: D(c("cc383caca3c46055b1573bd4b9"))
            };
            return _.prototype.Yg = function() {
                var de, Ee, ve, Ae = D(c("3f557381b51db59b220039d3b919")), dt = D(c("0ddbbdf3f07263"));
                N.Pb = this.L[c("5051e0c639cce34a")],
                N.Pb ? (fe(dt, c("f3d29c96")),
                _e(Ae, N.Pb)) : me(dt, c("a80f838b")),
                this.L[c("5847fbc639f2fd4e1255d1")] < 1 ? fe(H, c("8d1a663370e0ff21f1")) : me(H, c("7b48141d9e526d17e7")),
                _e(Y, this.L[c("0914ea51e8216c2163e6e0")]),
                _e(U, this.L[c("babe0fa8cc21e13ca7")]),
                _e(Q, this.L[c("1d62faa6c47e")]),
                _e(k, this.L[c("b0ea9b6fd876")]),
                _e(q, Math.floor(50 * this.L[c("ff5d600adc47e619755d")])),
                _e(ae, this.L[c("06ffadf86e68a4727aec")]),
                qg(Ie);
                for (de of Ae = this.L[c("f75b8d181e4d100b8d43")])
                    Ae = vo(Di, !0),
                    dt = D(c("500fe1d726c0f74a3d5bb7c231ca"), Ae),
                    Ae[c("c95239992b")] = de[0],
                    dt[c("042634b4")] = de[1],
                    Si(Ie, Ae);
                for (Ee of Object.values(Br))
                    qg(Ee);
                for (ve of de = this.L[c("97bbfc786da96f7d")]) {
                    de = vo(_t, !0),
                    Ee = D(c("51eca0e1a7b032fa74a9b2f8a4"), de),
                    Ae = D(c("f14c00410710925ad4091459131a"), de),
                    dt = D(c("928d27c0e4513d5bb7d93dc3f94a4d57cbdf08"), de);
                    let ki = ve[c("ea99")];
                    _e(Ee, ve[c("3f11")]),
                    _e(Ae, ve[c("4fe3")] + c("9a8e6e9dbb1d26149083578596")),
                    dt[c("bb1fc9d75315")][c("2d69c684c54a")] = ve[c("f101")] / 300 * 100 + c("4034b0a6"),
                    Si(Br[ve[c("e612")]], de),
                    $(de, c("d604f400b980"), () => {
                        wo(ki)
                    }
                    )
                }
                N.fe()
            }
            ,
            _.prototype.jf = function(de) {
                var Ee;
                D(c("b0a4c030dc6a9be2f5e89365")).hidden = !1,
                D(c("887cf8e8e4b2a33ad114a68b")).hidden = !0,
                me(D("body"), c("6537926c817707730e358a44")),
                N.bg = de[c("6cc8dd5a021edba7")],
                B["1ak"] = de[c("84a1a93ced37")],
                Se(),
                N.zg = !0,
                lt(D(c("483cb8a83cf1ef663553dbc7")), N.bg),
                Ee = this.ka ? this.L[c("b95f48894f71d694")] : ue,
                this.ka = !0,
                this.L = de,
                this.Yg(),
                Ee !== this.L[c("b2b607a0c418112d")] ? this.xj() : this.tg()
            }
            ,
            _.prototype.Ck = function() {
                var de = this;
                _.mk.ak(function(Ee) {
                    N.Fg = Ee[c("a97959b9497bc194d8435f")],
                    Se(),
                    de.mn(N.Fg)
                })
            }
            ,
            _.prototype.xj = function() {
                for (var de = 0; de < this.Cg.length; de++)
                    this.Cg[de]();
                this.tg()
            }
            ,
            _.prototype.tg = function() {
                for (var de = 0; de < this.Eg.length; de++)
                    this.Eg[de]()
            }
            ,
            _
        }
        )(),
        T.Gf = (Ne.prototype.init = async function(h) {
            var p = this;
            this.ic = h,
            this.da = (h = {
                [c("c317a4d831193a")]: p.ic,
                [c("6d3c8e439a05014b00089369951a134d")]: 0,
                [c("82e336f0e0723a7ce4f829")]: c(B["1a"] ? "3cfa1b6d2761f7" : "3eb865b3253f")
            },
            await _o(h)),
            this.ua = !0,
            this.Ya = new T.Hj(new Float32Array(3 * m)),
            this.od = this.Fc = 1,
            this.Oc = this.Nc = this.Mc = this.Kc = this.hc = x.O,
            this.ea(),
            G.w.o.mf(function() {
                p.Ya.Uf()
            })
        }
        ,
        m = Math.min(100, T.Of.Hl),
        x = {
            O: c("dadbf099ee"),
            Qb: c("1c5d329b11"),
            Rb: c("3a7b90390c")
        },
        Ne.prototype.Yc = function(h) {
            this.ua = h
        }
        ,
        Ne.prototype.ea = function() {
            var h = z.e()
              , p = Zg(this.ic);
            this.Fc = p[0],
            this.od = p[1],
            this.da.resize(this.Fc, this.od, h),
            this.ic.width = h * this.Fc,
            this.ic.height = h * this.od,
            h = this.od / 4,
            this.Ya.Tj(h),
            h = z.Hc(2 * Math.floor(this.Fc / h) - 5, 1, m),
            this.Ya.Nj(h)
        }
        ,
        Ne.prototype.Ha = function() {
            if (this.ua && !N.af) {
                var h = z.Pe() / 200
                  , p = Math.sin(h);
                this.Ya.gj(this.yl(this.hc, p), this.El(this.hc, p)),
                this.Ya.Kl(this.Ee(this.Kc, p), this.Ee(this.Mc, p), this.Ee(this.Nc, p), this.Ee(this.Oc, p));
                for (var p = this.Ya.vc, _ = this.Ya.P, g = this.Ya.ec, y = this.Fc - .5 * (this.Fc - .5 * p * (_ - 1)), M = .5 * this.od, A = 0, R = 0, I = -1; I < _; I++) {
                    var U = I
                      , H = Math.cos(+U / 12 * 3.141592653589793 - h) * (1 - Math.pow(16, -1 * U / 12));
                    0 <= I && (g[3 * I] = y - .5 * p * U,
                    g[3 * I + 1] = M + .5 * p * H,
                    g[3 * I + 2] = Math.atan2(R - H, U - A)),
                    A = U,
                    R = H
                }
                this.Ya.Aa(),
                this.Ya.Sl(this.da)
            }
        }
        ,
        Ne.prototype.Nb = function(h) {
            this.Ya.Nb(h)
        }
        ,
        Ne.prototype.Xl = function(h) {
            this.hc = h ? x.Rb : x.Qb,
            this.Oc = this.Nc = this.Mc = this.Kc = x.O
        }
        ,
        Ne.prototype.dm = function(h) {
            this.hc = x.O,
            this.Kc = h ? x.Rb : x.Qb,
            this.Oc = this.Nc = this.Mc = x.O
        }
        ,
        Ne.prototype.hm = function(h) {
            this.Kc = this.hc = x.O,
            this.Mc = h ? x.Rb : x.Qb,
            this.Oc = this.Nc = x.O
        }
        ,
        Ne.prototype.lm = function(h) {
            this.Mc = this.Kc = this.hc = x.O,
            this.Nc = h ? x.Rb : x.Qb,
            this.Oc = x.O
        }
        ,
        Ne.prototype.rm = function(h) {
            this.Nc = this.Mc = this.Kc = this.hc = x.O,
            this.Oc = h ? x.Rb : x.Qb
        }
        ,
        Ne.prototype.yl = function(h, p) {
            switch (h) {
            case x.Qb:
                return .9 + .1 * p;
            case x.Rb:
                return .4 + .3 * p
            }
            return 1
        }
        ,
        Ne.prototype.El = function(h, p) {
            switch (h) {
            case x.Qb:
                return .6 + .5 * p;
            case x.Rb:
                return .3 + .3 * p
            }
            return 1
        }
        ,
        Ne.prototype.Ee = function(h, p) {
            switch (h) {
            case x.Qb:
                return .9 + .1 * p;
            case x.Rb:
                return .6 + .4 * p
            }
            return 1
        }
        ,
        Ne),
        T.Wi = (ti.wn = function(h) {
            return new ti(h[c("fc78")],h[c("eba8")])
        }
        ,
        ti.In = function(h) {
            return new ti(h[c("f95f")],h[c("b431")])
        }
        ,
        ti),
        T.Dn = (Bt.prototype.Od = function(h, p, _, g) {
            var y = this.yc.resources.uniforms.uniforms.uColorOverlay;
            y[0] = h,
            y[1] = p,
            y[2] = _,
            y[3] = g
        }
        ,
        Bt.prototype.wk = function(h) {
            this.yc.resources.uTexture = h.source,
            this.yc.resources.uSampler = h.source.style
        }
        ,
        Bt.prototype.Aa = function(h, p, _, g) {
            this.Pc.position.x = h,
            this.Pc.position.y = p,
            this.Pc.scale.x = _,
            this.Pc.scale.y = g;
            var y = this.yc.resources.uniforms.uniforms.uTextureScale;
            y[0] = .2520615384615385 * _,
            y[1] = .4357063736263738 * g,
            (_ = this.yc.resources.uniforms.uniforms.uTextureOffset)[0] = .2520615384615385 * h,
            _[1] = .4357063736263738 * p
        }
        ,
        Bt),
        T.mb = (it.prototype.qb = function(h) {
            this.u.texture = h.hg(),
            this.u.anchor.set(h.Nl, h.db),
            this.Oi = h.Ul,
            this.Qi = h.Zl
        }
        ,
        it.prototype.Od = function(h) {
            this.u.tint = h
        }
        ,
        it.prototype.fb = function(h) {
            this.u.width = h * this.Oi,
            this.u.height = h * this.Qi
        }
        ,
        it.prototype.yh = function(h) {
            this.u.rotation = h
        }
        ,
        it.prototype.pe = function(h, p) {
            this.u.position.set(h, p)
        }
        ,
        it.prototype.Da = function(h) {
            this.u.visible = h
        }
        ,
        it.prototype.nd = function() {
            return this.u.visible
        }
        ,
        it.prototype.Fa = function(h) {
            this.u.alpha = h
        }
        ,
        it.prototype.xc = function() {
            z.Ga(this.u)
        }
        ,
        it),
        T.ye = (ee.prototype.Hd = function() {
            this.ta != null && z.Ga(this.ta.Ea),
            this.ca != null && z.Ga(this.ca),
            this.U != null && z.Ga(this.U)
        }
        ,
        ee.prototype.Pg = function() {
            this.Ne(.25),
            this.K.Ab = "",
            this.oc = !0,
            this.fa = {},
            this.Da(!1)
        }
        ,
        ee.prototype.Sh = function(h) {
            this.K = h,
            this.Sg(this.ab)
        }
        ,
        ee.prototype.Da = function(h) {
            var p = this.ab;
            this.ab = h,
            this.Sg(p)
        }
        ,
        ee.prototype.Ne = function(h) {
            this.Kb = 50 * h;
            var p = h
              , _ = (h > this.B.Se && (p = Math.atan((h - this.B.Se) / this.B.sg) * this.B.sg + this.B.Se),
            p = Math.sqrt(4 * Math.pow(5 * p, .707106781186548) + 25),
            Math.min(200, Math.max(3, 5 * (p - 5) + 1)));
            if (h = this.Ra,
            this.hb = .025 * (5 + .9 * p),
            this.Ra = Math.floor(_),
            this.yg = _ - this.Ra,
            0 < h && h < this.Ra)
                for (var p = this.wb[2 * h - 2], _ = this.wb[2 * h - 1], g = this.Pa[2 * h - 2], y = this.Pa[2 * h - 1], M = this.Z[2 * h - 2], A = this.Z[2 * h - 1]; h < this.Ra; h++)
                    this.wb[2 * h] = p,
                    this.wb[2 * h + 1] = _,
                    this.Pa[2 * h] = g,
                    this.Pa[2 * h + 1] = y,
                    this.Z[2 * h] = M,
                    this.Z[2 * h + 1] = A
        }
        ,
        ee.prototype.Em = function(h, p) {
            for (this.Ra = p,
            p = 0; p < this.Ra; p++)
                this.wb[2 * p] = this.Pa[2 * p] = this.Z[2 * p] = h(),
                this.wb[2 * p + 1] = this.Pa[2 * p + 1] = this.Z[2 * p + 1] = h()
        }
        ,
        ee.prototype.oi = function(h, p, _) {
            for (this.ge = _,
            _ = 0; _ < this.Ra; _++)
                this.wb[2 * _] = this.Pa[2 * _],
                this.wb[2 * _ + 1] = this.Pa[2 * _ + 1];
            this.yj(h - this.Pa[0], p - this.Pa[1], this.Ra, this.Pa)
        }
        ,
        ee.prototype.yj = function(h, p, _, g) {
            var y = z.Sf(h, p);
            if (!(y <= 0)) {
                var M = g[0];
                g[0] += h,
                h = g[1],
                g[1] += p;
                for (var A = 1 - 2 * (p = this.hb / (this.hb + y)), R = 1, I = _ - 1; R < I; R++) {
                    var U = g[2 * R];
                    g[2 * R] = g[2 * R - 2] * A + (U + M) * p,
                    M = U,
                    g[2 * R + 1] = g[2 * R - 1] * A + ((U = g[2 * R + 1]) + h) * p,
                    h = U
                }
                p = this.yg * this.hb / (this.yg * this.hb + y),
                g[2 * _ - 2] = g[2 * _ - 4] * (A = 1 - 2 * p) + (g[2 * _ - 2] + M) * p,
                g[2 * _ - 1] = g[2 * _ - 3] * A + (g[2 * _ - 1] + h) * p
            }
        }
        ,
        ee.prototype.vd = function() {
            return {
                jb: this.Z[0],
                kb: this.Z[1]
            }
        }
        ,
        ee.prototype.fg = function(h, p) {
            for (var _ = 1e6, g = h, y = p, M = 0; M < this.Ra; M++) {
                var A = this.Z[2 * M]
                  , R = this.Z[2 * M + 1]
                  , I = z.Sf(h - A, p - R);
                I < _ && (_ = I,
                g = A,
                y = R)
            }
            return {
                jb: g,
                kb: y,
                Le: _
            }
        }
        ,
        ee.prototype.Xh = function(h) {
            this.Xi = h
        }
        ,
        ee.prototype.re = function(h, p) {
            this.Ma = z.Q(this.Ma, this.oc ? this.ge ? .9 + .1 * Math.cos(h / 400 * 3.141592653589793) : 1 : 0, p, .00125),
            this.rf = z.Q(this.rf, !this.oc || this.ge ? 1 : 0, p, .0025),
            this.ta != null && (this.ta.Ea.alpha = this.Ma),
            this.ca != null && (this.ca.alpha = this.Ma)
        }
        ,
        ee.prototype.ve = function(h, p, _, g) {
            if (this.ab && this.oc)
                for (var y = Math.pow(.11112, p / 95), M = 0; M < this.Ra; M++) {
                    var A = z.te(this.wb[2 * M + 1], this.Pa[2 * M + 1], _);
                    this.Z[2 * M] = z.te(z.te(this.wb[2 * M], this.Pa[2 * M], _), this.Z[2 * M], y),
                    this.Z[2 * M + 1] = z.te(A, this.Z[2 * M + 1], y)
                }
            if (this.ta != null && this.ab && this.ta.zj(this, h, p, g),
            this.ca != null && (this.ca.xd.x = this.Z[0],
            this.ca.xd.y = this.Z[1] - 3 * this.hb),
            this.U != null && B["1s"] === 2) {
                for (var R in this.U.x = this.ca.position.x,
                this.U.y = this.ca.position.y + 1,
                this.U.Cb)
                    this.fa[R] != null && this.fa[R].ua || (this.U.removeChild(this.U.Cb[R]),
                    delete this.U.Cb[R]);
                for (var I in h = 0,
                this.fa)
                    (p = this.fa[I]) && p.ua && (_ = this.U.Cb[I],
                    _ || (this.U.Cb[I] = new Fe(G.w.o.N().Eh(p.W).Ja.hg()),
                    _ = this.U.Cb[I],
                    _.width = 30,
                    _.height = 30,
                    this.U.addChild(_)),
                    _.x = h,
                    h += 35);
                this.U[c("9fa0c8644ca0")].x = .5 * this.U.width,
                this.U[c("32339d3359b3")].y = this.U.height
            }
        }
        ,
        ee.prototype.Sg = function(h) {
            this.ab ? h || this.Cj() : (this.ta != null && z.Ga(this.ta.Ea),
            this.ca != null && z.Ga(this.ca),
            this.U != null && z.Ga(this.U))
        }
        ,
        ee.prototype.Cj = function() {
            this.ta == null ? this.ta = new T.Of : z.Ga(this.ta.Ea),
            this.ta.Tc(G.w.h.B.qc, G.w.o.N().me(this.K.qi), G.w.o.N().pd(this.K.Wa), G.w.o.N().qh(this.K.Ae), G.w.o.N().sh(this.K.ce), G.w.o.N().wh(this.K.Ce), G.w.o.N().Nf(this.K.Sc)),
            this.ca == null ? (this.ca = new ke({
                text: "",
                style: {
                    fontFamily: "PTSans"
                }
            }),
            this.ca.xd = {
                x: 0,
                y: 0
            },
            this.ca.anchor.set(.5, 0)) : z.Ga(this.ca),
            this.U == null ? (this.U = new Te,
            this.U.Cb = {}) : z.Ga(this.U),
            this.ca.style.fontSize = B["1w"],
            G.w.o.N().pd(this.K.Wa),
            this.ca.style.fill = B["1v"],
            this.ca.text = this.K.Ab,
            this.Xi.Cl(this.K.G, this.ta, this.ca, this.U)
        }
        ,
        ee.xe = function() {
            this.G = 0,
            this.qi = T.Xc.Wd,
            this.Sc = this.Ce = this.ce = this.Ae = this.Wa = 0,
            this.Ab = ""
        }
        ,
        ee),
        T.kh = (xe.prototype.Oj = function(h) {
            return new xe(h,this.lb,this.nb,this.gb,this.ob)
        }
        ,
        xe.prototype.Uj = function(h) {
            return new xe(this.ra,h,this.nb,this.gb,this.ob)
        }
        ,
        xe.prototype.bk = function(h) {
            return new xe(this.ra,this.lb,h,this.gb,this.ob)
        }
        ,
        xe.prototype.ik = function(h) {
            return new xe(this.ra,this.lb,this.nb,h,this.ob)
        }
        ,
        xe.prototype.nk = function(h) {
            return new xe(this.ra,this.lb,this.nb,this.gb,h)
        }
        ,
        xe),
        T.Hj = (v = new T.kh(0,0,0,0,0),
        Me.prototype.Nj = function(h) {
            if (this.P = h,
            this.A.P !== h) {
                for (var p = h; p < this.A.i.length; p++)
                    this.A.i[p].ja();
                for (; this.A.P > h; )
                    --this.A.P,
                    (p = this.A.i[this.A.P]).id.xc(),
                    p.I.xc();
                for (; this.A.P < h; )
                    p = this.A.i[this.A.P],
                    this.A.P += 1,
                    this.A.Ea[c("b8e89e6fff6597e3a4")](p.I.u),
                    this.A.Ea[c("bdcf5b1402daaa18a1")](p.id.u),
                    p.I.Fa(this.Ff),
                    p.id.Fa(this.Hf);
                for (h = 0; h < this.A.H.rc.length; h++)
                    this.A.H.rc[h].Fa(this.Jf);
                for (h = 0; h < this.A.H.sc.length; h++)
                    this.A.H.sc[h].Fa(this.Lf);
                for (h = 0; h < this.A.H.Tb.length; h++)
                    this.A.H.Tb[h].Fa(this.Mf);
                for (h = 0; h < this.A.H.tc.length; h++)
                    this.A.H.tc[h].Fa(this.Qf)
            }
        }
        ,
        Me.prototype.Nb = function(h) {
            this.dc = h,
            c("398f895fdbc8591627d4"),
            this.Uf()
        }
        ,
        Me.prototype.uk = function() {
            this.dc = v,
            this.Uf()
        }
        ,
        Me.prototype.Uf = function() {
            this.A.Tc(T.nc.gi, null, G.w.o.N().pd(this.dc.ra), G.w.o.N().qh(this.dc.lb), G.w.o.N().sh(this.dc.nb), G.w.o.N().wh(this.dc.ob), G.w.o.N().Nf(this.dc.gb))
        }
        ,
        Me.prototype.Tj = function(h) {
            this.vc = h
        }
        ,
        Me.prototype.gj = function(h, p) {
            for (this.Ff = h,
            this.Hf = p,
            h = 0; h < this.P; h++)
                (p = this.A.i[h]).I.Fa(this.Ff),
                p.id.Fa(this.Hf)
        }
        ,
        Me.prototype.Kl = function(h, p, _, g) {
            for (this.Jf = h,
            this.Lf = p,
            this.Mf = _,
            this.Qf = g,
            h = 0; h < this.A.H.rc.length; h++)
                this.A.H.rc[h].Fa(this.Jf);
            for (h = 0; h < this.A.H.sc.length; h++)
                this.A.H.sc[h].Fa(this.Lf);
            for (h = 0; h < this.A.H.Tb.length; h++)
                this.A.H.Tb[h].Fa(this.Mf);
            for (h = 0; h < this.A.H.tc.length; h++)
                this.A.H.tc[h].Fa(this.Qf)
        }
        ,
        Me.prototype.Aa = function() {
            var h, p, _, g = 2 * this.vc, y = 2 * this.vc * 1.5;
            for (0 < this.P && (h = this.ec[0],
            p = this.ec[1],
            _ = this.ec[2],
            this.A.i[0].ba(h, p, g, y, _),
            this.A.H.ba(h, p, g, _)),
            h = 1; h < this.P; h++)
                this.A.i[h].ba(this.ec[3 * h], this.ec[3 * h + 1], g, y, this.ec[3 * h + 2])
        }
        ,
        Me.prototype.Sl = function(h) {
            h.render({
                container: this.A.Ea
            })
        }
        ,
        Me),
        T.ha = (ut.prototype.m = function() {}
        ,
        ut.prototype.Ua = function() {}
        ,
        ut.prototype.X = function() {}
        ,
        ut.prototype.Sd = function() {}
        ,
        ut.prototype.ea = function() {}
        ,
        ut.prototype.Ha = function() {}
        ,
        ut),
        T.Gj = ( () => {
            let h = D(c("95a3257b6ef0dc23ceed702244"))
              , p = D(c("e73ddb691c662a31bb4f81"))
              , _ = D(c("f381c7d505cd0a9f97d8d09e13d1f8df62d3649fe9"))
              , g = D(c("912721f76763e4bdf57e36af7260ebb9cf6746"))
              , y = D(c("6b395f6d88419c073c521014"))
              , M = D(c("08fc78686d2d3e"))
              , A = D(c("bd8b0d4336c8ee17a0d8331d3b97a713acda2af2"));
            var R = D(c("28dc58484b1c039a73601cf555f6"))
              , I = z.aa(T.ha, function() {
                T.ha.call(this, T.cb.mc);
                var H = this;
                $(_, c("36a494a05920"), () => {
                    Ye.Ic()
                }
                ),
                $(g, c("a2d008dcc55c"), async () => {
                    try {
                        var k = await (await fetch(c("bb498fe85e002897f132a9d92011279ff93a") + B["1ak"])).json()
                          , Y = k[c("df738e3606")];
                        if (Y === 200)
                            G.w.T.jf(k[c("36a399bd5b")]);
                        else if (Y === 201)
                            return void tt.location.reload()
                    } catch {}
                    G.w.g.ma(G.w.g.Ba),
                    me(y, c("34ea066256")),
                    me(A, c("fbcd9e9a16c6e4")),
                    me(M, c("74acd86a1f28d7ae"))
                }
                ),
                Ye.bj = () => {
                    N.z = !N.z
                }
                ,
                Ye.Vf = () => {
                    var k, Y = G.w.h.V, ae = B["1ag"];
                    ae.length && Y.ta && (k = ae.indexOf(Y.K.Wa),
                    Y.ta.vi(k === -1 ? ae[0] : ae[(k + 1) % ae.length]))
                }
                ,
                Ye.Uk = () => {
                    var k, Y = G.w.h.V, ae = B["1ah"][c("6b740c2a9c")];
                    ae && ae.length && (k = ae.indexOf(Y.K.Sc),
                    Y.ta.Ol(k === -1 ? ae[0] : ae[(k + 1) % ae.length]))
                }
                ,
                Ye.Ic = () => {
                    N.Ve && wo && wo(N.Ve, N.He)
                }
                ,
                Ye.Fn = () => {
                    Ti(1)
                }
                ,
                Ye.Rg = () => {
                    var k, Y;
                    N.Pb && (k = Object.keys(tr)).length && (Y = k.indexOf(B["1b"]),
                    B["1b"] = Y === -1 ? k[0] : k[(Y + 1) % k.length],
                    N.dg())
                }
                ,
                Ye.Gi = () => {
                    N.Pb && (N.zf = !0,
                    B["1af"]) && (To.pause(),
                    To.play())
                }
                ;
                let Q = [Ii, Ir];
                $(tt, c("da80f994ba00d71f"), k => {
                    k.target.type !== c("f0b5573b80") && k.code === c("d634e808b98e") && (H.rb = !0)
                }
                ),
                $(tt, c("dbe7b8b72ae0"), k => {
                    k.target.type !== c("d3f0b0be23") && ((k = k.code) === c("56ac7d900b") ? Ye.bj() : k === c("c61ced208c") ? Ye.Vf() : k === c("c9712e8505") ? Ye.Gi() : k === c("cc566be697") ? Ye.Uk() : k === c("20ba070a76") ? Ye.Ic() : k === c("3a00993464") ? Ye.Fn() : k === c("736f101fb4") ? Ye.Rg() : k === c("dd853ae92b") ? N.gd = !N.gd : k === c("b60c1d30f6") ? N.wd = !N.wd : k === c("17037cf3d5") ? (G.w.g.v.C.oa.Ob = !G.w.g.v.C.oa.Ob,
                    G.w.g.v.C.Xa.visible = G.w.g.v.C.oa.Ob,
                    G.w.g.v.C.oa.Aa(G.w.g.v.C.oa.Cb)) : k === c("9f9ed47f53b54157c3bc") ? Ti(N.Ib + B["1i"]) : k === c("0db0faade16377976064e3baf8696f") ? Ti(N.Ib - B["1i"]) : k === c("73770507944d") && (H.rb = !1))
                }
                ),
                R.addEventListener(c("e600c01c8f97"), k => {
                    N.zg && (k.deltaY < 0 ? Ti(N.Ib + B["1i"]) : Ti(N.Ib - B["1i"]))
                }
                , {
                    capture: !0,
                    passive: !0
                }),
                R.addEventListener(c("799e94d99e8612dff797"), function(k) {
                    var Y, ae;
                    k && B["1f"] === 0 && !N.z && (k = k.touches[0],
                    Y = .5 * R.offsetWidth,
                    ae = .5 * R.offsetHeight,
                    c("adeb410454c4da0ad0c2") != typeof k.clientX ? H.Gb = Math.atan2(k.clientY - ae, k.clientX - Y) : H.Gb = Math.atan2(k.pageY - ae, k.pageX - Y),
                    k = Math.min(Math.sqrt((Y - k.pageX) * (Y - k.pageX) + (ae - k.pageY) * (ae - k.pageY)), 110),
                    ht.position.x = Y + k * Math.cos(H.Gb),
                    ht.position.y = ae + k * Math.sin(H.Gb))
                }, {
                    capture: !0,
                    passive: !0
                }),
                R.addEventListener(c("0eebbfd4714ba75177d5ac"), function(k) {
                    k.preventDefault(),
                    B["1f"] !== 2 && B["1f"] !== 3 && k && (H.rb = 2 <= k.touches.length)
                }, !0),
                R.addEventListener(c("9c99b11ac319879dc0"), function(k) {
                    B["1f"] !== 2 && B["1f"] !== 3 && k && (H.rb = 2 <= k.touches.length)
                }, {
                    capture: !0,
                    passive: !0
                }),
                R.addEventListener(c("241809825b9c07145a18"), function(k) {
                    !k || N.z || k.shiftKey || (H.Gb = Math.atan2(k.clientY - .5 * R.offsetHeight, k.clientX - .5 * R.offsetWidth))
                }, !0),
                R.addEventListener(c("916f7cb16663f3a7ee64"), function() {
                    H.rb = !0
                }, !0),
                R.addEventListener(c("0a76a3687dfaa5d1"), function() {
                    H.rb = !1
                }, !0),
                R.addEventListener(c("8e6f3f48fcd731d7fb482e4c"), function(k) {
                    var Y, ae;
                    Or && k.pointerId === t1 ? (Or.nf = !0,
                    Or.parent[c("49cea430a2dd2eec")]({
                        x: k.clientX,
                        y: k.clientY
                    }, null, Or.position)) : Nt.any && (Zt && k.pointerId === zh && (Y = Zt.height / 2,
                    ae = Math.max(Y, Math.min(Zt.parent[c("6b6802128043900e")]({
                        x: k.clientX,
                        y: k.clientY
                    }).y, Zt.parent.height - Y)),
                    Zt.parent.Bh((Zt.parent.height - Zt.height - (ae - Y)) / (Zt.parent.height - Zt.height), 1)),
                    se.Re || k.pointerId !== se.p || se.Hm(k))
                }, {
                    capture: !0,
                    passive: !0
                }),
                R.addEventListener(c("71929ccd9b9212da0c9a"), function(k) {
                    Or = null,
                    Nt.any && (Zt = null,
                    zh = -1,
                    ht.p === k.pointerId && (ht.p = -1,
                    ht.alpha = .25),
                    se.Re || k.pointerId !== se.p || (se.visible = se.wg,
                    se.Gm(),
                    se.p = -1))
                }, {
                    capture: !0,
                    passive: !0
                }),
                Nt.any && (N.Zf = H,
                R.addEventListener(c("b0f19d6ada7193f5dce68d65"), function(k) {
                    if (ht.p === -1 && (ht.p = k.pointerId,
                    ht.alpha = 1),
                    !se.Re) {
                        for (var Y of Q)
                            if (k.clientX >= Y.x && k.clientX <= Y.x + Y.width && k.clientY >= Y.y && k.clientY <= Y.y + Y.height)
                                return;
                        se.De || se.p !== -1 || (se.p = k.pointerId,
                        se.x = k.clientX,
                        se.y = k.clientY,
                        se.visible = !0,
                        se.zi())
                    }
                }, {
                    capture: !0,
                    passive: !0
                }))
            })
              , U = (I.prototype.m = function() {}
            ,
            I.prototype.Ua = function() {
                var H = D(c("dba9effd38f10cb7ace280a4"))
                  , Q = D(c("f0e40070953546"))
                  , k = D(c("8b19bf4d783a3ce1f62ae1e3656575e5fa28f8fc"));
                me(Q, c("306801ae58ea176351671d")),
                me(k, c("0c3c2dab799737")),
                fe(Q, c("b30ddb8b500954cf")),
                this.na === U.Td && me(H, c("4a347c3820"))
            }
            ,
            I.prototype.Td = function() {
                return this.na = U.Td,
                this
            }
            ,
            I.prototype.Ue = function() {
                return qt( () => {
                    this.na === U.Ue && fe(y, c("fbc38d8b11"))
                }
                , 3e3),
                this.na = U.Ue,
                this
            }
            ,
            I.prototype.X = function() {
                this.rb = !1,
                this.C.ea()
            }
            ,
            I.prototype.ea = function() {
                this.C.ea()
            }
            ,
            I.prototype.Ha = function(H, Q) {
                this.C.Ha(H, Q)
            }
            ,
            I.prototype.Am = function(H, Q) {
                _e(h, H),
                0 <= Q && Q <= 10 ? fe(p, c("d608e80cb4")) : me(p, c("3f1f31d7ad")),
                _e(p, c("468347896f693c") + Q)
            }
            ,
            I.prototype.init = async function() {
                this.C = new T.Om,
                await this.C.init(R),
                this.na = U.Td,
                this.Gb = 0,
                this.rb = !1
            }
            ,
            {
                Td: 0,
                Ue: 1
            });
            return I
        }
        )(),
        T.Ql = ( () => {
            let h = D(c("350385dbce5052807b47d39c"))
              , p = D(c("f1474117021c9e44a9090f"))
              , _ = D(c("d2c6a6d6b717e8"))
              , g = D(c("95a3257b6ef0b62ff8e06b3553bfcf3bc4f2422a"))
              , y = z.aa(T.ha, function() {
                T.ha.call(this, T.cb.mc),
                this.vg = -1,
                this.Yd = ""
            });
            return y.prototype.m = function() {}
            ,
            y.prototype.Ua = function() {
                fe(_, c("1ba56e23f3bfc0764aba42")),
                fe(g, c("24140583418f0f"))
            }
            ,
            y.prototype.X = function() {}
            ,
            y.prototype.Sd = function() {}
            ,
            y.prototype.to = function(M, A) {
                this.Yd !== M && (this.Yd = M),
                M = z.Hc(Math.floor(100 * A), 0, 100),
                this.vg !== M && (h && (h[c("8ae838e4e27a")][c("c303acd23310")] = M + "%"),
                p) && (p[c("8e6b3559e6e03bcbe242365d")] = M + "%")
            }
            ,
            y
        }
        )(),
        T.Mj = ( () => {
            let h = D(c("f8ec08788b3757a346b82e3f"))
              , p = D(c("dba9effd28ea08beb3f791"))
              , _ = D(c("37464ed0d20090cc5e02"))
              , g = D(c("2692da8a4b4b9c"))
              , y = D(c("21b79167d2ec0a3b4cf4df39dfb3430f50c6d616"))
              , M = D(c("d0842010a74e7fc9f5d9684eaa007dce8ec74340"))
              , A = D(c("992473a3706bb2a3ca7b4da70878c2a0dd"))
              , R = D(c("7b02150192552c01e85deb052a487b1ffd"))
              , I = D(c("9a852cc1ff564d56c3de0198c44306"))
              , U = D(c("475d7b89bc06befd20e93fb1"));
            D(c("7b094f5d98516c17cc42e004"));
            var H = z.aa(T.ha, function() {
                T.ha.call(this, T.cb.We)
            });
            return H.prototype.init = async function() {
                this.vg = -1,
                this.Yd = "",
                this.cd = new T.Gf,
                await this.cd.init(M),
                $(M, c("65358b718a31"), () => {
                    G.w.T.ka && G.w.g.ma(G.w.g.Rf)
                }
                ),
                $(R, c("a2d008dcc55c"), () => {
                    G.w.l.ok()
                }
                ),
                $(A, c("5a0870043d84"), () => {
                    G.w.l.zm()
                }
                ),
                $(I, c("d280f88cb50c"), () => {
                    G.w.yn()
                }
                ),
                this.Jn()
            }
            ,
            H.prototype.m = function() {
                var Q = this;
                G.w.T.kg(function() {
                    G.w.T.ka ? (G.w.l.ia(G.w.T.pl(), T.j.R),
                    G.w.l.ia(G.w.T.sl(), T.j.sa),
                    G.w.l.ia(G.w.T.fj(), T.j.va),
                    G.w.l.ia(G.w.T.xl(), T.j.xa),
                    G.w.l.ia(G.w.T.Dl(), T.j.wa)) : (G.w.l.ia(G.w.pj(), T.j.R),
                    G.w.l.ia(0, T.j.sa),
                    G.w.l.ia(0, T.j.va),
                    G.w.l.ia(0, T.j.xa),
                    G.w.l.ia(0, T.j.wa))
                }),
                G.w.T.kg(function() {
                    _e(U, G.w.T.we())
                }),
                G.w.l.jg(function() {
                    Q.cd.Nb(G.w.l.ig())
                })
            }
            ,
            H.prototype.Ua = function() {}
            ,
            H.prototype.Tg = function() {
                me(y, c("916370b07c70f2")),
                me(g, c("0913f811e1116e2478ecf4")),
                _[c("5e9d459c0d0541")](),
                p[c("5e9d459c0d0541")]()
            }
            ,
            H.prototype.to = function(Q, k) {
                this.Yd !== Q && (this.Yd = Q),
                Q = z.Hc(Math.floor(100 * k), 0, 100),
                this.vg !== Q && (h && (h[c("ce2ce418be86")][c("36b091ad4e23")] = Q + "%"),
                p) && (p[c("c146268c3175a896bd5f2588")] = Q + "%")
            }
            ,
            H.prototype.X = function() {
                this.cd.Yc(!0)
            }
            ,
            H.prototype.Sd = function() {
                this.cd.Yc(!1)
            }
            ,
            H.prototype.ea = function() {
                this.cd.ea()
            }
            ,
            H.prototype.Ha = function() {
                this.cd.Ha()
            }
            ,
            H.prototype.oe = function() {
                return G.w.T.oe()
            }
            ,
            H.prototype.Zg = function() {
                return c("73652723b969")
            }
            ,
            H.prototype.Jn = function() {
                G.w.Qg()
            }
            ,
            H
        }
        )(),
        T.jm = ((He = z.aa(T.ha, function() {
            T.ha.call(this, T.cb.mc)
        })).prototype.m = function() {}
        ,
        He.prototype.Ua = function() {}
        ,
        He),
        T.wl = ((He = z.aa(T.ha, function() {
            T.ha.call(this, T.cb.mc)
        })).prototype.m = function() {}
        ,
        He.prototype.Ua = function() {}
        ,
        He.prototype.X = function() {}
        ,
        He),
        T.Jl = ((He = z.aa(T.ha, function() {
            T.ha.call(this, T.cb.mc),
            this.bh = [],
            this.Vj = null
        })).prototype.m = function() {}
        ,
        He.prototype.Ua = function() {}
        ,
        He.prototype.X = function() {}
        ,
        He.prototype.gn = function() {
            return this.Vj != null || 0 < this.bh.length
        }
        ,
        He.prototype.yi = function(h) {
            this.bh.push(h),
            qt(function() {
                G.w.g.Li()
            }, 0)
        }
        ,
        He),
        T.cb = {
            mc: 0,
            We: 1
        },
        T.ga = ((S = z.aa(T.ha, function(h) {
            T.ha.call(this, T.cb.We),
            this.Ab = h,
            this.Bf = []
        })).prototype.m = function() {
            S.parent.prototype.m.call(this),
            S.Kk || (S.Kk = !0,
            G.w.T.kg(function() {}))
        }
        ,
        S.prototype.Ua = function() {}
        ,
        S.prototype.zl = function() {
            var h = this
              , p = 2147483647 & z.Tl();
            return this.Bf.push(p),
            qt(function() {
                h.Ph(p)
            }, 5e3),
            new i1(this,p)
        }
        ,
        S.prototype.Ph = function(h) {
            (h = this.Bf.indexOf(h)) < 0 || this.Bf.splice(h, 1)
        }
        ,
        S),
        Vh.prototype.dp = function() {
            this.Ll.Ph(this.Rl)
        }
        ;
        var Ft, ir, Fi, rr, ks, Us, Gr, He, i1 = Vh;
        function Vh(h, p) {
            this.Ll = h,
            this.Rl = p
        }
        function Wh() {}
        T.xk = ((Ft = z.aa(T.ga, function() {
            T.ga.call(this, c("9307faef793b"), !1)
        })).prototype.m = function() {
            Ft.parent.prototype.m.call(this)
        }
        ,
        Ft.prototype.X = function() {}
        ,
        Ft),
        T.Jk = ((ir = z.aa(T.ga, function() {
            T.ga.call(this, c("b16e56855143c59b"), !0)
        })).prototype.m = function() {
            ir.parent.prototype.m.call(this)
        }
        ,
        ir.prototype.X = function() {}
        ,
        ir),
        T.Zk = ((Fi = z.aa(T.ga, function() {
            T.ga.call(this, c("f5aa18cf1084"), !1)
        })).prototype.m = function() {
            Fi.parent.prototype.m.call(this)
        }
        ,
        Fi.prototype.X = function() {}
        ,
        Fi),
        T.Sk = ((rr = z.aa(T.ga, function() {
            T.ga.call(this, c("1f0053fdc53dc9f3"), !0)
        })).prototype.m = function() {
            rr.parent.prototype.m.call(this)
        }
        ,
        rr.prototype.X = function() {}
        ,
        rr),
        T.al = ((ks = z.aa(T.ga, function() {
            T.ga.call(this, c("7535925c8d03154b0e"), !1)
        })).prototype.m = function() {
            ks.parent.prototype.m.call(this)
        }
        ,
        ks.prototype.X = function() {}
        ,
        ks),
        T.jl = ( () => {
            let h = D(c("f381c7d500d20ab990c593ad1edef79370"))
              , p = D(c("039137c5f0c2faa960d563bdeeb4e2"))
              , _ = D(c("34a044344f7309d857e4105f3274f4"))
              , g = D(c("d5e365bb2eb0a8dfb6a731de04aa97"))
              , y = D(c("6014908013cfd5640350c4f609c9cf"))
              , M = D(c("681c98881bc7dd6c1b28dc8f1ba6dd221c"))
              , A = D(c("9cc8ec5cd70b91a0cf9c8836cc1d"))
              , R = D(c("71c7c197829c04fb128395fe988310c6e4"))
              , I = D(c("4034b0a037feef79657bffe22efcfc"))
              , U = D(c("13e12735e0b2ea5970a5735eedb9c277"))
              , H = D(c("18cc68586b172dbc4b980c31510c"))
              , Q = 0;
            var k = z.aa(T.ga, function() {
                T.ga.call(this, c("20a2091a4a06"), !0)
            })
              , Y = (k.prototype.init = async function() {
                var oe = this;
                this.ae = this.Lb = null,
                this.ub = [],
                this.Hi = {},
                this.Ia = new T.Gf,
                await this.Ia.init(h),
                $(H, c("2f035dcbd00f"), () => {
                    oe.Zm()
                }
                ),
                $(_, c("e5b50bf10ab1"), () => {
                    oe.Lb.hn()
                }
                ),
                $(g, c("4a3860342db4"), () => {
                    oe.Lb.nn()
                }
                ),
                $(A, c("51a1bfedb6ad"), () => {
                    G.w.l.za(Q, T.j.R) && (me(A, c("07596a0ee24ae8")),
                    fe(R, c("97a9fa7e72ba78")),
                    B["1ag"].includes(Q) || B["1ag"].push(Q),
                    Se())
                }
                ),
                $(R, c("57eb35a3b8e7"), () => {
                    G.w.l.za(Q, T.j.R) && (B["1ag"] = B["1ag"].filter(q => q !== Q),
                    fe(A, c("a17340a04c60c2")),
                    me(R, c("37095aded21ad8")),
                    Se())
                }
                )
            }
            ,
            k.prototype.m = function() {
                k.parent.prototype.m.call(this);
                var oe = this;
                G.w.o.mf(function() {
                    var q = G.w.o.$a.Yb;
                    oe.ub = [];
                    for (var j = 0; j < q[c("39d9d005d3e94d1f34c28206b7d73e3c20d9bf")].length; j++)
                        oe.ub.push(new Y(oe,q[c("4d4da469bf05216b2036967aab2b2248342dab")][j]));
                    for (oe.Hi = {},
                    j = 0; j < q[c("189a3102722c2c9d4188261a4701")].length; j++) {
                        var ue = q[c("3ebc6bb82c12762727ae4cb0292f")][j];
                        oe.Hi[ue[c("dc447a")]] = ue
                    }
                    oe.Ui()
                }),
                this.Mb(!1),
                G.w.l.jg(function() {
                    oe.Mb(!1)
                })
            }
            ,
            k.prototype.X = function() {
                this.Ui(),
                this.Ia.Yc(!0)
            }
            ,
            k.prototype.Sd = function() {
                this.Ia.Yc(!1)
            }
            ,
            k.prototype.ea = function() {
                this.Ia.ea()
            }
            ,
            k.prototype.Ha = function() {
                this.Ia.Ha()
            }
            ,
            k.prototype.Ui = function() {
                if (this.Pk)
                    me(this.ae, c("6d3f8c54981416")),
                    fe(this.ub[0].Kd, c("8afa2fe9e76935")),
                    this.ae = this.ub[0].Kd;
                else {
                    this.Pk = !0;
                    for (var oe = 0; oe < this.ub.length; oe++) {
                        let Ie = this.ub[oe];
                        var q = Gi(c("0a79b9697af0be"))
                          , j = Ie.Zb[c("febd")];
                        j ? ((ue = Gi(c("df798c35"))).src = j,
                        Si(q, ue)) : _e(q, Ie.Zb.name),
                        fe(q, c("c303bfc56a0e2bcea5")),
                        $(q, c("fc2e52a663ba"), () => {
                            this.Ig(Ie)
                        }
                        ),
                        p.append(q),
                        Ie.Kd = q
                    }
                    if (0 < this.ub.length) {
                        for (oe = G.w.l.Oa(T.j.R),
                        q = 0; q < this.ub.length; q++)
                            for (var ue = (j = this.ub[q]).Zb.list, pe = 0; pe < ue.length; pe++)
                                if (ue[pe] === oe)
                                    return j.ac = pe,
                                    void this.Ig(j);
                        this.Ig(this.ub[0])
                    }
                }
            }
            ,
            k.prototype.Ig = function(oe) {
                this.Lb !== oe && (this.Lb = oe,
                this.ae && me(this.ae, c("ddaf3ce408a486")),
                this.Lb.Kd && (fe(this.Lb.Kd, c("7e6e2365ebe521")),
                this.ae = this.Lb.Kd),
                this.Mb(!0))
            }
            ,
            k.prototype.Wg = function() {
                return this.Lb == null ? T.$b.kf() : this.Lb.lf()
            }
            ,
            k.prototype.Zm = function() {
                var oe = this.Wg();
                oe.pf() && this.Ij(oe.Cc())
            }
            ,
            k.prototype.Ij = function(oe) {
                var q = G.w.l.Ye(oe, T.j.R);
                if (q != null && (q = q.pt,
                !(G.w.T.we() < q))) {
                    let ue = G.w.l.Oa(T.j.R)
                      , pe = G.w.l.Oa(T.j.sa)
                      , Ie = G.w.l.Oa(T.j.va)
                      , _t = G.w.l.Oa(T.j.xa)
                      , Di = G.w.l.Oa(T.j.wa);
                    var j = this.zl();
                    G.w.T.Rm(oe, T.j.R, function() {
                        j.dp(),
                        G.w.g.ma(G.w.g.Vc)
                    }, function() {
                        G.w.T.um(function() {
                            G.w.l.ia(ue, T.j.R),
                            G.w.l.ia(pe, T.j.sa),
                            G.w.l.ia(Ie, T.j.va),
                            G.w.l.ia(_t, T.j.xa),
                            G.w.l.ia(Di, T.j.wa),
                            G.w.l.ia(oe, T.j.R),
                            j.dp()
                        })
                    })
                }
            }
            ,
            k.prototype.Mb = function(oe) {
                var q, j = G.w.l.ig(), ue = this.Wg();
                ue.pf() && (Q = ue.Cc(),
                ue = G.w.l.Ye(Q, T.j.R),
                q = !1,
                me(A, c("916370b07c70f2")),
                me(R, c("386819ff55fb1b")),
                G.w.l.za(Q, T.j.R) ? (me(I, c("0c3c2dab799737")),
                me(M, c("8fa1f2767ab270")),
                B["1ag"].includes(Q) ? fe(R, c("a7b9ca6e42aa48")) : fe(A, c("64d4c543014fcf"))) : (q = !0,
                fe(M, c("c636eb2da3ade9")),
                ue && ue.ff === 2 && (fe(I, c("7507945c901c1e")),
                _e(U, ue.pt))),
                _e(y, c("550f932dea0b7e3e6d") + Q),
                this.Ia.Nb(j.Oj(Q)),
                this.Ia.Xl(q),
                oe) && G.w.l.ia(Q, T.j.R)
            }
            ,
            ae.prototype.hn = function() {
                --this.ac < 0 && (this.ac = this.Zb.list.length - 1),
                this.je.Mb(!0)
            }
            ,
            ae.prototype.nn = function() {
                ++this.ac >= this.Zb.list.length && (this.ac = 0),
                this.je.Mb(!0)
            }
            ,
            ae.prototype.lf = function() {
                return this.ac >= this.Zb.list.length ? T.$b.kf() : T.$b.ah(this.Zb.list[this.ac])
            }
            ,
            ae);
            function ae(oe, q) {
                this.je = oe,
                this.ac = 0,
                this.Zb = q
            }
            return k
        }
        )(),
        T.ol = function() {
            let h = D(c("0b993fcdfcb4fe7076e9666dfea6ea"))
              , p = D(c("ff153341f040ea0462157e1fea4efe"))
              , _ = D(c("8311b74570427a57f857e4107c"))
              , g = D(c("bfd5f301348e361ba69baa"))
              , y = D(c("681c98881bc7dd6b1935dea6"))
              , M = D(c("6c93dd4b1f33d7ee16b1d8"))
              , A = D(c("8fe5a33164be662be4bcf6787e"))
              , R = D(c("ce7aa252b18ffb96b34aeb1db599f9"));
            $(R, c("8b5fe1176c2b"), () => {
                me(A, c("3eae63a52b2561"))
            }
            ),
            $(M, c("a0128e9ac79e"), () => {
                G.w.g.Rc.X(),
                fe(A, c("f90b185814189a"))
            }
            ),
            $(h, c("9ded733942f9"), () => {
                fe(_, c("9e4e0345cbc501")),
                fe(h, c("0272a7616fe1ad")),
                me(g, c("fa6adf7997f9a5")),
                me(p, c("72e257f11f715d")),
                _e(y, c("d8fa6e44ae483b9dd0946701c10d1692d18d0f09dc6e45d69eb2"))
            }
            ),
            $(p, c("2c1e0296536a"), () => {
                fe(p, c("621247010f814d")),
                fe(g, c("64d4c543014fcf")),
                me(_, c("c15320802c40a2")),
                me(h, c("899b68c86488ea")),
                _e(y, c("a2e010dad4524d0b9a9e298f8b0740648bf751f786061b2adfb80fa2cc26e522")),
                G.w.g.Rc.X()
            }
            )
        }
        ,
        T.rl = ( () => {
            let h = D(c("f8ec08788b374d8e63b201326a2327a4"))
              , p = D(c("1be92f3deca4ce6046f9406fc2ab"))
              , _ = D(c("778d4bd988d8929c1a9dec9d76c06d"))
              , g = D(c("0ebae2926157bb57738abfc57b58af486d"))
              , y = D(c("92866696e553375bff8634ccea"))
              , M = D(c("33c10715c092ca6b588f734bc784"))
              , A = D(c("44b0b4243f63f9da2ffede6d3557"))
              , R = D(c("acd8dc4cc7fb8142d766bbe2cce8"))
              , I = D(c("786c88f81daedd62e224bbb1e5a7"))
              , U = D(c("0b993fcdf8bae24370a74574feabfc"))
              , H = D(c("b90f09df4a54ccb1a2510f9b265da29c"))
              , Q = D(c("8074f0e0f3afb516eb3a8bbfe8"))
              , k = D(c("18cc68586b172dae43923016491a1092"))
              , Y = 0;
            var ae = z.aa(T.ga, function() {
                T.ga.call(this, c("2efc9cae462b9d2b51"), !0)
            })
              , oe = (ae.prototype.init = async function() {
                var j = this
                  , ue = this;
                this.Bc = [],
                this.sa = new oe(this,T.j.sa,p),
                this.va = new oe(this,T.j.va,_),
                this.xa = new oe(this,T.j.xa,g),
                this.wa = new oe(this,T.j.wa,y),
                this.Dk = this.yf = this.xf = this.wf = this.uf = this.xb = null,
                this.Ia = new T.Gf,
                await this.Ia.init(h),
                $(p, c("72e058ec156c"), () => {
                    ue.sd(j.sa)
                }
                ),
                $(_, c("8b5fe1176c2b"), () => {
                    ue.sd(j.va)
                }
                ),
                $(g, c("3f132ddba01f"), () => {
                    ue.sd(j.xa)
                }
                ),
                $(y, c("ee1cdce89168"), () => {
                    ue.sd(j.wa)
                }
                ),
                $(M, c("0a78a0746df4"), () => {
                    ue.xb.Tk()
                }
                ),
                $(A, c("2c1e0296536a"), () => {
                    ue.xb.Ok()
                }
                ),
                $(Q, c("c634e430a9b0"), () => {
                    Y && G.w.l.za(Y.G, Y.W) && (me(Q, c("c15320802c40a2")),
                    fe(k, c("43952642ae8eac")),
                    B["1ah"][Y.W].includes(Y.G) || B["1ah"][Y.W].push(Y.G),
                    Se())
                }
                ),
                $(k, c("59a9b7e5bea5"), () => {
                    Y && G.w.l.za(Y.G, Y.W) && (B["1ah"][Y.W] = B["1ah"][Y.W].filter(pe => pe !== Y.G),
                    fe(Q, c("21f3c020cce042")),
                    me(k, c("3d4fdc84a84426")),
                    Se())
                }
                ),
                this.Bc.push(this.sa),
                this.Bc.push(this.va),
                this.Bc.push(this.xa),
                this.Bc.push(this.wa)
            }
            ,
            ae.prototype.m = function() {
                ae.parent.prototype.m.call(this);
                let j = this;
                G.w.o.mf(function() {
                    var ue = G.w.o.$a.Yb;
                    j.uf = ue[c("1ba9646bec94c87157")],
                    j.wf = ue[c("b8e4957ec8658dcba9f276")],
                    j.xf = ue[c("72e458e405745d7a3ee25ff9")],
                    j.yf = ue[c("d5ae36fc2a8eb2efa9")],
                    j.Dk = ue[c("ce3cff0dbd91d08cb513")],
                    j.sa.qe(Object.keys(j.uf).map(pe => parseInt(pe))),
                    j.sa.se(j.uf),
                    j.va.qe(Object.keys(j.wf).map(pe => parseInt(pe))),
                    j.va.se(j.wf),
                    j.xa.qe(Object.keys(j.xf).map(pe => parseInt(pe))),
                    j.xa.se(j.xf),
                    j.wa.qe(Object.keys(j.yf).map(pe => parseInt(pe))),
                    j.wa.se(j.yf)
                }),
                this.Mb(!1),
                G.w.l.jg(function() {
                    j.Mb(!1)
                })
            }
            ,
            ae.prototype.X = function() {
                this.sd(this.xb ?? this.sa),
                this.Ia.Yc(!0)
            }
            ,
            ae.prototype.Sd = function() {
                this.Ia.Yc(!1)
            }
            ,
            ae.prototype.ea = function() {
                this.Ia.ea()
            }
            ,
            ae.prototype.Ha = function() {
                this.Ia.Ha()
            }
            ,
            ae.prototype.sd = function(j) {
                for (this.xb = j,
                j = 0; j < this.Bc.length; j++)
                    me(this.Bc[j].ii, c("520277113f917d"));
                fe(this.xb.ii, c("a335c6e24e2e4c")),
                this.xb.Ua()
            }
            ,
            ae.prototype.fl = function() {
                return this.xb == null ? T.$b.kf() : T.$b.ah({
                    G: this.xb.lf(),
                    W: this.xb.W
                })
            }
            ,
            ae.prototype.Mb = function(j) {
                var ue = G.w.l.ig()
                  , pe = this.fl();
                if (pe.pf()) {
                    Y = pe = pe.Cc();
                    var Ie = G.w.l.Ye(pe.G, pe.W)
                      , _t = !1;
                    switch (me(Q, c("e8d8494f854b4b")),
                    me(k, c("29fbc828c4e84a")),
                    G.w.l.za(pe.G, pe.W) ? (me(I, c("0597e4cce08c6e")),
                    me(H, c("11e3f030fcf072")),
                    B["1ah"][pe.W] || (B["1ah"][pe.W] = []),
                    B["1ah"][Y.W].includes(Y.G) ? fe(k, c("1bad7e7af6a6c4")) : fe(Q, c("d3e5b6b23efe3c"))) : (_t = !0,
                    fe(H, c("e8d8494f854b4b")),
                    Ie && Ie.ff === 2 && (fe(I, c("734516129e5e9c")),
                    _e(U, Ie.pt))),
                    _e(R, c("49f38f59feff6ab261") + pe.G),
                    Ie = this.Ia,
                    pe.W) {
                    case T.j.sa:
                        Ie.Nb(ue.Uj(pe.G)),
                        Ie.dm(_t);
                        break;
                    case T.j.va:
                        Ie.Nb(ue.bk(pe.G)),
                        Ie.hm(_t);
                        break;
                    case T.j.xa:
                        Ie.Nb(ue.nk(pe.G)),
                        Ie.rm(_t);
                        break;
                    case T.j.wa:
                        Ie.Nb(ue.ik(pe.G)),
                        Ie.lm(_t)
                    }
                    j && G.w.l.ia(pe.G, pe.W)
                }
            }
            ,
            q.prototype.qe = function(j) {
                this.Za = j.map(ue => [ue])
            }
            ,
            q.prototype.se = function(j) {
                this.qf = j
            }
            ,
            q.prototype.Ua = function() {
                for (var j = G.w.l.Oa(this.W), ue = 0; ue < this.Za.length; ue++)
                    for (var pe = 0; pe < this.Za[ue].length; pe++)
                        if (this.Za[ue][pe] === j)
                            return this.Be(ue),
                            void this.de(pe);
                this.Be(0),
                this.de(0)
            }
            ,
            q.prototype.Ok = function() {
                let j = this.yd - 1;
                j < 0 && (j = this.Za.length - 1),
                this.Be(j),
                this.de(this.ze % this.Za[j].length)
            }
            ,
            q.prototype.Tk = function() {
                let j = this.yd + 1;
                j >= this.Za.length && (j = 0),
                this.Be(j),
                this.de(this.ze % this.Za[j].length)
            }
            ,
            q.prototype.Be = function(j) {
                j < 0 || j >= this.Za.length || (this.yd = j)
            }
            ,
            q.prototype.de = function(j) {
                j < 0 || j >= this.Za[this.yd].length || (this.ze = j,
                this.je.Mb(!0))
            }
            ,
            q.prototype.lf = function() {
                return this.Za[this.yd][this.ze]
            }
            ,
            q);
            function q(j, ue, pe) {
                this.je = j,
                this.W = ue,
                this.ii = pe,
                this.qf = {},
                this.Za = [[]],
                this.ze = this.yd = -10
            }
            return ae
        }
        )(),
        T.$j = ((Us = z.aa(T.ga, function() {
            T.ga.call(this, c("8640216de2ff3efcf93a6211d1cc3ad6f3492c"), !1)
        })).prototype.m = function() {
            Us.parent.prototype.m.call(this)
        }
        ,
        Us.prototype.X = function() {}
        ,
        Us),
        T.lk = ((Gr = z.aa(T.ga, function() {
            T.ga.call(this, c("64f4c554074cc4cf498f9e5b152dd7b71daad8"), !1)
        })).prototype.m = function() {
            Gr.parent.prototype.m.call(this)
        }
        ,
        Gr.prototype.X = function() {}
        ,
        Gr.prototype.dq = function() {}
        ,
        Gr),
        T.Wc = (Wh.prototype.X = function() {}
        ,
        Wh),
        T.Pm = ((He = z.aa(T.Wc, function() {
            T.Wc.call(this)
        })).prototype.X = function() {
            G.w.Te.ho()
        }
        ,
        He),
        T.Mm = ((He = z.aa(T.Wc, function() {
            T.Wc.call(this)
        })).prototype.X = function() {
            G.w.Te.fo()
        }
        ,
        He),
        T.$n = ((He = z.aa(T.Wc, function() {
            T.Wc.call(this)
        })).prototype.X = function() {
            qt(function() {}, 0)
        }
        ,
        He),
        T.Wl = ((He = z.aa(T.ha, function() {
            T.ha.call(this, T.cb.mc)
        })).prototype.m = function() {}
        ,
        He.prototype.Ua = function() {}
        ,
        He.prototype.X = function() {}
        ,
        He),
        T.bm = ( () => {
            let h = D(c("3f557381b40e80c4352a2cceb905"))
              , p = D(c("28dc58485b07439a42731df1"))
              , _ = D(c("67bd5be98cfd80bb20d61490"))
              , g = D(c("649094040949da"))
              , y = D(c("d1676137223cfa6bbc242f692f63b37f80360666"))
              , M = z.aa(T.ha, function() {
                T.ha.call(this, T.cb.mc),
                $(h, c("6210481c059c"), () => {
                    me(p, c("209e12164a")),
                    me(_, c("67f719bf85")),
                    me(y, c("c8f8696fa56b6b")),
                    me(g, c("6d379c0d9d0d12401c0890")),
                    G.w.g.ma(G.w.g.Ba)
                }
                )
            });
            return M.prototype.m = function() {}
            ,
            M.prototype.Ua = function() {
                me(g, c("dbe5b3e338f10cb7")),
                fe(y, c("d8c8795fb55b7b")),
                fe(g, c("1c042dc24c9e03174d1b01")),
                fe(p, c("2bb35d7bc1"))
            }
            ,
            M.prototype.X = function() {}
            ,
            M
        }
        )(),
        z.om = function() {
            return (h = {
                ni: !1
            }).ri = z.Pe(),
            h.$c = 0,
            h.ug = 0,
            h.ro = null,
            h.h = null,
            h.o = null,
            h.Fd = null,
            h.Te = null,
            h.g = null,
            h.l = null,
            h.T = null,
            h.m = async function() {
                h.h = new T.Sm,
                h.h.$d = new T.vn(h.h),
                h.o = new T.La,
                await h.o.init(),
                h.Fd = new T.oj,
                await h.Fd.init(),
                h.Te = new T.vk,
                h.g = new T.wj,
                await h.g.init(),
                h.l = new T.nl,
                h.T = new T.tn,
                h.h.Pi = function() {
                    h.g.ma(h.g.ci)
                }
                ,
                h.h.Ri = function() {
                    h.g.Ba.Zg(),
                    h.g.ma(h.g.v.Td())
                }
                ,
                h.h.Ti = function() {
                    h.o.ti(null, null, null),
                    h.zn(Math.floor(h.h.V.Kb), h.h.$e)
                }
                ,
                h.h.Yi = function(p) {
                    p(h.g.v.Gb, h.g.v.rb)
                }
                ,
                h.T.km(function() {
                    var p = h.g.ln();
                    p != null && p.W === T.cb.We && h.g.ma(h.g.Ba),
                    h.T.ka && h.T.Ef(),
                    h.aj()
                }),
                h.h.m(),
                h.g.m(),
                h.l.m(),
                h.o.m(),
                h.g.ma(h.g.Ba),
                h.Fd.m(function() {
                    h.Te.m(),
                    h.T.m(),
                    h.o.ti(function() {
                        h.g.Ba.Tg(),
                        h.g.ma(h.g.Ba)
                    }, function() {
                        h.g.Ba.Tg(),
                        h.g.ma(h.g.Vc)
                    }, function(p, _) {
                        h.g.Cf.to(p, _),
                        h.g.Ba.to(p, _)
                    }),
                    h.aj()
                })
            }
            ,
            h.Ln = function() {}
            ,
            h.yn = function() {
                h.Xg()
            }
            ,
            h.Xg = function(p, _) {
                var g;
                Ti(1),
                N.pb && (N.pb.d = performance.now()),
                Mr.pk(),
                h.h.Dj() && (h.g.ma(h.g.Cf),
                g = h.g.Ba.Zg(),
                T.pa.ud(T.pa.zk, g),
                T.pa.ud(T.pa.fk, !0),
                h.T.ka ? (N.He = _,
                h.Jj(p)) : (p = h.g.Ba.oe(),
                T.pa.ud(T.pa.Hk, p),
                T.pa.ud(T.pa.nh, h.l.Oa(T.j.R))))
            }
            ,
            wo = function(p, _) {
                h.Xg(p, _)
            }
            ,
            h.Jj = async function(p=null) {
                var _ = B["1ak"]
                  , g = h.l.Oa(T.j.R)
                  , y = h.l.Oa(T.j.sa)
                  , M = h.l.Oa(T.j.va)
                  , A = h.l.Oa(T.j.xa)
                  , R = h.l.Oa(T.j.wa)
                  , I = (N.dh(0),
                N.$g(0),
                c("cc383cd9a3d57351a00b7cd4b7c7"));
                try {
                    var U = await (await fetch(I)).json();
                    U[c("a7bbc67e4e")] === 1460 ? h.g.ma(h.g.Kg) : U[c("ddad30f404")] !== 1200 ? h.g.ma(h.g.Vc) : (N.Ve = p || U[c("189a3f196a082cb055830e")],
                    h.h.Wj(N.Ve, _, g, y, M, A, R))
                } catch {
                    h.g.ma(h.g.Vc)
                }
            }
            ,
            h.On = function() {}
            ,
            h.zn = function(p, _) {
                h.g.Ba.oe(),
                h.g.v.Am(p, _),
                h.g.ma(h.g.v.Ue())
            }
            ,
            h.pj = function() {
                var p;
                return h.Qg() && (p = parseInt(T.pa.Pf(T.pa.nh))) != null && h.l.za(p, T.j.R) ? p : h.l.pi()
            }
            ,
            h.Nn = function(p) {
                T.pa.ud(T.pa.th, c(p ? "56936a9c3f" : "0c3b2fb36384"))
            }
            ,
            h.Qg = function() {
                return T.pa.Pf(T.pa.th) === c("9e5b1244c7")
            }
            ,
            h.aj = function() {
                h.ni !== !0 && (h.ni = !0,
                c("ae5c1f2fc1a61ab1d323"),
                c("2bbb496edda3de4c40815b52"))
            }
            ,
            h.bl = function() {
                return T.pa.Pf(T.pa.Yj) === c("95f2653d7c")
            }
            ,
            h.qo = function() {
                return !1
            }
            ,
            h.Ha = function() {
                h.$c = z.Pe(),
                h.ug = h.$c - h.ri,
                h.h.Cd(h.$c, h.ug),
                h.g.Cd(h.$c, h.ug),
                h.ri = h.$c
            }
            ,
            h.ea = function() {
                h.g.ea()
            }
            ,
            h;
            var h
        }
        ,
        T.Sm = function() {
            c("a2c617d08305584adec905deda");
            var h = {
                Ek: 30,
                fc: new Float32Array(100),
                oh: 0,
                qd: 0,
                td: 0,
                kc: 0,
                Lc: 0,
                gl: 0,
                na: 0,
                la: null,
                rh: 300,
                Hh: 0,
                Ri: function() {},
                Ti: function() {},
                Yi: function() {},
                Pi: function() {},
                B: new T.Xc,
                $d: null,
                V: null,
                Vb: {},
                tb: {},
                ui: 12.5,
                Jc: 40,
                zd: 1,
                Jh: -1,
                Lh: 1,
                Lg: 1,
                Qh: -1,
                Th: -1,
                Uh: 1,
                Yh: 1,
                ai: -1,
                $e: 500,
                ki: 500
            };
            return h.B.lh = 500,
            h.V = new T.ye(h.B),
            h.m = function() {
                h.V.Xh(G.w.g.v.C),
                setInterval(function() {
                    h.Yi(function(p, _) {
                        h.fr(p, _)
                    })
                }, 10)
            }
            ,
            h.dl = function(p, _, g, y) {
                h.Jh = p,
                h.Lh = _,
                h.Lg = g,
                h.Qh = y,
                h.ei()
            }
            ,
            h.im = function(p) {
                h.zd = p,
                h.ei()
            }
            ,
            h.ei = function() {
                h.Th = h.Jh - h.zd,
                h.Uh = h.Lh + h.zd,
                h.Yh = h.Lg - h.zd,
                h.ai = h.Qh + h.zd
            }
            ,
            h.Cd = function(p, _) {
                h.td += _,
                h.qd -= .2 * h.oh * _,
                h.$d.tj(),
                h.la == null || h.na !== 2 && h.na !== 3 || (h.pm(p, _),
                h.Jc = 4 + h.ui * h.V.hb),
                p = 1e3 / Math.max(1, _);
                for (var g = _ = 0; g < h.fc.length - 1; g++)
                    _ += h.fc[g],
                    h.fc[g] = h.fc[g + 1];
                h.fc[h.fc.length - 1] = p,
                h.Ek = (_ + p) / h.fc.length
            }
            ,
            h.Oe = function(p, _) {
                return h.Th < p && p < h.Uh && h.Yh < _ && _ < h.ai
            }
            ,
            h.pm = function(p, _) {
                var g, y, M = (h.td + h.qd - h.kc) / (h.Lc - h.kc), A = (h.V.re(p, _),
                h.V.ve(p, _, M, h.Oe),
                0);
                for (g in h.tb) {
                    var R = h.tb[g];
                    R.re(p, _),
                    R.ve(p, _, M, h.Oe),
                    R.ab && R.hb > A && (A = R.hb),
                    R.oc || !(R.Ma < .005) && R.ab || (R.Hd(),
                    delete h.tb[R.K.G])
                }
                for (y in h.im(3 * A),
                h.Vb)
                    M = h.Vb[y],
                    M.re(p, _),
                    M.ve(p, _, h.Oe),
                    M.Bg && (M.Ma < .005 || !h.Oe(M.tf, M.vf)) && (M.Hd(),
                    delete h.Vb[M.K.G])
            }
            ,
            h.ml = function(p, _) {
                h.na === 1 && (h.na = 2,
                h.Ri());
                var g = G.w.$c;
                (h.gl = p) === 0 ? (h.kc = g - 95,
                h.Lc = g,
                h.td = h.kc,
                h.qd = 0) : (h.kc = h.Lc,
                h.Lc += _),
                h.oh = (h.td + h.qd - h.kc) / (h.Lc - h.kc)
            }
            ,
            h.En = function() {
                var p;
                h.na !== 1 && h.na !== 2 || (h.na = 3,
                p = h.la,
                qt(function() {
                    h.na === 3 && (h.na = 0),
                    p != null && p === h.la && (h.la[c("4cfee2702344")](),
                    h.la = null)
                }, 3e3),
                h.Ti())
            }
            ,
            h.Dj = function() {
                return h.na = 1,
                h.$d.Og(),
                h.Vb = {},
                h.tb = {},
                h.V.Pg(),
                h.la != null && (h.la[c("ae5c1c2ec1a6")](),
                h.la = null),
                !0
            }
            ,
            h.mg = async function() {
                try {
                    (await (await fetch(c("9e0a5277c3c30d9094710456cdd202989c79") + B["1ak"])).json())[c("9ded703444")] === 201 && tt.location.reload()
                } catch {}
                h.la = null,
                h.$d.Og(),
                h.na !== 3 && h.Pi(),
                h.na = 0
            }
            ,
            h.Wj = function(p, _, g, y, M, A, R) {
                h.si(p, function() {
                    var I = Math.min(2048, _.length)
                      , U = new T.mh(17 + 2 * I)
                      , H = new T.hh(new T.Dg(U));
                    H.Je(98),
                    H.Fb(g),
                    H.Fb(y),
                    H.Fb(M),
                    H.Fb(A),
                    H.Fb(R),
                    H.cn(B["1y"]),
                    H.uj(B["1ae"]);
                    for (var Q = 0; Q < I; Q++)
                        H.Fb(_.charCodeAt(Q));
                    h.rg(U)
                })
            }
            ,
            h.Rn = function(p, _, g) {
                h.si(p, function() {
                    var y = Math.min(32, _.length)
                      , M = new T.mh(7 + 2 * y)
                      , A = new T.hh(new T.Dg(M));
                    A.Je(129),
                    A.Fb(2800),
                    A.Je(0),
                    A.Fb(g),
                    A.Je(y);
                    for (var R = 0; R < y; R++)
                        A.Fb(_.charCodeAt(R));
                    h.rg(M)
                })
            }
            ,
            h.rg = function(p) {
                try {
                    h.la != null && h.la.readyState === WebSocket.OPEN && h.la.send(p)
                } catch {
                    h.mg()
                }
            }
            ,
            h.fr = function(p, _) {
                p = z.tl(p) / 6.283185307179586 * 256 & 255,
                _ = N.zf << 1 | _ << 0,
                N.zf && (N.zf = !1),
                h.rh === p && h.Hh == _ || (h.rg(new Uint8Array([p, _]).buffer),
                h.rh = p,
                h.Hh = _)
            }
            ,
            h.si = function(p, _) {
                var g = h.la = new WebSocket(p);
                g[c("370a50c4da1ec4fa460024")] = c("c636fa2baba2eea8a839f513"),
                g[c("0ef0bece6246ba")] = function() {
                    for (var y in N.af = !0,
                    N.k)
                        G.w.g.v.C.t.removeChild(N.k[y]),
                        delete N.k[y];
                    h.la === g && _()
                }
                ,
                g[c("36a896aa56248f28")] = function() {
                    N.af = !1,
                    h.la === g && h.mg()
                }
                ,
                g[c("0c3220ba62933d11")] = function() {
                    N.af = !1,
                    h.la === g && h.mg()
                }
                ,
                g[c("f9051541181d8c516617")] = function(y) {
                    h.la === g && h.$d.mj(y.data)
                }
            }
            ,
            h
        }
        ,
        $(tt, c("d0c27d4da0406ed3b5cc745e"), function(h) {
            return h.preventDefault(),
            h.stopPropagation(),
            !1
        }),
        G.w = z.om(),
        await G.w.m(),
        i(),
        $(tt, c("0908ee4fe4046a"), i),
        (function h() {
            requestAnimationFrame(h),
            G.w.Ha()
        }
        )()
    });
}
)();
